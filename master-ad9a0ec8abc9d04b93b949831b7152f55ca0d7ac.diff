--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/machine_mem.c	2020-05-01 00:05:34.638251632 +0200
+++ micropython-master-no_nlr/extmod/machine_mem.c	2020-04-30 23:32:39.440155538 +0200
@@ -42,7 +42,8 @@
 STATIC uintptr_t machine_mem_get_addr(mp_obj_t addr_o, uint align) {
     uintptr_t addr = mp_obj_int_get_truncated(addr_o);
     if ((addr & (align - 1)) != 0) {
-        mp_raise_msg_varg(&mp_type_ValueError, "address %08x is not aligned to %d bytes", addr, align);
+        //mp_raise_msg_varg(&mp_type_ValueError, "address %08x is not aligned to %d bytes", addr, align);
+        mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "address %08x is not aligned to %d bytes", addr, align));
     }
     return addr;
 }
@@ -69,6 +70,9 @@
     } else if (value == MP_OBJ_SENTINEL) {
         // load
         uintptr_t addr = MICROPY_MACHINE_MEM_GET_READ_ADDR(index, self->elem_size);
+        if (MP_STATE_THREAD(active_exception) != NULL) {
+            return MP_OBJ_NULL;
+        }
         uint32_t val;
         switch (self->elem_size) {
             case 1:
@@ -85,6 +89,9 @@
     } else {
         // store
         uintptr_t addr = MICROPY_MACHINE_MEM_GET_WRITE_ADDR(index, self->elem_size);
+        if (MP_STATE_THREAD(active_exception) != NULL) {
+            return MP_OBJ_NULL;
+        }
         uint32_t val = mp_obj_get_int_truncated(value);
         switch (self->elem_size) {
             case 1:
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/machine_signal.c	2020-05-01 00:05:34.638251632 +0200
+++ micropython-master-no_nlr/extmod/machine_signal.c	2020-04-30 23:32:39.440155538 +0200
@@ -104,7 +104,7 @@
             }
         } else {
         error:
-            mp_raise_TypeError(NULL);
+            return mp_raise_TypeError_o(NULL);
         }
     }
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/modbtree.c	2020-05-01 00:05:34.638251632 +0200
+++ micropython-master-no_nlr/extmod/modbtree.c	2020-04-30 23:34:41.540427216 +0200
@@ -58,7 +58,7 @@
 
 #define CHECK_ERROR(res) \
     if (res == RET_ERROR) { \
-        mp_raise_OSError(errno); \
+        return mp_raise_OSError_o(errno); \
     }
 
 void __dbpanic(DB *db) {
@@ -256,7 +256,8 @@
         key.data = (void *)mp_obj_str_get_data(index, &key.size);
         int res = __bt_delete(self->db, &key, 0);
         if (res == RET_SPECIAL) {
-            mp_raise_type(&mp_type_KeyError);
+            //mp_raise_type(&mp_type_KeyError);
+            return mp_raise_o(mp_obj_new_exception(&mp_type_KeyError));
         }
         CHECK_ERROR(res);
         return mp_const_none;
@@ -266,7 +267,8 @@
         key.data = (void *)mp_obj_str_get_data(index, &key.size);
         int res = __bt_get(self->db, &key, &val, 0);
         if (res == RET_SPECIAL) {
-            mp_raise_type(&mp_type_KeyError);
+            //mp_raise_type(&mp_type_KeyError);
+            return mp_raise_o(mp_obj_new_exception(&mp_type_KeyError));
         }
         CHECK_ERROR(res);
         return mp_obj_new_bytes(val.data, val.size);
@@ -359,7 +361,7 @@
 
     DB *db = __bt_open(MP_OBJ_TO_PTR(pos_args[0]), &btree_stream_fvtable, &openinfo, /*dflags*/ 0);
     if (db == NULL) {
-        mp_raise_OSError(errno);
+        return mp_raise_OSError_o(errno);
     }
     return MP_OBJ_FROM_PTR(btree_new(db));
 }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/modframebuf.c	2020-05-01 00:05:34.638251632 +0200
+++ micropython-master-no_nlr/extmod/modframebuf.c	2020-04-30 23:32:39.442155510 +0200
@@ -300,7 +300,7 @@
         case FRAMEBUF_GS8:
             break;
         default:
-            mp_raise_ValueError("invalid format");
+            return mp_raise_ValueError_o("invalid format");
     }
 
     return MP_OBJ_FROM_PTR(o);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/modubinascii.c	2020-05-01 00:05:34.640251605 +0200
+++ micropython-master-no_nlr/extmod/modubinascii.c	2020-04-30 23:32:39.442155510 +0200
@@ -78,7 +78,7 @@
     mp_get_buffer_raise(data, &bufinfo, MP_BUFFER_READ);
 
     if ((bufinfo.len & 1) != 0) {
-        mp_raise_ValueError("odd-length string");
+        return mp_raise_ValueError_o("odd-length string");
     }
     vstr_t vstr;
     vstr_init_len(&vstr, bufinfo.len / 2);
@@ -89,7 +89,7 @@
         if (unichar_isxdigit(hex_ch)) {
             hex_byte += unichar_xdigit_value(hex_ch);
         } else {
-            mp_raise_ValueError("non-hex digit found");
+            return mp_raise_ValueError_o("non-hex digit found");
         }
         if (i & 1) {
             hex_byte <<= 4;
@@ -157,7 +157,7 @@
     }
 
     if (nbits) {
-        mp_raise_ValueError("incorrect padding");
+        return mp_raise_ValueError_o("incorrect padding");
     }
 
     return mp_obj_new_str_from_vstr(&mp_type_bytes, &vstr);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/moducryptolib.c	2020-05-01 00:05:34.640251605 +0200
+++ micropython-master-no_nlr/extmod/moducryptolib.c	2020-04-30 23:32:39.442155510 +0200
@@ -225,7 +225,7 @@
             break;
 
         default:
-            mp_raise_ValueError("mode");
+            return mp_raise_ValueError_o("mode");
     }
 
     mp_obj_aes_t *o = m_new_obj_var(mp_obj_aes_t, struct ctr_params, !!is_ctr_mode(block_mode));
@@ -237,7 +237,7 @@
     mp_buffer_info_t keyinfo;
     mp_get_buffer_raise(args[0], &keyinfo, MP_BUFFER_READ);
     if (32 != keyinfo.len && 16 != keyinfo.len) {
-        mp_raise_ValueError("key");
+        return mp_raise_ValueError_o("key");
     }
 
     mp_buffer_info_t ivinfo;
@@ -246,10 +246,10 @@
         mp_get_buffer_raise(args[2], &ivinfo, MP_BUFFER_READ);
 
         if (16 != ivinfo.len) {
-            mp_raise_ValueError("IV");
+            return mp_raise_ValueError_o("IV");
         }
     } else if (o->block_mode == UCRYPTOLIB_MODE_CBC || is_ctr_mode(o->block_mode)) {
-        mp_raise_ValueError("IV");
+        return mp_raise_ValueError_o("IV");
     }
 
     if (is_ctr_mode(block_mode)) {
@@ -274,7 +274,7 @@
     mp_get_buffer_raise(in_buf, &in_bufinfo, MP_BUFFER_READ);
 
     if (!is_ctr_mode(self->block_mode) && in_bufinfo.len % 16 != 0) {
-        mp_raise_ValueError("blksize % 16");
+        return mp_raise_ValueError_o("blksize % 16");
     }
 
     vstr_t vstr;
@@ -284,7 +284,7 @@
     if (out_buf != MP_OBJ_NULL) {
         mp_get_buffer_raise(out_buf, &out_bufinfo, MP_BUFFER_WRITE);
         if (out_bufinfo.len < in_bufinfo.len) {
-            mp_raise_ValueError("output too small");
+            return mp_raise_ValueError_o("output too small");
         }
         out_buf_ptr = out_bufinfo.buf;
     } else {
@@ -301,7 +301,7 @@
         if ((encrypt && self->key_type == AES_KEYTYPE_DEC) ||
             (!encrypt && self->key_type == AES_KEYTYPE_ENC)) {
 
-            mp_raise_ValueError("can't encrypt & decrypt");
+            return mp_raise_ValueError_o("can't encrypt & decrypt");
         }
     }
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/moductypes.c	2020-05-01 00:05:34.640251605 +0200
+++ micropython-master-no_nlr/extmod/moductypes.c	2020-04-30 23:37:13.208280805 +0200
@@ -116,8 +116,8 @@
     uint32_t flags;
 } mp_obj_uctypes_struct_t;
 
-STATIC NORETURN void syntax_error(void) {
-    mp_raise_TypeError("syntax error in uctypes descriptor");
+STATIC mp_obj_t syntax_error(void) {
+    return mp_raise_TypeError_o("syntax error in uctypes descriptor");
 }
 
 STATIC mp_obj_t uctypes_struct_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
@@ -226,9 +226,11 @@
             // but scalar structure field is lowered into native Python int, so all
             // type info is lost. So, we cannot say if it's scalar type description,
             // or such lowered scalar.
-            mp_raise_TypeError("Cannot unambiguously get sizeof scalar");
+            mp_raise_TypeError_o("Cannot unambiguously get sizeof scalar");
+            return (mp_uint_t)-1;
         }
         syntax_error();
+        return (mp_uint_t)-1;
     }
 
     mp_obj_dict_t *d = MP_OBJ_TO_PTR(desc_in);
@@ -254,6 +256,7 @@
             } else {
                 if (!mp_obj_is_type(v, &mp_type_tuple)) {
                     syntax_error();
+                    return (mp_uint_t)-1;
                 }
                 mp_obj_tuple_t *t = MP_OBJ_TO_PTR(v);
                 mp_int_t offset = MP_OBJ_SMALL_INT_VALUE(t->items[0]);
@@ -284,7 +287,7 @@
     // or to instantiated structure
     if (mp_obj_is_type(obj_in, &uctypes_struct_type)) {
         if (n_args != 1) {
-            mp_raise_TypeError(NULL);
+            return mp_raise_TypeError_o(NULL);
         }
         // Extract structure definition
         mp_obj_uctypes_struct_t *obj = MP_OBJ_TO_PTR(obj_in);
@@ -296,6 +299,9 @@
         }
     }
     mp_uint_t size = uctypes_struct_size(obj_in, layout_type, &max_field_size);
+    if (size == (mp_uint_t)-1) {
+        return MP_OBJ_NULL;
+    }
     return MP_OBJ_NEW_SMALL_INT(size);
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(uctypes_struct_sizeof_obj, 1, 2, uctypes_struct_sizeof);
@@ -424,7 +430,7 @@
         && !mp_obj_is_type(self->desc, &mp_type_ordereddict)
         #endif
         ) {
-        mp_raise_TypeError("struct: no fields");
+        return mp_raise_TypeError_o("struct: no fields");
     }
 
     mp_obj_t deref = mp_obj_dict_get(self->desc, MP_OBJ_NEW_QSTR(attr));
@@ -490,12 +496,12 @@
     }
 
     if (!mp_obj_is_type(deref, &mp_type_tuple)) {
-        syntax_error();
+        return syntax_error();
     }
 
     if (set_val != MP_OBJ_NULL) {
         // Cannot assign to aggregate
-        syntax_error();
+        return syntax_error();
     }
 
     mp_obj_tuple_t *sub = MP_OBJ_TO_PTR(deref);
@@ -557,7 +563,7 @@
     } else {
         // load / store
         if (!mp_obj_is_type(self->desc, &mp_type_tuple)) {
-            mp_raise_TypeError("struct: cannot index");
+            return mp_raise_TypeError_o("struct: cannot index");
         }
 
         mp_obj_tuple_t *t = MP_OBJ_TO_PTR(self->desc);
@@ -571,7 +577,8 @@
             uint val_type = GET_TYPE(arr_sz, VAL_TYPE_BITS);
             arr_sz &= VALUE_MASK(VAL_TYPE_BITS);
             if (index >= arr_sz) {
-                mp_raise_msg(&mp_type_IndexError, "struct: index out of range");
+                //mp_raise_msg(&mp_type_IndexError, "struct: index out of range");
+                return mp_raise_o(mp_obj_new_exception_msg(&mp_type_IndexError, "struct: index out of range"));
             }
 
             if (t->len == 2) {
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/moduheapq.c	2020-05-01 00:05:34.640251605 +0200
+++ micropython-master-no_nlr/extmod/moduheapq.c	2020-04-30 23:32:39.444155482 +0200
@@ -33,7 +33,8 @@
 
 STATIC mp_obj_list_t *uheapq_get_heap(mp_obj_t heap_in) {
     if (!mp_obj_is_type(heap_in, &mp_type_list)) {
-        mp_raise_TypeError("heap must be a list");
+        mp_raise_TypeError_o("heap must be a list");
+        return NULL;
     }
     return MP_OBJ_TO_PTR(heap_in);
 }
@@ -72,6 +73,9 @@
 
 STATIC mp_obj_t mod_uheapq_heappush(mp_obj_t heap_in, mp_obj_t item) {
     mp_obj_list_t *heap = uheapq_get_heap(heap_in);
+    if (heap == NULL) {
+        return MP_OBJ_NULL;
+    }
     mp_obj_list_append(heap_in, item);
     uheapq_heap_siftdown(heap, 0, heap->len - 1);
     return mp_const_none;
@@ -80,8 +84,12 @@
 
 STATIC mp_obj_t mod_uheapq_heappop(mp_obj_t heap_in) {
     mp_obj_list_t *heap = uheapq_get_heap(heap_in);
+    if (heap == NULL) {
+        return MP_OBJ_NULL;
+    }
     if (heap->len == 0) {
-        mp_raise_msg(&mp_type_IndexError, "empty heap");
+        //mp_raise_msg(&mp_type_IndexError, "empty heap");
+        return mp_raise_o(mp_obj_new_exception_msg(&mp_type_IndexError, "empty heap"));
     }
     mp_obj_t item = heap->items[0];
     heap->len -= 1;
@@ -96,6 +104,9 @@
 
 STATIC mp_obj_t mod_uheapq_heapify(mp_obj_t heap_in) {
     mp_obj_list_t *heap = uheapq_get_heap(heap_in);
+    if (heap == NULL) {
+        return MP_OBJ_NULL;
+    }
     for (mp_uint_t i = heap->len / 2; i > 0;) {
         uheapq_heap_siftup(heap, --i);
     }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/modujson.c	2020-05-01 00:05:34.640251605 +0200
+++ micropython-master-no_nlr/extmod/modujson.c	2020-04-30 23:56:42.933755352 +0200
@@ -35,7 +35,9 @@
 #if MICROPY_PY_UJSON
 
 STATIC mp_obj_t mod_ujson_dump(mp_obj_t obj, mp_obj_t stream) {
-    mp_get_stream_raise(stream, MP_STREAM_OP_WRITE);
+    if (mp_get_stream_raise(stream, MP_STREAM_OP_WRITE) == NULL) {
+        return MP_OBJ_NULL;
+    }
     mp_print_t print = {MP_OBJ_TO_PTR(stream), mp_stream_write_adaptor};
     mp_obj_print_helper(&print, obj, PRINT_JSON);
     return mp_const_none;
@@ -79,7 +81,9 @@
 STATIC byte ujson_stream_next(ujson_stream_t *s) {
     mp_uint_t ret = s->read(s->stream_obj, &s->cur, 1, &s->errcode);
     if (s->errcode != 0) {
-        mp_raise_OSError(s->errcode);
+        // TODO deal with raising exception
+        mp_raise_OSError_o(s->errcode);
+        return 0xff;
     }
     if (ret == 0) {
         s->cur = S_EOF;
@@ -295,7 +299,7 @@
     return stack_top;
 
 fail:
-    mp_raise_ValueError("syntax error in JSON");
+    return mp_raise_ValueError_o("syntax error in JSON");
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_1(mod_ujson_load_obj, mod_ujson_load);
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/modurandom.c	2020-05-01 00:05:34.640251605 +0200
+++ micropython-master-no_nlr/extmod/modurandom.c	2020-04-30 23:32:39.444155482 +0200
@@ -74,7 +74,7 @@
 STATIC mp_obj_t mod_urandom_getrandbits(mp_obj_t num_in) {
     int n = mp_obj_get_int(num_in);
     if (n > 32 || n == 0) {
-        mp_raise_ValueError(NULL);
+        return mp_raise_ValueError_o(NULL);
     }
     uint32_t mask = ~0;
     // Beware of C undefined behavior when shifting by >= than bit size
@@ -133,7 +133,7 @@
     }
 
 error:
-    mp_raise_ValueError(NULL);
+    return mp_raise_ValueError_o(NULL);
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_urandom_randrange_obj, 1, 3, mod_urandom_randrange);
 
@@ -143,7 +143,7 @@
     if (a <= b) {
         return mp_obj_new_int(a + yasmarang_randbelow(b - a + 1));
     } else {
-        mp_raise_ValueError(NULL);
+        return mp_raise_ValueError_o(NULL);
     }
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_2(mod_urandom_randint_obj, mod_urandom_randint);
@@ -153,7 +153,8 @@
     if (len > 0) {
         return mp_obj_subscr(seq, mp_obj_new_int(yasmarang_randbelow(len)), MP_OBJ_SENTINEL);
     } else {
-        mp_raise_type(&mp_type_IndexError);
+        //mp_raise_type(&mp_type_IndexError);
+        return mp_raise_o(mp_obj_new_exception(&mp_type_IndexError));
     }
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_1(mod_urandom_choice_obj, mod_urandom_choice);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/modure.c	2020-05-01 00:05:34.640251605 +0200
+++ micropython-master-no_nlr/extmod/modure.c	2020-04-30 23:57:51.006794920 +0200
@@ -64,7 +64,7 @@
     mp_obj_match_t *self = MP_OBJ_TO_PTR(self_in);
     mp_int_t no = mp_obj_get_int(no_in);
     if (no < 0 || no >= self->num_matches) {
-        nlr_raise(mp_obj_new_exception_arg1(&mp_type_IndexError, no_in));
+        return mp_raise_o(mp_obj_new_exception_arg1(&mp_type_IndexError, no_in));
     }
 
     const char *start = self->caps[no * 2];
@@ -96,14 +96,15 @@
 
 #if MICROPY_PY_URE_MATCH_SPAN_START_END
 
-STATIC void match_span_helper(size_t n_args, const mp_obj_t *args, mp_obj_t span[2]) {
+STATIC int match_span_helper(size_t n_args, const mp_obj_t *args, mp_obj_t span[2]) {
     mp_obj_match_t *self = MP_OBJ_TO_PTR(args[0]);
 
     mp_int_t no = 0;
     if (n_args == 2) {
         no = mp_obj_get_int(args[1]);
         if (no < 0 || no >= self->num_matches) {
-            nlr_raise(mp_obj_new_exception_arg1(&mp_type_IndexError, args[1]));
+            mp_raise_o(mp_obj_new_exception_arg1(&mp_type_IndexError, args[1]));
+            return 1;
         }
     }
 
@@ -119,25 +120,33 @@
 
     span[0] = mp_obj_new_int(s);
     span[1] = mp_obj_new_int(e);
+
+    return 0;
 }
 
 STATIC mp_obj_t match_span(size_t n_args, const mp_obj_t *args) {
     mp_obj_t span[2];
-    match_span_helper(n_args, args, span);
+    if (match_span_helper(n_args, args, span)) {
+        return MP_OBJ_NULL;
+    }
     return mp_obj_new_tuple(2, span);
 }
 MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(match_span_obj, 1, 2, match_span);
 
 STATIC mp_obj_t match_start(size_t n_args, const mp_obj_t *args) {
     mp_obj_t span[2];
-    match_span_helper(n_args, args, span);
+    if (match_span_helper(n_args, args, span)) {
+        return MP_OBJ_NULL;
+    }
     return span[0];
 }
 MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(match_start_obj, 1, 2, match_start);
 
 STATIC mp_obj_t match_end(size_t n_args, const mp_obj_t *args) {
     mp_obj_t span[2];
-    match_span_helper(n_args, args, span);
+    if (match_span_helper(n_args, args, span)) {
+        return MP_OBJ_NULL;
+    }
     return span[1];
 }
 MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(match_end_obj, 1, 2, match_end);
@@ -185,6 +194,10 @@
     // cast is a workaround for a bug in msvc: it treats const char** as a const pointer instead of a pointer to pointer to const char
     memset((char *)match->caps, 0, caps_num * sizeof(char *));
     int res = re1_5_recursiveloopprog(&self->re, &subj, match->caps, caps_num, is_anchored);
+    if (res == -1) {
+        // exception
+        return MP_OBJ_NULL;
+    }
     if (res == 0) {
         m_del_var(mp_obj_match_t, char *, caps_num, match);
         return mp_const_none;
@@ -226,6 +239,10 @@
         // cast is a workaround for a bug in msvc: it treats const char** as a const pointer instead of a pointer to pointer to const char
         memset((char **)caps, 0, caps_num * sizeof(char *));
         int res = re1_5_recursiveloopprog(&self->re, &subj, caps, caps_num, false);
+        if (res == -1) {
+            // exception
+            return MP_OBJ_NULL;
+        }
 
         // if we didn't have a match, or had an empty match, it's time to stop
         if (!res || caps[0] == caps[1]) {
@@ -235,7 +252,7 @@
         mp_obj_t s = mp_obj_new_str_of_type(str_type, (const byte *)subj.begin, caps[0] - subj.begin);
         mp_obj_list_append(retval, s);
         if (self->re.sub > 0) {
-            mp_raise_NotImplementedError("Splitting with sub-captures");
+            return mp_raise_NotImplementedError_o("Splitting with sub-captures");
         }
         subj.begin = caps[1];
         if (maxsplit > 0 && --maxsplit == 0) {
@@ -281,6 +298,10 @@
         // cast is a workaround for a bug in msvc: it treats const char** as a const pointer instead of a pointer to pointer to const char
         memset((char *)match->caps, 0, caps_num * sizeof(char *));
         int res = re1_5_recursiveloopprog(&self->re, &subj, match->caps, caps_num, false);
+        if (res == -1) {
+            // exception
+            return MP_OBJ_NULL;
+        }
 
         // If we didn't have a match, or had an empty match, it's time to stop
         if (!res || match->caps[0] == match->caps[1]) {
@@ -320,7 +341,7 @@
                     }
 
                     if (match_no >= (unsigned int)match->num_matches) {
-                        nlr_raise(mp_obj_new_exception_arg1(&mp_type_IndexError, MP_OBJ_NEW_SMALL_INT(match_no)));
+                        return mp_raise_o(mp_obj_new_exception_arg1(&mp_type_IndexError, MP_OBJ_NEW_SMALL_INT(match_no)));
                     }
 
                     const char *start_match = match->caps[match_no * 2];
@@ -402,8 +423,8 @@
     #endif
     int error = re1_5_compilecode(&o->re, re_str);
     if (error != 0) {
-    error:
-        mp_raise_ValueError("Error in regex");
+error:
+        return mp_raise_ValueError_o("Error in regex");
     }
     #if MICROPY_PY_URE_DEBUG
     if (flags & FLAG_DEBUG) {
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/modussl_axtls.c	2020-05-01 00:05:34.640251605 +0200
+++ micropython-master-no_nlr/extmod/modussl_axtls.c	2020-04-30 23:59:44.565192585 +0200
@@ -54,7 +54,7 @@
 
 STATIC const mp_obj_type_t ussl_socket_type;
 
-STATIC mp_obj_ssl_socket_t *ussl_socket_new(mp_obj_t sock, struct ssl_args *args) {
+STATIC mp_obj_t ussl_socket_new(mp_obj_t sock, struct ssl_args *args) {
     #if MICROPY_PY_USSL_FINALISER
     mp_obj_ssl_socket_t *o = m_new_obj_with_finaliser(mp_obj_ssl_socket_t);
     #else
@@ -74,7 +74,7 @@
         options |= SSL_NO_DEFAULT_KEY;
     }
     if ((o->ssl_ctx = ssl_ctx_new(options, SSL_DEFAULT_CLNT_SESS)) == NULL) {
-        mp_raise_OSError(MP_EINVAL);
+        return mp_raise_OSError_o(MP_EINVAL);
     }
 
     if (args->key.u_obj != mp_const_none) {
@@ -82,13 +82,16 @@
         const byte *data = (const byte *)mp_obj_str_get_data(args->key.u_obj, &len);
         int res = ssl_obj_memory_load(o->ssl_ctx, SSL_OBJ_RSA_KEY, data, len, NULL);
         if (res != SSL_OK) {
-            mp_raise_ValueError("invalid key");
+            return mp_raise_ValueError_o("invalid key");
         }
 
         data = (const byte *)mp_obj_str_get_data(args->cert.u_obj, &len);
+        if (data == NULL) {
+            return MP_OBJ_NULL;
+        }
         res = ssl_obj_memory_load(o->ssl_ctx, SSL_OBJ_X509_CERT, data, len, NULL);
         if (res != SSL_OK) {
-            mp_raise_ValueError("invalid cert");
+            return mp_raise_ValueError_o("invalid cert");
         }
     }
 
@@ -109,13 +112,13 @@
             if (res != SSL_OK) {
                 printf("ssl_handshake_status: %d\n", res);
                 ssl_display_error(res);
-                mp_raise_OSError(MP_EIO);
+                return mp_raise_OSError_o(MP_EIO);
             }
         }
 
     }
 
-    return o;
+    return MP_OBJ_FROM_PTR(o);
 }
 
 STATIC void ussl_socket_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
@@ -260,7 +263,7 @@
     mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args,
         MP_ARRAY_SIZE(allowed_args), allowed_args, (mp_arg_val_t *)&args);
 
-    return MP_OBJ_FROM_PTR(ussl_socket_new(sock, &args));
+    return ussl_socket_new(sock, &args);
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_KW(mod_ssl_wrap_socket_obj, 1, mod_ssl_wrap_socket);
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/modutimeq.c	2020-05-01 00:05:34.640251605 +0200
+++ micropython-master-no_nlr/extmod/modutimeq.c	2020-04-30 23:32:39.444155482 +0200
@@ -126,7 +126,7 @@
     mp_obj_t heap_in = args[0];
     mp_obj_utimeq_t *heap = utimeq_get_heap(heap_in);
     if (heap->len == heap->alloc) {
-        mp_raise_msg(&mp_type_IndexError, "queue overflow");
+        return mp_raise_msg_o(&mp_type_IndexError, "queue overflow");
     }
     mp_uint_t l = heap->len;
     heap->items[l].time = MP_OBJ_SMALL_INT_VALUE(args[1]);
@@ -142,11 +142,13 @@
 STATIC mp_obj_t mod_utimeq_heappop(mp_obj_t heap_in, mp_obj_t list_ref) {
     mp_obj_utimeq_t *heap = utimeq_get_heap(heap_in);
     if (heap->len == 0) {
-        mp_raise_msg(&mp_type_IndexError, "empty heap");
+        //mp_raise_msg(&mp_type_IndexError, "empty heap");
+        return mp_raise_o(mp_obj_new_exception_msg(&mp_type_IndexError, "empty heap"));
     }
     mp_obj_list_t *ret = MP_OBJ_TO_PTR(list_ref);
     if (!mp_obj_is_type(list_ref, &mp_type_list) || ret->len < 3) {
-        mp_raise_TypeError(NULL);
+        //mp_raise_TypeError(NULL);
+        return mp_raise_TypeError_o(NULL);
     }
 
     struct qentry *item = &heap->items[0];
@@ -167,7 +169,8 @@
 STATIC mp_obj_t mod_utimeq_peektime(mp_obj_t heap_in) {
     mp_obj_utimeq_t *heap = utimeq_get_heap(heap_in);
     if (heap->len == 0) {
-        mp_raise_msg(&mp_type_IndexError, "empty heap");
+        //mp_raise_msg(&mp_type_IndexError, "empty heap");
+        return mp_raise_o(mp_obj_new_exception_msg(&mp_type_IndexError, "empty heap"));
     }
 
     struct qentry *item = &heap->items[0];
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/moduzlib.c	2020-05-01 00:05:34.642251576 +0200
+++ micropython-master-no_nlr/extmod/moduzlib.c	2020-05-01 00:01:24.547781618 +0200
@@ -58,10 +58,14 @@
     byte c;
     mp_uint_t out_sz = stream->read(self->src_stream, &c, 1, &err);
     if (out_sz == MP_STREAM_ERROR) {
-        mp_raise_OSError(err);
+        // TODO deal with raising exception
+        mp_raise_OSError_o(err);
+        return -1;
     }
     if (out_sz == 0) {
-        mp_raise_type(&mp_type_EOFError);
+        //mp_raise_type(&mp_type_EOFError);
+        mp_raise_o(mp_obj_new_exception(&mp_type_EOFError));
+        return -1;
     }
     return c;
 }
@@ -91,8 +95,8 @@
     } else if (dict_opt >= 0) {
         dict_opt = uzlib_zlib_parse_header(&o->decomp);
         if (dict_opt < 0) {
-        header_error:
-            mp_raise_ValueError("compression header");
+header_error:
+            return mp_raise_ValueError_o("compression header");
         }
         dict_sz = 1 << dict_opt;
     } else {
@@ -201,7 +205,7 @@
     return res;
 
 error:
-    nlr_raise(mp_obj_new_exception_arg1(&mp_type_ValueError, MP_OBJ_NEW_SMALL_INT(st)));
+    return mp_raise_o(mp_obj_new_exception_arg1(&mp_type_ValueError, MP_OBJ_NEW_SMALL_INT(st)));
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_uzlib_decompress_obj, 1, 3, mod_uzlib_decompress);
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/re1.5/recursiveloop.c	2020-04-17 09:19:09.158301165 +0200
+++ micropython-master-no_nlr/extmod/re1.5/recursiveloop.c	2020-04-17 12:45:36.361620189 +0200
@@ -9,8 +9,9 @@
 {
 	const char *old;
 	int off;
+	int ret;
 
-	re1_5_stack_chk();
+	if (re1_5_stack_chk()) return -1;
 
 	for(;;) {
 		if(inst_is_consumer(*pc)) {
@@ -46,14 +47,14 @@
 			continue;
 		case Split:
 			off = (signed char)*pc++;
-			if(recursiveloop(pc, sp, input, subp, nsubp))
-				return 1;
+			if((ret = recursiveloop(pc, sp, input, subp, nsubp)))
+				return ret;
 			pc = pc + off;
 			continue;
 		case RSplit:
 			off = (signed char)*pc++;
-			if(recursiveloop(pc + off, sp, input, subp, nsubp))
-				return 1;
+			if((ret = recursiveloop(pc + off, sp, input, subp, nsubp)))
+				return ret;
 			continue;
 		case Save:
 			off = (unsigned char)*pc++;
@@ -62,8 +63,8 @@
 			}
 			old = subp[off];
 			subp[off] = sp;
-			if(recursiveloop(pc, sp, input, subp, nsubp))
-				return 1;
+			if((ret = recursiveloop(pc, sp, input, subp, nsubp)))
+				return ret;
 			subp[off] = old;
 			return 0;
 		case Bol:
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/vfs.c	2020-05-01 00:56:48.642186087 +0200
+++ micropython-master-no_nlr/extmod/vfs.c	2020-05-01 00:53:18.269052928 +0200
@@ -112,11 +112,11 @@
     assert(n_args <= PROXY_MAX_ARGS);
     if (vfs == MP_VFS_NONE) {
         // mount point not found
-        mp_raise_OSError(MP_ENODEV);
+        return mp_raise_OSError_o(MP_ENODEV);
     }
     if (vfs == MP_VFS_ROOT) {
         // can't do operation on root dir
-        mp_raise_OSError(MP_EPERM);
+        return mp_raise_OSError_o(MP_EPERM);
     }
     mp_obj_t meth[2 + PROXY_MAX_ARGS];
     mp_load_method(vfs->obj, meth_name, meth);
@@ -141,13 +141,10 @@
 
     // delegate to vfs.stat() method
     mp_obj_t path_o = mp_obj_new_str(path_out, strlen(path_out));
-    mp_obj_t stat;
-    nlr_buf_t nlr;
-    if (nlr_push(&nlr) == 0) {
-        stat = mp_vfs_proxy_call(vfs, MP_QSTR_stat, 1, &path_o);
-        nlr_pop();
-    } else {
+    mp_obj_t stat = mp_vfs_proxy_call(vfs, MP_QSTR_stat, 1, &path_o);
+    if (stat == MP_OBJ_NULL) {
         // assume an exception means that the path is not found
+        MP_STATE_THREAD(active_exception) = NULL;
         return MP_IMPORT_STAT_NO_EXIST;
     }
     mp_obj_t *items;
@@ -241,7 +238,7 @@
             // if root dir is mounted, still allow to mount something within a subdir of root
         } else {
             // mount point in use
-            mp_raise_OSError(MP_EPERM);
+            return mp_raise_OSError_o(MP_EPERM);
         }
     }
 
@@ -278,7 +275,7 @@
     }
 
     if (vfs == NULL) {
-        mp_raise_OSError(MP_EINVAL);
+        return mp_raise_OSError_o(MP_EINVAL);
     }
 
     // if we unmounted the current device then set current to root
@@ -444,7 +441,7 @@
     mp_obj_t path_out;
     mp_vfs_mount_t *vfs = lookup_path(path_in, &path_out);
     if (vfs == MP_VFS_ROOT || (vfs != MP_VFS_NONE && !strcmp(mp_obj_str_get_str(path_out), "/"))) {
-        mp_raise_OSError(MP_EEXIST);
+        return mp_raise_OSError_o(MP_EEXIST);
     }
     return mp_vfs_proxy_call(vfs, MP_QSTR_mkdir, 1, &path_out);
 }
@@ -463,7 +460,7 @@
     mp_vfs_mount_t *new_vfs = lookup_path(new_path_in, &args[1]);
     if (old_vfs != new_vfs) {
         // can't rename across filesystems
-        mp_raise_OSError(MP_EPERM);
+        return mp_raise_OSError_o(MP_EPERM);
     }
     return mp_vfs_proxy_call(old_vfs, MP_QSTR_rename, 2, args);
 }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/vfs_fat.c	2020-05-01 00:05:34.642251576 +0200
+++ micropython-master-no_nlr/extmod/vfs_fat.c	2020-04-30 23:32:39.446155453 +0200
@@ -81,7 +81,7 @@
         // don't error out if no filesystem, to let mkfs()/mount() create one if wanted
         vfs->blockdev.flags |= MP_BLOCKDEV_FLAG_NO_FILESYSTEM;
     } else if (res != FR_OK) {
-        mp_raise_OSError(fresult_to_errno_table[res]);
+        return mp_raise_OSError_o(fresult_to_errno_table[res]);
     }
 
     return MP_OBJ_FROM_PTR(vfs);
@@ -108,7 +108,7 @@
         res = f_mkfs(&vfs->fatfs, FM_FAT32, 0, working_buf, sizeof(working_buf));
     }
     if (res != FR_OK) {
-        mp_raise_OSError(fresult_to_errno_table[res]);
+        return mp_raise_OSError_o(fresult_to_errno_table[res]);
     }
 
     return mp_const_none;
@@ -183,7 +183,7 @@
     iter->is_str = is_str_type;
     FRESULT res = f_opendir(&self->fatfs, &iter->dir, path);
     if (res != FR_OK) {
-        mp_raise_OSError(fresult_to_errno_table[res]);
+        return mp_raise_OSError_o(fresult_to_errno_table[res]);
     }
 
     return MP_OBJ_FROM_PTR(iter);
@@ -198,7 +198,7 @@
     FRESULT res = f_stat(&self->fatfs, path, &fno);
 
     if (res != FR_OK) {
-        mp_raise_OSError(fresult_to_errno_table[res]);
+        return mp_raise_OSError_o(fresult_to_errno_table[res]);
     }
 
     // check if path is a file or directory
@@ -206,11 +206,11 @@
         res = f_unlink(&self->fatfs, path);
 
         if (res != FR_OK) {
-            mp_raise_OSError(fresult_to_errno_table[res]);
+            return mp_raise_OSError_o(fresult_to_errno_table[res]);
         }
         return mp_const_none;
     } else {
-        mp_raise_OSError(attr ? MP_ENOTDIR : MP_EISDIR);
+        return mp_raise_OSError_o(attr ? MP_ENOTDIR : MP_EISDIR);
     }
 }
 
@@ -238,7 +238,7 @@
     if (res == FR_OK) {
         return mp_const_none;
     } else {
-        mp_raise_OSError(fresult_to_errno_table[res]);
+        return mp_raise_OSError_o(fresult_to_errno_table[res]);
     }
 
 }
@@ -251,7 +251,7 @@
     if (res == FR_OK) {
         return mp_const_none;
     } else {
-        mp_raise_OSError(fresult_to_errno_table[res]);
+        return mp_raise_OSError_o(fresult_to_errno_table[res]);
     }
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_2(fat_vfs_mkdir_obj, fat_vfs_mkdir);
@@ -265,7 +265,7 @@
     FRESULT res = f_chdir(&self->fatfs, path);
 
     if (res != FR_OK) {
-        mp_raise_OSError(fresult_to_errno_table[res]);
+        return mp_raise_OSError_o(fresult_to_errno_table[res]);
     }
 
     return mp_const_none;
@@ -278,7 +278,7 @@
     char buf[MICROPY_ALLOC_PATH_MAX + 1];
     FRESULT res = f_getcwd(&self->fatfs, buf, sizeof(buf));
     if (res != FR_OK) {
-        mp_raise_OSError(fresult_to_errno_table[res]);
+        return mp_raise_OSError_o(fresult_to_errno_table[res]);
     }
     return mp_obj_new_str(buf, strlen(buf));
 }
@@ -300,7 +300,7 @@
     } else {
         FRESULT res = f_stat(&self->fatfs, path, &fno);
         if (res != FR_OK) {
-            mp_raise_OSError(fresult_to_errno_table[res]);
+            return mp_raise_OSError_o(fresult_to_errno_table[res]);
         }
     }
 
@@ -343,7 +343,7 @@
     FATFS *fatfs = &self->fatfs;
     FRESULT res = f_getfree(fatfs, &nclst);
     if (FR_OK != res) {
-        mp_raise_OSError(fresult_to_errno_table[res]);
+        return mp_raise_OSError_o(fresult_to_errno_table[res]);
     }
 
     mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(10, NULL));
@@ -381,7 +381,7 @@
         res = f_mkfs(&self->fatfs, FM_FAT | FM_SFD, 0, working_buf, sizeof(working_buf));
     }
     if (res != FR_OK) {
-        mp_raise_OSError(fresult_to_errno_table[res]);
+        return mp_raise_OSError_o(fresult_to_errno_table[res]);
     }
     self->blockdev.flags &= ~MP_BLOCKDEV_FLAG_NO_FILESYSTEM;
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/vfs_fat_file.c	2020-05-01 00:05:34.642251576 +0200
+++ micropython-master-no_nlr/extmod/vfs_fat_file.c	2020-04-30 23:32:39.446155453 +0200
@@ -193,6 +193,9 @@
     }
 
     pyb_file_obj_t *o = m_new_obj_with_finaliser(pyb_file_obj_t);
+    if (o == NULL) {
+        return MP_OBJ_NULL;
+    }
     o->base.type = type;
 
     const char *fname = mp_obj_str_get_str(args[0].u_obj);
@@ -200,7 +203,7 @@
     FRESULT res = f_open(&vfs->fatfs, &o->fp, fname, mode);
     if (res != FR_OK) {
         m_del_obj(pyb_file_obj_t, o);
-        mp_raise_OSError(fresult_to_errno_table[res]);
+        return mp_raise_OSError_o(fresult_to_errno_table[res]);
     }
 
     // for 'a' mode, we must begin at the end of the file
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/vfs_lfsx.c	2020-05-01 00:05:34.642251576 +0200
+++ micropython-master-no_nlr/extmod/vfs_lfsx.c	2020-04-30 23:32:39.446155453 +0200
@@ -123,7 +123,7 @@
         args[LFS_MAKE_ARG_readsize].u_int, args[LFS_MAKE_ARG_progsize].u_int, args[LFS_MAKE_ARG_lookahead].u_int);
     int ret = LFSx_API(mount)(&self->lfs, &self->config);
     if (ret < 0) {
-        mp_raise_OSError(-ret);
+        return mp_raise_OSError_o(-ret);
     }
     return MP_OBJ_FROM_PTR(self);
 }
@@ -137,7 +137,7 @@
         args[LFS_MAKE_ARG_readsize].u_int, args[LFS_MAKE_ARG_progsize].u_int, args[LFS_MAKE_ARG_lookahead].u_int);
     int ret = LFSx_API(format)(&self.lfs, &self.config);
     if (ret < 0) {
-        mp_raise_OSError(-ret);
+        return mp_raise_OSError_o(-ret);
     }
     return mp_const_none;
 }
@@ -205,7 +205,7 @@
     iter->vfs = self;
     int ret = LFSx_API(dir_open)(&self->lfs, &iter->dir, path);
     if (ret < 0) {
-        mp_raise_OSError(-ret);
+        return mp_raise_OSError_o(-ret);
     }
     return MP_OBJ_FROM_PTR(iter);
 }
@@ -216,7 +216,7 @@
     const char *path = MP_VFS_LFSx(make_path)(self, path_in);
     int ret = LFSx_API(remove)(&self->lfs, path);
     if (ret < 0) {
-        mp_raise_OSError(-ret);
+        return mp_raise_OSError_o(-ret);
     }
     return mp_const_none;
 }
@@ -227,7 +227,7 @@
     const char *path = MP_VFS_LFSx(make_path)(self, path_in);
     int ret = LFSx_API(remove)(&self->lfs, path);
     if (ret < 0) {
-        mp_raise_OSError(-ret);
+        return mp_raise_OSError_o(-ret);
     }
     return mp_const_none;
 }
@@ -243,7 +243,7 @@
     int ret = LFSx_API(rename)(&self->lfs, path_old, vstr_null_terminated_str(&path_new));
     vstr_clear(&path_new);
     if (ret < 0) {
-        mp_raise_OSError(-ret);
+        return mp_raise_OSError_o(-ret);
     }
     return mp_const_none;
 }
@@ -254,7 +254,7 @@
     const char *path = MP_VFS_LFSx(make_path)(self, path_o);
     int ret = LFSx_API(mkdir)(&self->lfs, path);
     if (ret < 0) {
-        mp_raise_OSError(-ret);
+        return mp_raise_OSError_o(-ret);
     }
     return mp_const_none;
 }
@@ -270,7 +270,7 @@
         struct LFSx_API (info) info;
         int ret = LFSx_API(stat)(&self->lfs, path, &info);
         if (ret < 0 || info.type != LFSx_MACRO(_TYPE_DIR)) {
-            mp_raise_OSError(-MP_ENOENT);
+            return mp_raise_OSError_o(-MP_ENOENT);
         }
     }
 
@@ -308,7 +308,7 @@
     struct LFSx_API (info) info;
     int ret = LFSx_API(stat)(&self->lfs, path, &info);
     if (ret < 0) {
-        mp_raise_OSError(-ret);
+        return mp_raise_OSError_o(-ret);
     }
 
     mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(10, NULL));
@@ -344,7 +344,7 @@
     int ret = LFSx_API(fs_traverse)(&self->lfs, LFSx_API(traverse_cb), &n_used_blocks);
     #endif
     if (ret < 0) {
-        mp_raise_OSError(-ret);
+        return mp_raise_OSError_o(-ret);
     }
 
     mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(10, NULL));
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/vfs_lfsx_file.c	2020-05-01 00:05:34.642251576 +0200
+++ micropython-master-no_nlr/extmod/vfs_lfsx_file.c	2020-04-30 23:32:39.446155453 +0200
@@ -105,7 +105,7 @@
     int ret = LFSx_API(file_opencfg)(&self->lfs, &o->file, path, flags, &o->cfg);
     if (ret < 0) {
         o->vfs = NULL;
-        mp_raise_OSError(-ret);
+        return mp_raise_OSError_o(-ret);
     }
 
     return MP_OBJ_FROM_PTR(o);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/vfs_posix.c	2020-05-01 00:05:34.642251576 +0200
+++ micropython-master-no_nlr/extmod/vfs_posix.c	2020-04-30 23:32:39.446155453 +0200
@@ -68,7 +68,7 @@
     mp_obj_vfs_posix_t *self = MP_OBJ_TO_PTR(self_in);
     int ret = f(vfs_posix_get_path_str(self, path_in));
     if (ret != 0) {
-        mp_raise_OSError(errno);
+        return mp_raise_OSError_o(errno);
     }
     return mp_const_none;
 }
@@ -113,7 +113,7 @@
         self->readonly = true;
     }
     if (mp_obj_is_true(mkfs)) {
-        mp_raise_OSError(MP_EPERM);
+        return mp_raise_OSError_o(MP_EPERM);
     }
     return mp_const_none;
 }
@@ -130,7 +130,7 @@
     const char *mode = mp_obj_str_get_str(mode_in);
     if (self->readonly
         && (strchr(mode, 'w') != NULL || strchr(mode, 'a') != NULL || strchr(mode, '+') != NULL)) {
-        mp_raise_OSError(MP_EROFS);
+        return mp_raise_OSError_o(MP_EROFS);
     }
     if (!mp_obj_is_small_int(path_in)) {
         path_in = vfs_posix_get_path_obj(self, path_in);
@@ -149,7 +149,7 @@
     char buf[MICROPY_ALLOC_PATH_MAX + 1];
     const char *ret = getcwd(buf, sizeof(buf));
     if (ret == NULL) {
-        mp_raise_OSError(errno);
+        return mp_raise_OSError_o(errno);
     }
     ret += self->root_len;
     return mp_obj_new_str(ret, strlen(ret));
@@ -237,7 +237,7 @@
     iter->dir = opendir(path);
     MP_THREAD_GIL_ENTER();
     if (iter->dir == NULL) {
-        mp_raise_OSError(errno);
+        return mp_raise_OSError_o(errno);
     }
     return MP_OBJ_FROM_PTR(iter);
 }
@@ -256,7 +256,7 @@
     int ret = mkdir(path, 0777);
     MP_THREAD_GIL_ENTER();
     if (ret != 0) {
-        mp_raise_OSError(errno);
+        return mp_raise_OSError_o(errno);
     }
     return mp_const_none;
 }
@@ -275,7 +275,7 @@
     int ret = rename(old_path, new_path);
     MP_THREAD_GIL_ENTER();
     if (ret != 0) {
-        mp_raise_OSError(errno);
+        return mp_raise_OSError_o(errno);
     }
     return mp_const_none;
 }
@@ -294,7 +294,7 @@
     int ret = stat(path, &sb);
     MP_THREAD_GIL_ENTER();
     if (ret != 0) {
-        mp_raise_OSError(errno);
+        return mp_raise_OSError_o(errno);
     }
     mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(10, NULL));
     t->items[0] = MP_OBJ_NEW_SMALL_INT(sb.st_mode);
@@ -339,7 +339,7 @@
     int ret = STATVFS(path, &sb);
     MP_THREAD_GIL_ENTER();
     if (ret != 0) {
-        mp_raise_OSError(errno);
+        return mp_raise_OSError_o(errno);
     }
     mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(10, NULL));
     t->items[0] = MP_OBJ_NEW_SMALL_INT(sb.f_bsize);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/extmod/vfs_posix_file.c	2020-05-01 01:09:34.237637949 +0200
+++ micropython-master-no_nlr/extmod/vfs_posix_file.c	2020-04-30 23:32:39.446155453 +0200
@@ -45,11 +45,15 @@
 #ifdef MICROPY_CPYTHON_COMPAT
 STATIC void check_fd_is_open(const mp_obj_vfs_posix_file_t *o) {
     if (o->fd < 0) {
-        mp_raise_ValueError("I/O operation on closed file");
+        //mp_raise_msg(&mp_type_ValueError, "I/O operation on closed file");
+#pragma message "PMPP TODO: remove obj creation py/runtime.c:1493"
+        mp_raise_o(mp_obj_new_exception_msg(&mp_type_ValueError, "I/O operation on closed file"));
+        return 1;
     }
+    return 0;
 }
 #else
-#define check_fd_is_open(o)
+#define check_fd_is_open(o) 0
 #endif
 
 STATIC void vfs_posix_file_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
@@ -105,7 +109,7 @@
     int fd = open(fname, mode_x | mode_rw, 0644);
     MP_THREAD_GIL_ENTER();
     if (fd == -1) {
-        mp_raise_OSError(errno);
+        return mp_raise_OSError_o(errno);
     }
     o->fd = fd;
     return MP_OBJ_FROM_PTR(o);
@@ -124,7 +128,9 @@
 
 STATIC mp_obj_t vfs_posix_file_fileno(mp_obj_t self_in) {
     mp_obj_vfs_posix_file_t *self = MP_OBJ_TO_PTR(self_in);
-    check_fd_is_open(self);
+    if (check_fd_is_open(self)) {
+        return MP_OBJ_NULL;
+    }
     return MP_OBJ_NEW_SMALL_INT(self->fd);
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_1(vfs_posix_file_fileno_obj, vfs_posix_file_fileno);
@@ -137,7 +143,9 @@
 
 STATIC mp_uint_t vfs_posix_file_read(mp_obj_t o_in, void *buf, mp_uint_t size, int *errcode) {
     mp_obj_vfs_posix_file_t *o = MP_OBJ_TO_PTR(o_in);
-    check_fd_is_open(o);
+    if (check_fd_is_open(o)) {
+        return MP_STREAM_ERROR;
+    }
     MP_THREAD_GIL_EXIT();
     mp_int_t r = read(o->fd, buf, size);
     MP_THREAD_GIL_ENTER();
@@ -150,7 +158,9 @@
 
 STATIC mp_uint_t vfs_posix_file_write(mp_obj_t o_in, const void *buf, mp_uint_t size, int *errcode) {
     mp_obj_vfs_posix_file_t *o = MP_OBJ_TO_PTR(o_in);
-    check_fd_is_open(o);
+    if (check_fd_is_open(o)) {
+        return MP_STREAM_ERROR;
+    }
     #if MICROPY_PY_OS_DUPTERM
     if (o->fd <= STDERR_FILENO) {
         mp_hal_stdout_tx_strn(buf, size);
@@ -162,7 +172,8 @@
         if (MP_STATE_VM(mp_pending_exception) != MP_OBJ_NULL) {
             mp_obj_t obj = MP_STATE_VM(mp_pending_exception);
             MP_STATE_VM(mp_pending_exception) = MP_OBJ_NULL;
-            nlr_raise(obj);
+            mp_raise_o(obj);
+            return MP_STREAM_ERROR;
         }
         MP_THREAD_GIL_EXIT();
         r = write(o->fd, buf, size);
@@ -177,7 +188,9 @@
 
 STATIC mp_uint_t vfs_posix_file_ioctl(mp_obj_t o_in, mp_uint_t request, uintptr_t arg, int *errcode) {
     mp_obj_vfs_posix_file_t *o = MP_OBJ_TO_PTR(o_in);
-    check_fd_is_open(o);
+    if (check_fd_is_open(o)) {
+        return MP_STREAM_ERROR;
+    }
     switch (request) {
         case MP_STREAM_FLUSH:
             MP_THREAD_GIL_EXIT();
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/lib/upytesthelper/upytesthelper.c	2020-04-17 09:19:09.172300970 +0200
+++ micropython-master-no_nlr/lib/upytesthelper/upytesthelper.c	2020-04-17 12:45:36.365620138 +0200
@@ -96,16 +96,15 @@
     mp_obj_list_init(mp_sys_path, 0);
     mp_obj_list_init(mp_sys_argv, 0);
 
-    nlr_buf_t nlr;
-    if (nlr_push(&nlr) == 0) {
-        mp_lexer_t *lex = mp_lexer_new_from_str_len(MP_QSTR__lt_stdin_gt_, src, strlen(src), 0);
-        qstr source_name = lex->source_name;
-        mp_parse_tree_t parse_tree = mp_parse(lex, MP_PARSE_FILE_INPUT);
-        mp_obj_t module_fun = mp_compile(&parse_tree, source_name, false);
+    mp_lexer_t *lex = mp_lexer_new_from_str_len(MP_QSTR__lt_stdin_gt_, src, strlen(src), 0);
+    qstr source_name = lex->source_name;
+    mp_parse_tree_t parse_tree = mp_parse(lex, MP_PARSE_FILE_INPUT);
+    mp_obj_t module_fun = mp_compile(&parse_tree, source_name, false);
+    if (module_fun != MP_OBJ_NULL) {
         mp_call_function_0(module_fun);
-        nlr_pop();
-    } else {
-        mp_obj_t exc = (mp_obj_t)nlr.ret_val;
+    }
+    if (MP_STATE_THREAD(active_exception) != NULL) {
+        mp_obj_t exc = MP_OBJ_FROM_PTR(MP_STATE_THREAD(active_exception));
         if (mp_obj_is_subclass_fast(mp_obj_get_type(exc), &mp_type_SystemExit)) {
             // Assume that sys.exit() is called to skip the test.
             // TODO: That can be always true, we should set up convention to
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/mpy-cross/main.c	2020-05-01 00:05:34.644251548 +0200
+++ micropython-master-no_nlr/mpy-cross/main.c	2020-04-30 23:32:39.448155425 +0200
@@ -47,11 +47,21 @@
 // Make it larger on a 64 bit machine, because pointers are larger.
 long heap_size = 1024 * 1024 * (sizeof(mp_uint_t) / 4);
 
+#if __EMSCRIPTEN__
+#include "emscripten.h"
+
+STATIC void stderr_print_strn(void *env, const char *str, mp_uint_t len) {
+EM_ASM{
+    console.error("ERROR");
+}
+}
+#else
 STATIC void stderr_print_strn(void *env, const char *str, mp_uint_t len) {
     (void)env;
     ssize_t dummy = write(STDERR_FILENO, str, len);
     (void)dummy;
 }
+#endif
 
 STATIC const mp_print_t mp_stderr_print = {NULL, stderr_print_strn};
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/ports/esp8266/boards/GENERIC_512K/mpconfigboard.mk	2020-04-17 12:44:56.014132049 +0200
+++ micropython-master-no_nlr/ports/esp8266/boards/GENERIC_512K/mpconfigboard.mk	2020-04-17 12:45:36.365620138 +0200
@@ -1,3 +1,4 @@
 MICROPY_PY_BTREE = 0
 MICROPY_VFS_FAT = 0
 LD_FILES = boards/esp8266_512k.ld
+FROZEN_MANIFEST = boards/manifest_minimal.py
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/ports/javascript/Makefile	2020-04-17 09:19:09.210300438 +0200
+++ micropython-master-no_nlr/ports/javascript/Makefile	2020-04-17 12:45:36.365620138 +0200
@@ -16,12 +16,13 @@
 CPP = clang -E
 
 ifdef EMSCRIPTEN
-    CPP += -isystem $(EMSCRIPTEN)/system/include/libc -cxx-isystem $(EMSCRIPTEN)/system/include/libcxx
+    CPP += -isystem $(EMSCRIPTEN)/system/include/libc -isystem $(EMSCRIPTEN)/system/lib/libc/musl/arch/emscripten -cxx-isystem $(EMSCRIPTEN)/system/include/libcxx
 endif
 
-CFLAGS = -m32 -Wall -Werror $(INC) -std=c99 $(COPT)
-LDFLAGS = -m32 -Wl,-Map=$@.map,--cref -Wl,--gc-sections
-
+CFLAGS = -m32 -Wall $(INC) -std=c99 $(COPT)
+LDFLAGS = -m32
+# -Wl,-Map=$@.map,--cref -Wl,--gc-sections
+#-s "BINARYEN_TRAP_MODE='clamp'"
 CFLAGS += -O0 -DNDEBUG
 CFLAGS += -fdata-sections -ffunction-sections
 
@@ -51,7 +52,7 @@
 OBJ += $(addprefix $(BUILD)/, $(SRC_LIB:.c=.o))
 OBJ += $(addprefix $(BUILD)/, $(SRC_C:.c=.o))
 
-JSFLAGS = -O0 -s EXPORTED_FUNCTIONS="['_mp_js_init', '_mp_js_init_repl', '_mp_js_do_str', '_mp_js_process_char', '_mp_hal_get_interrupt_char', '_mp_keyboard_interrupt']" -s EXTRA_EXPORTED_RUNTIME_METHODS="['ccall', 'cwrap']" -s "BINARYEN_TRAP_MODE='clamp'" --memory-init-file 0 --js-library library.js
+JSFLAGS = -O0 -s EXPORTED_FUNCTIONS="['_mp_js_init', '_mp_js_init_repl', '_mp_js_do_str', '_mp_js_process_char', '_mp_hal_get_interrupt_char', '_mp_keyboard_interrupt']" -s EXTRA_EXPORTED_RUNTIME_METHODS="['ccall', 'cwrap']"  --memory-init-file 0 --js-library library.js
 
 all: $(BUILD)/micropython.js
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/ports/qemu-arm/main.c	2020-05-01 00:05:34.662251294 +0200
+++ micropython-master-no_nlr/ports/qemu-arm/main.c	2020-04-30 23:32:39.462155227 +0200
@@ -13,17 +13,16 @@
 #include "py/mperrno.h"
 
 void do_str(const char *src, mp_parse_input_kind_t input_kind) {
-    nlr_buf_t nlr;
-    if (nlr_push(&nlr) == 0) {
-        mp_lexer_t *lex = mp_lexer_new_from_str_len(MP_QSTR__lt_stdin_gt_, src, strlen(src), 0);
-        qstr source_name = lex->source_name;
-        mp_parse_tree_t parse_tree = mp_parse(lex, input_kind);
-        mp_obj_t module_fun = mp_compile(&parse_tree, source_name, true);
+    mp_lexer_t *lex = mp_lexer_new_from_str_len(MP_QSTR__lt_stdin_gt_, src, strlen(src), 0);
+    qstr source_name = lex->source_name;
+    mp_parse_tree_t parse_tree = mp_parse(lex, input_kind);
+    mp_obj_t module_fun = mp_compile(&parse_tree, source_name, true);
+    if (module_fun != MP_OBJ_NULL) {
         mp_call_function_0(module_fun);
-        nlr_pop();
-    } else {
+    }
+    if (MP_STATE_THREAD(active_exception) != NULL) {
         // uncaught exception
-        mp_obj_print_exception(&mp_plat_print, (mp_obj_t)nlr.ret_val);
+        mp_obj_print_exception(&mp_plat_print, MP_OBJ_FROM_PTR(MP_STATE_THREAD(active_exception)));
     }
 }
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/ports/qemu-arm/test_main.c	2020-05-01 00:05:34.662251294 +0200
+++ micropython-master-no_nlr/ports/qemu-arm/test_main.c	2020-04-30 23:32:39.462155227 +0200
@@ -43,7 +43,8 @@
 }
 
 mp_lexer_t *mp_lexer_new_from_file(const char *filename) {
-    mp_raise_OSError(MP_ENOENT);
+    mp_raise_OSError_o(MP_ENOENT);
+    return NULL;
 }
 
 mp_import_stat_t mp_import_stat(const char *path) {
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/ports/unix/coverage.c	2020-05-01 00:05:34.682251012 +0200
+++ micropython-master-no_nlr/ports/unix/coverage.c	2020-04-30 23:32:39.476155029 +0200
@@ -240,20 +240,15 @@
         mp_printf(&mp_plat_print, "%.*s\n", (int)vstr->len, vstr->buf);
 
         VSTR_FIXED(fix, 4);
-        nlr_buf_t nlr;
-        if (nlr_push(&nlr) == 0) {
-            vstr_add_str(&fix, "large");
-            nlr_pop();
-        } else {
-            mp_obj_print_exception(&mp_plat_print, MP_OBJ_FROM_PTR(nlr.ret_val));
+        if (vstr_add_str(&fix, "large")) {
+            mp_obj_print_exception(&mp_plat_print, MP_STATE_THREAD(active_exception));
+            MP_STATE_THREAD(active_exception) = NULL;
         }
 
         fix.len = fix.alloc;
-        if (nlr_push(&nlr) == 0) {
-            vstr_null_terminated_str(&fix);
-            nlr_pop();
-        } else {
-            mp_obj_print_exception(&mp_plat_print, MP_OBJ_FROM_PTR(nlr.ret_val));
+        if (vstr_null_terminated_str(&fix) == NULL) {
+            mp_obj_print_exception(&mp_plat_print, MP_STATE_THREAD(active_exception));
+            MP_STATE_THREAD(active_exception) = NULL;
         }
     }
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/ports/unix/file.c	2020-05-01 00:56:48.646186033 +0200
+++ micropython-master-no_nlr/ports/unix/file.c	2020-05-01 00:53:18.171054265 +0200
@@ -45,10 +45,12 @@
 #endif
 
 #ifdef MICROPY_CPYTHON_COMPAT
-STATIC void check_fd_is_open(const mp_obj_fdfile_t *o) {
+STATIC int check_fd_is_open(const mp_obj_fdfile_t *o) {
     if (o->fd < 0) {
-        mp_raise_ValueError("I/O operation on closed file");
+        mp_raise_ValueError_o("I/O operation on closed file");
+        return 1;
     }
+    return 0;
 }
 #else
 #define check_fd_is_open(o)
@@ -65,7 +67,9 @@
 
 STATIC mp_uint_t fdfile_read(mp_obj_t o_in, void *buf, mp_uint_t size, int *errcode) {
     mp_obj_fdfile_t *o = MP_OBJ_TO_PTR(o_in);
-    check_fd_is_open(o);
+    if (check_fd_is_open(o)) {
+        return MP_STREAM_ERROR;
+    }
     MP_THREAD_GIL_EXIT();
     mp_int_t r = read(o->fd, buf, size);
     MP_THREAD_GIL_ENTER();
@@ -78,7 +82,9 @@
 
 STATIC mp_uint_t fdfile_write(mp_obj_t o_in, const void *buf, mp_uint_t size, int *errcode) {
     mp_obj_fdfile_t *o = MP_OBJ_TO_PTR(o_in);
-    check_fd_is_open(o);
+    if (check_fd_is_open(o)) {
+        return MP_STREAM_ERROR;
+    }
     #if MICROPY_PY_OS_DUPTERM
     if (o->fd <= STDERR_FILENO) {
         mp_hal_stdout_tx_strn(buf, size);
@@ -92,7 +98,8 @@
         if (MP_STATE_VM(mp_pending_exception) != MP_OBJ_NULL) {
             mp_obj_t obj = MP_STATE_VM(mp_pending_exception);
             MP_STATE_VM(mp_pending_exception) = MP_OBJ_NULL;
-            nlr_raise(obj);
+            mp_raise_o(obj);
+            return MP_STREAM_ERROR;
         }
         MP_THREAD_GIL_EXIT();
         r = write(o->fd, buf, size);
@@ -107,7 +114,9 @@
 
 STATIC mp_uint_t fdfile_ioctl(mp_obj_t o_in, mp_uint_t request, uintptr_t arg, int *errcode) {
     mp_obj_fdfile_t *o = MP_OBJ_TO_PTR(o_in);
-    check_fd_is_open(o);
+    if (check_fd_is_open(o)) {
+        return MP_STREAM_ERROR;
+    }
     switch (request) {
         case MP_STREAM_SEEK: {
             struct mp_stream_seek_t *s = (struct mp_stream_seek_t *)arg;
@@ -161,7 +170,9 @@
 
 STATIC mp_obj_t fdfile_fileno(mp_obj_t self_in) {
     mp_obj_fdfile_t *self = MP_OBJ_TO_PTR(self_in);
-    check_fd_is_open(self);
+    if (check_fd_is_open(self)) {
+        return MP_OBJ_NULL;
+    }
     return MP_OBJ_NEW_SMALL_INT(self->fd);
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_1(fdfile_fileno_obj, fdfile_fileno);
@@ -223,7 +234,7 @@
     int fd = open(fname, mode_x | mode_rw, 0644);
     MP_THREAD_GIL_ENTER();
     if (fd == -1) {
-        mp_raise_OSError(errno);
+        return mp_raise_OSError_o(errno);
     }
     o->fd = fd;
     return MP_OBJ_FROM_PTR(o);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/ports/unix/main.c	2020-05-01 00:05:34.682251012 +0200
+++ micropython-master-no_nlr/ports/unix/main.c	2020-05-01 00:03:29.348020201 +0200
@@ -77,7 +77,9 @@
 // If exc is SystemExit, return value where FORCED_EXIT bit set,
 // and lower 8 bits are SystemExit value. For all other exceptions,
 // return 1.
-STATIC int handle_uncaught_exception(mp_obj_base_t *exc) {
+STATIC int handle_uncaught_exception(void) {
+    mp_obj_base_t *exc = MP_STATE_THREAD(active_exception);
+    MP_STATE_THREAD(active_exception) = NULL;
     // check for SystemExit
     if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(exc->type), MP_OBJ_FROM_PTR(&mp_type_SystemExit))) {
         // None is an exit value of 0; an int is its value; anything else is 1
@@ -105,8 +107,7 @@
 STATIC int execute_from_lexer(int source_kind, const void *source, mp_parse_input_kind_t input_kind, bool is_repl) {
     mp_hal_set_interrupt_char(CHAR_CTRL_C);
 
-    nlr_buf_t nlr;
-    if (nlr_push(&nlr) == 0) {
+    {
         // create lexer based on source kind
         mp_lexer_t *lex;
         if (source_kind == LEX_SRC_STR) {
@@ -121,6 +122,10 @@
             lex = mp_lexer_new_from_fd(MP_QSTR__lt_stdin_gt_, 0, false);
         }
 
+        if (lex == NULL) {
+            return handle_uncaught_exception();
+        }
+
         qstr source_name = lex->source_name;
 
         #if MICROPY_PY___FILE__
@@ -142,21 +147,27 @@
 
         mp_obj_t module_fun = mp_compile(&parse_tree, source_name, is_repl);
 
-        if (!compile_only) {
+        if (!compile_only && module_fun != MP_OBJ_NULL) {
             // execute it
-            mp_call_function_0(module_fun);
+            mp_obj_t ret = mp_call_function_0(module_fun);
+            // check for pending exception
+            if (ret != MP_OBJ_NULL && MP_STATE_VM(mp_pending_exception) != MP_OBJ_NULL) {
+                mp_obj_t obj = MP_STATE_VM(mp_pending_exception);
+                MP_STATE_VM(mp_pending_exception) = MP_OBJ_NULL;
+                mp_raise_o(obj);
+            }
+        }
+
+        if (MP_STATE_THREAD(active_exception) != NULL) {
+            // uncaught exception
+            mp_hal_set_interrupt_char(-1);
+            mp_handle_pending(false);
+            return handle_uncaught_exception();
         }
 
         mp_hal_set_interrupt_char(-1);
         mp_handle_pending(true);
-        nlr_pop();
         return 0;
-
-    } else {
-        // uncaught exception
-        mp_hal_set_interrupt_char(-1);
-        mp_handle_pending(false);
-        return handle_uncaught_exception(nlr.ret_val);
     }
 }
 
@@ -395,6 +406,13 @@
                     if (heap_size < 700) {
                         goto invalid_arg;
                     }
+                } else if (strncmp(argv[a + 1], "alloc-max=", sizeof("alloc-max=") - 1) == 0) {
+                    char *end;
+                    extern unsigned gc_alloc_count_max;
+                    gc_alloc_count_max = strtol(argv[a + 1] + sizeof("alloc-max=") - 1, &end, 0);
+                    if (*end != 0) {
+                        goto invalid_arg;
+                    }
                 #endif
                 } else {
                 invalid_arg:
@@ -463,6 +481,9 @@
     #endif
 
     mp_init();
+    if (MP_STATE_THREAD(active_exception) != NULL) {
+        return handle_uncaught_exception();
+    }
 
     #if MICROPY_EMIT_NATIVE
     // Set default emitter options
@@ -503,6 +524,9 @@
         }
     }
     mp_obj_list_init(MP_OBJ_TO_PTR(mp_sys_path), path_num);
+    if (MP_STATE_THREAD(active_exception) != NULL) {
+        return handle_uncaught_exception();
+    }
     mp_obj_t *path_items;
     mp_obj_list_get(mp_sys_path, &path_num, &path_items);
     path_items[0] = MP_OBJ_NEW_QSTR(MP_QSTR_);
@@ -520,6 +544,9 @@
                 vstr_init(&vstr, home_l + (p1 - p - 1) + 1);
                 vstr_add_strn(&vstr, home, home_l);
                 vstr_add_strn(&vstr, p + 1, p1 - p - 1);
+                if (MP_STATE_THREAD(active_exception) != NULL) {
+                    return handle_uncaught_exception();
+                }
                 path_items[i] = mp_obj_new_str_from_vstr(&mp_type_str, &vstr);
             } else {
                 path_items[i] = mp_obj_new_str_via_qstr(p, p1 - p);
@@ -529,6 +556,9 @@
     }
 
     mp_obj_list_init(MP_OBJ_TO_PTR(mp_sys_argv), 0);
+    if (MP_STATE_THREAD(active_exception) != NULL) {
+        return handle_uncaught_exception();
+    }
 
     #if defined(MICROPY_UNIX_COVERAGE)
     {
@@ -591,16 +621,13 @@
                 set_sys_argv(argv, argc, a + 1);
 
                 mp_obj_t mod;
-                nlr_buf_t nlr;
                 bool subpkg_tried = false;
 
             reimport:
-                if (nlr_push(&nlr) == 0) {
-                    mod = mp_builtin___import__(MP_ARRAY_SIZE(import_args), import_args);
-                    nlr_pop();
-                } else {
+                mod = mp_builtin___import__(MP_ARRAY_SIZE(import_args), import_args);
+                if (mod == MP_OBJ_NULL) {
                     // uncaught exception
-                    return handle_uncaught_exception(nlr.ret_val) & 0xff;
+                    return handle_uncaught_exception() & 0xff;
                 }
 
                 if (mp_obj_is_package(mod) && !subpkg_tried) {
@@ -721,5 +748,5 @@
 
 void nlr_jump_fail(void *val) {
     fprintf(stderr, "FATAL: uncaught NLR %p\n", val);
-    exit(1);
+    exit(2);
 }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/ports/unix/modffi.c	2020-05-01 00:05:34.682251012 +0200
+++ micropython-master-no_nlr/ports/unix/modffi.c	2020-04-30 23:32:39.476155029 +0200
@@ -148,7 +148,8 @@
     }
     // TODO: Support actual libffi type objects
 
-    mp_raise_TypeError("Unknown type");
+    mp_raise_TypeError_o("Unknown type");
+    return NULL;
 }
 
 STATIC mp_obj_t return_ffi_value(ffi_arg val, char type) {
@@ -214,11 +215,14 @@
     int i = 0;
     while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {
         o->params[i++] = get_ffi_type(item);
+        if (o->params[i - 1] == NULL) {
+            return MP_OBJ_NULL;
+        }
     }
 
     int res = ffi_prep_cif(&o->cif, FFI_DEFAULT_ABI, nparams, char2ffi_type(*rettype), o->params);
     if (res != FFI_OK) {
-        mp_raise_ValueError("Error in ffi_prep_cif");
+        return mp_raise_ValueError_o("Error in ffi_prep_cif");
     }
 
     return MP_OBJ_FROM_PTR(o);
@@ -231,7 +235,7 @@
 
     void *sym = dlsym(self->handle, symname);
     if (sym == NULL) {
-        mp_raise_OSError(MP_ENOENT);
+        return mp_raise_OSError_o(MP_ENOENT);
     }
     return make_func(args[1], sym, args[3]);
 }
@@ -272,16 +276,19 @@
     int i = 0;
     while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {
         o->params[i++] = get_ffi_type(item);
+        if (o->params[i - 1] == NULL) {
+            return MP_OBJ_NULL;
+        }
     }
 
     int res = ffi_prep_cif(&o->cif, FFI_DEFAULT_ABI, nparams, char2ffi_type(*rettype), o->params);
     if (res != FFI_OK) {
-        mp_raise_ValueError("Error in ffi_prep_cif");
+        return mp_raise_ValueError_o("Error in ffi_prep_cif");
     }
 
     res = ffi_prep_closure_loc(o->clo, &o->cif, call_py_func, MP_OBJ_TO_PTR(func_in), o->func);
     if (res != FFI_OK) {
-        mp_raise_ValueError("ffi_prep_closure_loc");
+        return mp_raise_ValueError_o("ffi_prep_closure_loc");
     }
 
     return MP_OBJ_FROM_PTR(o);
@@ -295,7 +302,7 @@
 
     void *sym = dlsym(self->handle, symname);
     if (sym == NULL) {
-        mp_raise_OSError(MP_ENOENT);
+        return mp_raise_OSError_o(MP_ENOENT);
     }
     mp_obj_ffivar_t *o = m_new_obj(mp_obj_ffivar_t);
     o->base.type = &ffivar_type;
@@ -312,7 +319,7 @@
 
     void *sym = dlsym(self->handle, symname);
     if (sym == NULL) {
-        mp_raise_OSError(MP_ENOENT);
+        return mp_raise_OSError_o(MP_ENOENT);
     }
     return mp_obj_new_int((uintptr_t)sym);
 }
@@ -329,7 +336,7 @@
     void *mod = dlopen(fname, RTLD_NOW | RTLD_LOCAL);
 
     if (mod == NULL) {
-        mp_raise_OSError(errno);
+        return mp_raise_OSError_o(errno);
     }
     mp_obj_ffimod_t *o = m_new_obj(mp_obj_ffimod_t);
     o->base.type = type;
@@ -425,7 +432,7 @@
     }
 
 error:
-    mp_raise_TypeError("Don't know how to pass object to native function");
+    return mp_raise_TypeError_o("Don't know how to pass object to native function");
 }
 
 STATIC const mp_obj_type_t ffifunc_type = {
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/ports/unix/modmachine.c	2020-05-01 00:05:34.682251012 +0200
+++ micropython-master-no_nlr/ports/unix/modmachine.c	2020-04-30 23:32:39.478155001 +0200
@@ -49,7 +49,9 @@
 uintptr_t mod_machine_mem_get_addr(mp_obj_t addr_o, uint align) {
     uintptr_t addr = mp_obj_int_get_truncated(addr_o);
     if ((addr & (align - 1)) != 0) {
-        mp_raise_msg_varg(&mp_type_ValueError, "address %08x is not aligned to %d bytes", addr, align);
+        //mp_raise_msg_varg(&mp_type_ValueError, "address %08x is not aligned to %d bytes", addr, align);
+        mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "address %08x is not aligned to %d bytes", addr, align));
+        return 0;
     }
     #if MICROPY_PLAT_DEV_MEM
     {
@@ -60,7 +62,8 @@
         if (!fd) {
             int _fd = open("/dev/mem", O_RDWR | O_SYNC);
             if (_fd == -1) {
-                mp_raise_OSError(errno);
+                mp_raise_OSError_o(errno);
+                return 0;
             }
             fd = _fd;
         }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/ports/unix/modos.c	2020-05-01 00:05:34.682251012 +0200
+++ micropython-master-no_nlr/ports/unix/modos.c	2020-04-30 23:32:39.478155001 +0200
@@ -53,7 +53,7 @@
     MP_THREAD_GIL_EXIT();
     int res = stat(path, &sb);
     MP_THREAD_GIL_ENTER();
-    RAISE_ERRNO(res, errno);
+    RAISE_ERRNO_O(res, errno);
 
     mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(10, NULL));
     t->items[0] = MP_OBJ_NEW_SMALL_INT(sb.st_mode);
@@ -95,7 +95,7 @@
     MP_THREAD_GIL_EXIT();
     int res = STATVFS(path, &sb);
     MP_THREAD_GIL_ENTER();
-    RAISE_ERRNO(res, errno);
+    RAISE_ERRNO_O(res, errno);
 
     mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(10, NULL));
     t->items[0] = MP_OBJ_NEW_SMALL_INT(sb.f_bsize);
@@ -125,7 +125,7 @@
     int r = unlink(path);
     MP_THREAD_GIL_ENTER();
 
-    RAISE_ERRNO(r, errno);
+    RAISE_ERRNO_O(r, errno);
 
     return mp_const_none;
 }
@@ -139,7 +139,7 @@
     int r = rename(old_path, new_path);
     MP_THREAD_GIL_ENTER();
 
-    RAISE_ERRNO(r, errno);
+    RAISE_ERRNO_O(r, errno);
 
     return mp_const_none;
 }
@@ -152,7 +152,7 @@
     int r = rmdir(path);
     MP_THREAD_GIL_ENTER();
 
-    RAISE_ERRNO(r, errno);
+    RAISE_ERRNO_O(r, errno);
 
     return mp_const_none;
 }
@@ -165,7 +165,7 @@
     int r = system(cmd);
     MP_THREAD_GIL_ENTER();
 
-    RAISE_ERRNO(r, errno);
+    RAISE_ERRNO_O(r, errno);
 
     return MP_OBJ_NEW_SMALL_INT(r);
 }
@@ -225,7 +225,7 @@
     int r = mkdir(path, 0777);
     #endif
     MP_THREAD_GIL_ENTER();
-    RAISE_ERRNO(r, errno);
+    RAISE_ERRNO_O(r, errno);
     return mp_const_none;
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_1(mod_os_mkdir_obj, mod_os_mkdir);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/ports/unix/modtermios.c	2020-05-01 00:05:34.682251012 +0200
+++ micropython-master-no_nlr/ports/unix/modtermios.c	2020-04-30 23:32:39.478155001 +0200
@@ -38,7 +38,7 @@
     int fd = mp_obj_get_int(fd_in);
 
     int res = tcgetattr(fd, &term);
-    RAISE_ERRNO(res, errno);
+    RAISE_ERRNO_O(res, errno);
 
     mp_obj_list_t *r = MP_OBJ_TO_PTR(mp_obj_new_list(7, NULL));
     r->items[0] = MP_OBJ_NEW_SMALL_INT(term.c_iflag);
@@ -109,7 +109,7 @@
     struct termios term;
     int fd = mp_obj_get_int(fd_in);
     int res = tcgetattr(fd, &term);
-    RAISE_ERRNO(res, errno);
+    RAISE_ERRNO_O(res, errno);
 
     term.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
     term.c_oflag = 0;
@@ -118,7 +118,7 @@
     term.c_cc[VMIN] = 1;
     term.c_cc[VTIME] = 0;
     res = tcsetattr(fd, TCSAFLUSH, &term);
-    RAISE_ERRNO(res, errno);
+    RAISE_ERRNO_O(res, errno);
     return mp_const_none;
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_1(mod_termios_setraw_obj, mod_termios_setraw);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/ports/unix/modtime.c	2020-05-01 00:05:34.682251012 +0200
+++ micropython-master-no_nlr/ports/unix/modtime.c	2020-05-01 00:08:05.628120076 +0200
@@ -115,7 +115,7 @@
         break;
         #endif
     }
-    RAISE_ERRNO(res, errno);
+    RAISE_ERRNO_O(res, errno);
     #else
     // TODO: Handle EINTR
     MP_THREAD_GIL_EXIT();
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/ports/unix/moduselect.c	2020-05-01 00:05:34.684250983 +0200
+++ micropython-master-no_nlr/ports/unix/moduselect.c	2020-04-30 23:32:39.478155001 +0200
@@ -165,7 +165,7 @@
     }
 
     // obj doesn't exist in poller
-    mp_raise_OSError(MP_ENOENT);
+    return mp_raise_OSError_o(MP_ENOENT);
 }
 MP_DEFINE_CONST_FUN_OBJ_3(poll_modify_obj, poll_modify);
 
@@ -192,7 +192,7 @@
     MP_THREAD_GIL_EXIT();
     int n_ready = poll(self->entries, self->len, timeout);
     MP_THREAD_GIL_ENTER();
-    RAISE_ERRNO(n_ready, errno);
+    RAISE_ERRNO_R(n_ready, errno, -1);
     return n_ready;
 }
 
@@ -201,6 +201,10 @@
 STATIC mp_obj_t poll_poll(size_t n_args, const mp_obj_t *args) {
     int n_ready = poll_poll_internal(n_args, args);
 
+    if (n_ready < 0) {
+        return MP_OBJ_NULL;
+    }
+
     if (n_ready == 0) {
         return mp_const_empty_tuple;
     }
@@ -239,6 +243,10 @@
     }
 
     int n_ready = poll_poll_internal(n_args, args);
+    if (n_ready < 0) {
+        return MP_OBJ_NULL;
+    }
+
     self->iter_cnt = n_ready;
     self->iter_idx = 0;
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/ports/unix/modusocket.c	2020-05-01 00:05:34.684250983 +0200
+++ micropython-master-no_nlr/ports/unix/modusocket.c	2020-04-30 23:32:39.478155001 +0200
@@ -174,7 +174,7 @@
         // EINPROGRESS on a blocking socket means the operation timed out
         err = MP_ETIMEDOUT;
     }
-    RAISE_ERRNO(r, err);
+    RAISE_ERRNO_O(r, err);
     return mp_const_none;
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_2(socket_connect_obj, socket_connect);
@@ -186,7 +186,7 @@
     MP_THREAD_GIL_EXIT();
     int r = bind(self->fd, (const struct sockaddr *)bufinfo.buf, bufinfo.len);
     MP_THREAD_GIL_ENTER();
-    RAISE_ERRNO(r, errno);
+    RAISE_ERRNO_O(r, errno);
     return mp_const_none;
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_2(socket_bind_obj, socket_bind);
@@ -196,7 +196,7 @@
     MP_THREAD_GIL_EXIT();
     int r = listen(self->fd, MP_OBJ_SMALL_INT_VALUE(backlog_in));
     MP_THREAD_GIL_ENTER();
-    RAISE_ERRNO(r, errno);
+    RAISE_ERRNO_O(r, errno);
     return mp_const_none;
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_2(socket_listen_obj, socket_listen);
@@ -215,7 +215,7 @@
         // EAGAIN on a blocking socket means the operation timed out
         err = MP_ETIMEDOUT;
     }
-    RAISE_ERRNO(fd, err);
+    RAISE_ERRNO_O(fd, err);
 
     mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(2, NULL));
     t->items[0] = MP_OBJ_FROM_PTR(socket_new(fd));
@@ -241,7 +241,7 @@
     MP_THREAD_GIL_EXIT();
     int out_sz = recv(self->fd, buf, sz, flags);
     MP_THREAD_GIL_ENTER();
-    RAISE_ERRNO(out_sz, errno);
+    RAISE_ERRNO_O(out_sz, errno);
 
     mp_obj_t ret = mp_obj_new_str_of_type(&mp_type_bytes, buf, out_sz);
     m_del(char, buf, sz);
@@ -265,7 +265,7 @@
     MP_THREAD_GIL_EXIT();
     int out_sz = recvfrom(self->fd, buf, sz, flags, (struct sockaddr *)&addr, &addr_len);
     MP_THREAD_GIL_ENTER();
-    RAISE_ERRNO(out_sz, errno);
+    RAISE_ERRNO_O(out_sz, errno);
 
     mp_obj_t buf_o = mp_obj_new_str_of_type(&mp_type_bytes, buf, out_sz);
     m_del(char, buf, sz);
@@ -294,7 +294,7 @@
     MP_THREAD_GIL_EXIT();
     int out_sz = send(self->fd, bufinfo.buf, bufinfo.len, flags);
     MP_THREAD_GIL_ENTER();
-    RAISE_ERRNO(out_sz, errno);
+    RAISE_ERRNO_O(out_sz, errno);
 
     return MP_OBJ_NEW_SMALL_INT(out_sz);
 }
@@ -317,7 +317,7 @@
     int out_sz = sendto(self->fd, bufinfo.buf, bufinfo.len, flags,
         (struct sockaddr *)addr_bi.buf, addr_bi.len);
     MP_THREAD_GIL_ENTER();
-    RAISE_ERRNO(out_sz, errno);
+    RAISE_ERRNO_O(out_sz, errno);
 
     return MP_OBJ_NEW_SMALL_INT(out_sz);
 }
@@ -345,7 +345,7 @@
     MP_THREAD_GIL_EXIT();
     int r = setsockopt(self->fd, level, option, optval, optlen);
     MP_THREAD_GIL_ENTER();
-    RAISE_ERRNO(r, errno);
+    RAISE_ERRNO_O(r, errno);
     return mp_const_none;
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(socket_setsockopt_obj, 4, 4, socket_setsockopt);
@@ -353,20 +353,15 @@
 STATIC mp_obj_t socket_setblocking(mp_obj_t self_in, mp_obj_t flag_in) {
     mp_obj_socket_t *self = MP_OBJ_TO_PTR(self_in);
     int val = mp_obj_is_true(flag_in);
-    MP_THREAD_GIL_EXIT();
     int flags = fcntl(self->fd, F_GETFL, 0);
-    if (flags == -1) {
-        MP_THREAD_GIL_ENTER();
-        RAISE_ERRNO(flags, errno);
-    }
+    RAISE_ERRNO_O(flags, errno);
     if (val) {
         flags &= ~O_NONBLOCK;
     } else {
         flags |= O_NONBLOCK;
     }
     flags = fcntl(self->fd, F_SETFL, flags);
-    MP_THREAD_GIL_ENTER();
-    RAISE_ERRNO(flags, errno);
+    RAISE_ERRNO_O(flags, errno);
     self->blocking = val;
     return mp_const_none;
 }
@@ -402,11 +397,11 @@
         r = setsockopt(self->fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(struct timeval));
         if (r == -1) {
             MP_THREAD_GIL_ENTER();
-            RAISE_ERRNO(r, errno);
+            RAISE_ERRNO_O(r, errno);
         }
         r = setsockopt(self->fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(struct timeval));
         MP_THREAD_GIL_ENTER();
-        RAISE_ERRNO(r, errno);
+        RAISE_ERRNO_O(r, errno);
     }
 
     if (self->blocking != new_blocking) {
@@ -449,11 +444,10 @@
             }
         }
     }
-
     MP_THREAD_GIL_EXIT();
     int fd = socket(family, type, proto);
     MP_THREAD_GIL_ENTER();
-    RAISE_ERRNO(fd, errno);
+    RAISE_ERRNO_O(fd, errno);
     return MP_OBJ_FROM_PTR(socket_new(fd));
 }
 
@@ -502,9 +496,9 @@
     int family = mp_obj_get_int(family_in);
     byte binaddr[BINADDR_MAX_LEN];
     int r = inet_pton(family, mp_obj_str_get_str(addr_in), binaddr);
-    RAISE_ERRNO(r, errno);
+    RAISE_ERRNO_O(r, errno);
     if (r == 0) {
-        mp_raise_OSError(MP_EINVAL);
+        return mp_raise_OSError_o(MP_EINVAL);
     }
     int binaddr_len = 0;
     switch (family) {
@@ -526,7 +520,7 @@
     vstr_t vstr;
     vstr_init_len(&vstr, family == AF_INET ? INET_ADDRSTRLEN : INET6_ADDRSTRLEN);
     if (inet_ntop(family, bufinfo.buf, vstr.buf, vstr.len) == NULL) {
-        mp_raise_OSError(errno);
+        return mp_raise_OSError_o(errno);
     }
     vstr.len = strlen(vstr.buf);
     return mp_obj_new_str_from_vstr(&mp_type_str, &vstr);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/ports/unix/mphalport.h	2020-05-01 00:05:34.684250983 +0200
+++ micropython-master-no_nlr/ports/unix/mphalport.h	2020-05-01 00:09:40.214784622 +0200
@@ -73,6 +73,9 @@
 }
 #define mp_hal_ticks_cpu() 0
 
-#define RAISE_ERRNO(err_flag, error_val) \
+#define RAISE_ERRNO_O(err_flag, error_val) \
     { if (err_flag == -1) \
-      { mp_raise_OSError(error_val); } }
+        { return mp_raise_OSError_o(error_val); } }
+#define RAISE_ERRNO_R(err_flag, error_val, ret_on_err) \
+    { if (err_flag == -1) \
+        { mp_raise_OSError_o(error_val); return ret_on_err; } }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/ports/unix/mpthreadport.c	2020-05-01 00:05:34.684250983 +0200
+++ micropython-master-no_nlr/ports/unix/mpthreadport.c	2020-04-30 23:32:39.478155001 +0200
@@ -236,7 +236,8 @@
     return;
 
 er:
-    mp_raise_OSError(ret);
+    mp_raise_OSError_o(ret);
+    // TODO how to indicate error to caller?
 }
 
 void mp_thread_finish(void) {
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/argcheck.c	2020-05-01 00:05:34.686250955 +0200
+++ micropython-master-no_nlr/py/argcheck.c	2020-04-30 23:32:39.480154972 +0200
@@ -29,7 +29,7 @@
 
 #include "py/runtime.h"
 
-void mp_arg_check_num_sig(size_t n_args, size_t n_kw, uint32_t sig) {
+int mp_arg_check_num_sig(size_t n_args, size_t n_kw, uint32_t sig) {
     // TODO maybe take the function name as an argument so we can print nicer error messages
 
     // The reverse of MP_OBJ_FUN_MAKE_SIG
@@ -41,8 +41,9 @@
         if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
             mp_arg_error_terse_mismatch();
         } else {
-            mp_raise_TypeError("function doesn't take keyword arguments");
+            mp_raise_TypeError_o("function doesn't take keyword arguments");
         }
+        return 1;
     }
 
     if (n_args_min == n_args_max) {
@@ -50,33 +51,38 @@
             if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                 mp_arg_error_terse_mismatch();
             } else {
-                mp_raise_msg_varg(&mp_type_TypeError,
+                mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
                     "function takes %d positional arguments but %d were given",
-                    n_args_min, n_args);
+                    n_args_min, n_args));
             }
+            return 1;
         }
     } else {
         if (n_args < n_args_min) {
             if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                 mp_arg_error_terse_mismatch();
             } else {
-                mp_raise_msg_varg(&mp_type_TypeError,
+                mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
                     "function missing %d required positional arguments",
-                    n_args_min - n_args);
+                    n_args_min - n_args));
             }
+            return 1;
         } else if (n_args > n_args_max) {
             if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                 mp_arg_error_terse_mismatch();
             } else {
-                mp_raise_msg_varg(&mp_type_TypeError,
+                mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
                     "function expected at most %d arguments, got %d",
-                    n_args_max, n_args);
+                    n_args_max, n_args));
             }
+            return 1;
         }
     }
+
+    return 0;
 }
 
-void mp_arg_parse_all(size_t n_pos, const mp_obj_t *pos, mp_map_t *kws, size_t n_allowed, const mp_arg_t *allowed, mp_arg_val_t *out_vals) {
+int mp_arg_parse_all(size_t n_pos, const mp_obj_t *pos, mp_map_t *kws, size_t n_allowed, const mp_arg_t *allowed, mp_arg_val_t *out_vals) {
     size_t pos_found = 0, kws_found = 0;
     for (size_t i = 0; i < n_allowed; i++) {
         mp_obj_t given_arg;
@@ -93,8 +99,10 @@
                     if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                         mp_arg_error_terse_mismatch();
                     } else {
-                        mp_raise_msg_varg(&mp_type_TypeError, "'%q' argument required", allowed[i].qst);
+                        mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                            "'%q' argument required", allowed[i].qst));
                     }
+                    return 1;
                 }
                 out_vals[i] = allowed[i].defval;
                 continue;
@@ -118,7 +126,8 @@
             mp_arg_error_terse_mismatch();
         } else {
             // TODO better error message
-            mp_raise_TypeError("extra positional arguments given");
+            mp_raise_TypeError_o("extra positional arguments given");
+            return 1;
         }
     }
     if (kws_found < kws->used) {
@@ -126,23 +135,25 @@
             mp_arg_error_terse_mismatch();
         } else {
             // TODO better error message
-            mp_raise_TypeError("extra keyword arguments given");
+            mp_raise_TypeError_o("extra keyword arguments given");
+            return 1;
         }
     }
+    return 0;
 }
 
-void mp_arg_parse_all_kw_array(size_t n_pos, size_t n_kw, const mp_obj_t *args, size_t n_allowed, const mp_arg_t *allowed, mp_arg_val_t *out_vals) {
+int mp_arg_parse_all_kw_array(size_t n_pos, size_t n_kw, const mp_obj_t *args, size_t n_allowed, const mp_arg_t *allowed, mp_arg_val_t *out_vals) {
     mp_map_t kw_args;
     mp_map_init_fixed_table(&kw_args, n_kw, args + n_pos);
-    mp_arg_parse_all(n_pos, args, &kw_args, n_allowed, allowed, out_vals);
+    return mp_arg_parse_all(n_pos, args, &kw_args, n_allowed, allowed, out_vals);
 }
 
-NORETURN void mp_arg_error_terse_mismatch(void) {
-    mp_raise_TypeError("argument num/types mismatch");
+void mp_arg_error_terse_mismatch(void) {
+    mp_raise_TypeError_o("argument num/types mismatch");
 }
 
 #if MICROPY_CPYTHON_COMPAT
-NORETURN void mp_arg_error_unimpl_kw(void) {
-    mp_raise_NotImplementedError("keyword argument(s) not yet implemented - use normal args instead");
+void mp_arg_error_unimpl_kw(void) {
+    mp_raise_NotImplementedError_o("keyword argument(s) not yet implemented - use normal args instead");
 }
 #endif
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/bc.c	2020-05-01 00:05:34.686250955 +0200
+++ micropython-master-no_nlr/py/bc.c	2020-05-01 00:17:44.598061449 +0200
@@ -40,7 +40,8 @@
 #define DEBUG_printf(...) (void)0
 #endif
 
-#if !MICROPY_PERSISTENT_CODE
+#pragma message "? !MICROPY_PERSISTENT_CODE ?"
+#if 1 //!MICROPY_PERSISTENT_CODE
 
 mp_uint_t mp_decode_uint(const byte **ptr) {
     mp_uint_t unum = 0;
@@ -74,21 +75,22 @@
 
 #endif
 
-STATIC NORETURN void fun_pos_args_mismatch(mp_obj_fun_bc_t *f, size_t expected, size_t given) {
+STATIC mp_obj_t fun_pos_args_mismatch(mp_obj_fun_bc_t *f, size_t expected, size_t given) {
     #if MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE
     // generic message, used also for other argument issues
     (void)f;
     (void)expected;
     (void)given;
     mp_arg_error_terse_mismatch();
+    return MP_OBJ_NULL;
     #elif MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_NORMAL
     (void)f;
-    mp_raise_msg_varg(&mp_type_TypeError,
-        "function takes %d positional arguments but %d were given", expected, given);
+    return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+        "function takes %d positional arguments but %d were given", expected, given));
     #elif MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_DETAILED
-    mp_raise_msg_varg(&mp_type_TypeError,
+    return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
         "%q() takes %d positional arguments but %d were given",
-        mp_obj_fun_get_name(MP_OBJ_FROM_PTR(f)), expected, given);
+        mp_obj_fun_get_name(MP_OBJ_FROM_PTR(f)), expected, given));
     #endif
 }
 
@@ -109,7 +111,7 @@
 //    - code_state->fun_bc should contain a pointer to the function object
 //    - code_state->ip should contain the offset in bytes from the pointer
 //      code_state->fun_bc->bytecode to the entry n_state (0 for bytecode, non-zero for native)
-void mp_setup_code_state(mp_code_state_t *code_state, size_t n_args, size_t n_kw, const mp_obj_t *args) {
+mp_obj_t mp_setup_code_state(mp_code_state_t *code_state, size_t n_args, size_t n_kw, const mp_obj_t *args) {
     // This function is pretty complicated.  It's main aim is to be efficient in speed and RAM
     // usage for the common case of positional only args.
 
@@ -153,7 +155,7 @@
     if (n_args > n_pos_args) {
         // given more than enough arguments
         if ((scope_flags & MP_SCOPE_FLAG_VARARGS) == 0) {
-            fun_pos_args_mismatch(self, n_pos_args, n_args);
+            return fun_pos_args_mismatch(self, n_pos_args, n_args);
         }
         // put extra arguments in varargs tuple
         *var_pos_kw_args-- = mp_obj_new_tuple(n_args - n_pos_args, args + n_pos_args);
@@ -172,7 +174,7 @@
                     code_state->state[n_state - 1 - i] = self->extra_args[i - (n_pos_args - n_def_pos_args)];
                 }
             } else {
-                fun_pos_args_mismatch(self, n_pos_args - n_def_pos_args, n_args);
+                return fun_pos_args_mismatch(self, n_pos_args - n_def_pos_args, n_args);
             }
         }
     }
@@ -203,8 +205,8 @@
             for (size_t j = 0; j < n_pos_args + n_kwonly_args; j++) {
                 if (wanted_arg_name == arg_names[j]) {
                     if (code_state->state[n_state - 1 - j] != MP_OBJ_NULL) {
-                        mp_raise_msg_varg(&mp_type_TypeError,
-                            "function got multiple values for argument '%q'", MP_OBJ_QSTR_VALUE(wanted_arg_name));
+                        return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                            "function got multiple values for argument '%q'", MP_OBJ_QSTR_VALUE(wanted_arg_name)));
                     }
                     code_state->state[n_state - 1 - j] = kwargs[2 * i + 1];
                     goto continue2;
@@ -213,10 +215,10 @@
             // Didn't find name match with positional args
             if ((scope_flags & MP_SCOPE_FLAG_VARKEYWORDS) == 0) {
                 if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-                    mp_raise_TypeError("unexpected keyword argument");
+                    return mp_raise_TypeError_o("unexpected keyword argument");
                 } else {
-                    mp_raise_msg_varg(&mp_type_TypeError,
-                        "unexpected keyword argument '%q'", MP_OBJ_QSTR_VALUE(wanted_arg_name));
+                    return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                        "unexpected keyword argument '%q'", MP_OBJ_QSTR_VALUE(wanted_arg_name)));
                 }
             }
             mp_obj_dict_store(dict, kwargs[2 * i], kwargs[2 * i + 1]);
@@ -241,8 +243,8 @@
         // Check that all mandatory positional args are specified
         while (d < &code_state->state[n_state]) {
             if (*d++ == MP_OBJ_NULL) {
-                mp_raise_msg_varg(&mp_type_TypeError,
-                    "function missing required positional argument #%d", &code_state->state[n_state] - d);
+                return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                    "function missing required positional argument #%d", &code_state->state[n_state] - d));
             }
         }
 
@@ -257,8 +259,8 @@
                 if (elem != NULL) {
                     code_state->state[n_state - 1 - n_pos_args - i] = elem->value;
                 } else {
-                    mp_raise_msg_varg(&mp_type_TypeError,
-                        "function missing required keyword argument '%q'", MP_OBJ_QSTR_VALUE(arg_names[n_pos_args + i]));
+                    return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                        "function missing required keyword argument '%q'", MP_OBJ_QSTR_VALUE(arg_names[n_pos_args + i])));
                 }
             }
         }
@@ -266,7 +268,7 @@
     } else {
         // no keyword arguments given
         if (n_kwonly_args != 0) {
-            mp_raise_TypeError("function missing keyword-only argument");
+            return mp_raise_TypeError_o("function missing keyword-only argument");
         }
         if ((scope_flags & MP_SCOPE_FLAG_VARKEYWORDS) != 0) {
             *var_pos_kw_args = mp_obj_new_dict(0);
@@ -298,6 +300,8 @@
     DEBUG_printf("Calling: n_pos_args=%d, n_kwonly_args=%d\n", n_pos_args, n_kwonly_args);
     dump_args(code_state->state + n_state - n_pos_args - n_kwonly_args, n_pos_args + n_kwonly_args);
     dump_args(code_state->state, n_state);
+
+    return MP_OBJ_SENTINEL; // success
 }
 
 #if MICROPY_PERSISTENT_CODE_LOAD || MICROPY_PERSISTENT_CODE_SAVE
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/bc.h	2020-05-01 00:05:34.688250927 +0200
+++ micropython-master-no_nlr/py/bc.h	2020-04-30 23:32:39.482154944 +0200
@@ -225,7 +225,7 @@
 
 mp_vm_return_kind_t mp_execute_bytecode(mp_code_state_t *code_state, volatile mp_obj_t inject_exc);
 mp_code_state_t *mp_obj_fun_bc_prepare_codestate(mp_obj_t func, size_t n_args, size_t n_kw, const mp_obj_t *args);
-void mp_setup_code_state(mp_code_state_t *code_state, size_t n_args, size_t n_kw, const mp_obj_t *args);
+mp_obj_t mp_setup_code_state(mp_code_state_t *code_state, size_t n_args, size_t n_kw, const mp_obj_t *args);
 void mp_bytecode_print(const void *descr, const byte *code, mp_uint_t len, const mp_uint_t *const_table);
 void mp_bytecode_print2(const byte *code, size_t len, const mp_uint_t *const_table);
 const byte *mp_bytecode_print_str(const byte *ip);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/binary.c	2020-05-01 00:05:34.688250927 +0200
+++ micropython-master-no_nlr/py/binary.c	2020-04-30 23:32:39.482154944 +0200
@@ -135,7 +135,8 @@
     }
 
     if (size == 0) {
-        mp_raise_ValueError("bad typecode");
+        mp_raise_ValueError_o("bad typecode");
+        return 0;
     }
 
     if (palign != NULL) {
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/builtinevex.c	2020-05-01 00:56:48.646186033 +0200
+++ micropython-master-no_nlr/py/builtinevex.c	2020-05-01 00:53:18.165054347 +0200
@@ -58,19 +58,10 @@
     }
 
     // execute code
-    nlr_buf_t nlr;
-    if (nlr_push(&nlr) == 0) {
-        mp_obj_t ret = mp_call_function_0(self->module_fun);
-        nlr_pop();
-        mp_globals_set(old_globals);
-        mp_locals_set(old_locals);
-        return ret;
-    } else {
-        // exception; restore context and re-raise same exception
-        mp_globals_set(old_globals);
-        mp_locals_set(old_locals);
-        nlr_jump(nlr.ret_val);
-    }
+    mp_obj_t ret = mp_call_function_0(self->module_fun);
+    mp_globals_set(old_globals);
+    mp_locals_set(old_locals);
+    return ret;
 }
 
 STATIC mp_obj_t mp_builtin_compile(size_t n_args, const mp_obj_t *args) {
@@ -100,12 +91,15 @@
             parse_input_kind = MP_PARSE_EVAL_INPUT;
             break;
         default:
-            mp_raise_ValueError("bad compile mode");
+            return mp_raise_ValueError_o("bad compile mode");
     }
 
     mp_obj_code_t *code = m_new_obj(mp_obj_code_t);
     code->base.type = &mp_type_code;
     code->module_fun = mp_parse_compile_execute(lex, parse_input_kind, NULL, NULL);
+    if (code->module_fun == MP_OBJ_NULL) {
+        return MP_OBJ_NULL;
+    }
     return MP_OBJ_FROM_PTR(code);
 }
 MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_compile_obj, 3, 6, mp_builtin_compile);
@@ -121,7 +115,7 @@
     for (size_t i = 1; i < 3 && i < n_args; ++i) {
         if (args[i] != mp_const_none) {
             if (!mp_obj_is_type(args[i], &mp_type_dict)) {
-                mp_raise_TypeError(NULL);
+                return mp_raise_TypeError_o(NULL);
             }
             locals = MP_OBJ_TO_PTR(args[i]);
             if (i == 1) {
@@ -150,6 +144,10 @@
         lex = mp_lexer_new_from_str_len(MP_QSTR__lt_string_gt_, bufinfo.buf, bufinfo.len, 0);
     }
 
+    if (lex == NULL) {
+        return MP_OBJ_NULL;
+    }
+
     return mp_parse_compile_execute(lex, parse_input_kind, globals, locals);
 }
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/builtinimport.c	2020-05-01 00:05:34.688250927 +0200
+++ micropython-master-no_nlr/py/builtinimport.c	2020-05-01 00:21:57.358553002 +0200
@@ -130,7 +130,7 @@
 }
 
 #if MICROPY_MODULE_FROZEN_STR || MICROPY_ENABLE_COMPILER
-STATIC void do_load_from_lexer(mp_obj_t module_obj, mp_lexer_t *lex) {
+STATIC int do_load_from_lexer(mp_obj_t module_obj, mp_lexer_t *lex) {
     #if MICROPY_PY___FILE__
     qstr source_name = lex->source_name;
     mp_store_attr(module_obj, MP_QSTR___file__, MP_OBJ_NEW_QSTR(source_name));
@@ -138,12 +138,12 @@
 
     // parse, compile and execute the module in its context
     mp_obj_dict_t *mod_globals = mp_obj_module_get_globals(module_obj);
-    mp_parse_compile_execute(lex, MP_PARSE_FILE_INPUT, mod_globals, mod_globals);
+    return mp_parse_compile_execute(lex, MP_PARSE_FILE_INPUT, mod_globals, mod_globals) == MP_OBJ_NULL;
 }
 #endif
 
 #if MICROPY_PERSISTENT_CODE_LOAD || MICROPY_MODULE_FROZEN_MPY
-STATIC void do_execute_raw_code(mp_obj_t module_obj, mp_raw_code_t *raw_code, const char *source_name) {
+STATIC int do_execute_raw_code(mp_obj_t module_obj, mp_raw_code_t *raw_code, const char *source_name) {
     (void)source_name;
 
     #if MICROPY_PY___FILE__
@@ -161,25 +161,18 @@
     mp_globals_set(mod_globals);
     mp_locals_set(mod_globals);
 
-    nlr_buf_t nlr;
-    if (nlr_push(&nlr) == 0) {
-        mp_obj_t module_fun = mp_make_function_from_raw_code(raw_code, MP_OBJ_NULL, MP_OBJ_NULL);
-        mp_call_function_0(module_fun);
-
-        // finish nlr block, restore context
-        nlr_pop();
-        mp_globals_set(old_globals);
-        mp_locals_set(old_locals);
-    } else {
-        // exception; restore context and re-raise same exception
-        mp_globals_set(old_globals);
-        mp_locals_set(old_locals);
-        nlr_jump(nlr.ret_val);
-    }
+    mp_obj_t module_fun = mp_make_function_from_raw_code(raw_code, MP_OBJ_NULL, MP_OBJ_NULL);
+    module_fun = mp_call_function_0(module_fun);
+
+    // restore context
+    mp_globals_set(old_globals);
+    mp_locals_set(old_locals);
+
+    return module_fun == MP_OBJ_NULL;
 }
 #endif
 
-STATIC void do_load(mp_obj_t module_obj, vstr_t *file) {
+STATIC int do_load(mp_obj_t module_obj, vstr_t *file) {
     #if MICROPY_MODULE_FROZEN || MICROPY_ENABLE_COMPILER || (MICROPY_PERSISTENT_CODE_LOAD && MICROPY_HAS_FILE_READER)
     char *file_str = vstr_null_terminated_str(file);
     #endif
@@ -195,8 +188,7 @@
     // found the filename in the list of frozen files, then load and execute it.
     #if MICROPY_MODULE_FROZEN_STR
     if (frozen_type == MP_FROZEN_STR) {
-        do_load_from_lexer(module_obj, modref);
-        return;
+        return do_load_from_lexer(module_obj, modref);
     }
     #endif
 
@@ -204,8 +196,7 @@
     // its data) in the list of frozen files, execute it.
     #if MICROPY_MODULE_FROZEN_MPY
     if (frozen_type == MP_FROZEN_MPY) {
-        do_execute_raw_code(module_obj, modref, file_str);
-        return;
+        return do_execute_raw_code(module_obj, modref, file_str);
     }
     #endif
 
@@ -214,8 +205,10 @@
     #if MICROPY_HAS_FILE_READER && MICROPY_PERSISTENT_CODE_LOAD
     if (file_str[file->len - 3] == 'm') {
         mp_raw_code_t *raw_code = mp_raw_code_load_file(file_str);
-        do_execute_raw_code(module_obj, raw_code, file_str);
-        return;
+        if (raw_code == NULL) {
+            return 1;
+        }
+        return do_execute_raw_code(module_obj, raw_code, file_str);
     }
     #endif
 
@@ -223,12 +216,12 @@
     #if MICROPY_ENABLE_COMPILER
     {
         mp_lexer_t *lex = mp_lexer_new_from_file(file_str);
-        do_load_from_lexer(module_obj, lex);
-        return;
+        return do_load_from_lexer(module_obj, lex);
     }
     #else
     // If we get here then the file was not frozen and we can't compile scripts.
-    mp_raise_msg(&mp_type_ImportError, "script compilation not supported");
+    mp_raise_msg_o(&mp_type_ImportError, "script compilation not supported");
+    return 1;
     #endif
 }
 
@@ -261,13 +254,16 @@
         if (n_args >= 5) {
             level = MP_OBJ_SMALL_INT_VALUE(args[4]);
             if (level < 0) {
-                mp_raise_ValueError(NULL);
+                return mp_raise_ValueError_o(NULL);
             }
         }
     }
 
     size_t mod_len;
     const char *mod_str = mp_obj_str_get_data(module_name, &mod_len);
+    if (mod_str == NULL) {
+        return MP_OBJ_NULL;
+    }
 
     if (level != 0) {
         // What we want to do here is to take name of current module,
@@ -279,11 +275,17 @@
         // module's position in the package hierarchy."
         level--;
         mp_obj_t this_name_q = mp_obj_dict_get(MP_OBJ_FROM_PTR(mp_globals_get()), MP_OBJ_NEW_QSTR(MP_QSTR___name__));
+        if (this_name_q == MP_OBJ_NULL) {
+            return MP_OBJ_NULL;
+        }
         assert(this_name_q != MP_OBJ_NULL);
         #if MICROPY_CPYTHON_COMPAT
         if (MP_OBJ_QSTR_VALUE(this_name_q) == MP_QSTR___main__) {
             // This is a module run by -m command-line switch, get its real name from backup attribute
             this_name_q = mp_obj_dict_get(MP_OBJ_FROM_PTR(mp_globals_get()), MP_OBJ_NEW_QSTR(MP_QSTR___main__));
+            if (this_name_q == MP_OBJ_NULL) {
+                return MP_OBJ_NULL;
+            }
         }
         #endif
         mp_map_t *globals_map = &mp_globals_get()->map;
@@ -313,7 +315,7 @@
 
         // We must have some component left over to import from
         if (p == this_name) {
-            mp_raise_ValueError("cannot perform relative import");
+            return mp_raise_ValueError_o("cannot perform relative import");
         }
 
         uint new_mod_l = (mod_len == 0 ? (size_t)(p - this_name) : (size_t)(p - this_name) + 1 + mod_len);
@@ -397,9 +399,10 @@
                 if (module_obj == MP_OBJ_NULL) {
                     // couldn't find the file, so fail
                     if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-                        mp_raise_msg(&mp_type_ImportError, "module not found");
+                        return mp_raise_msg_o(&mp_type_ImportError, "module not found");
                     } else {
-                        mp_raise_msg_varg(&mp_type_ImportError, "no module named '%q'", mod_name);
+                        return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_ImportError,
+                            "no module named '%q'", mod_name));
                     }
                 }
             } else {
@@ -442,11 +445,17 @@
                     if (stat_file_py_or_mpy(&path) != MP_IMPORT_STAT_FILE) {
                         //mp_warning("%s is imported as namespace package", vstr_str(&path));
                     } else {
-                        do_load(module_obj, &path);
+                        if (do_load(module_obj, &path)) {
+                            // exception
+                            return MP_OBJ_NULL;
+                        }
                     }
                     path.len = orig_path_len;
                 } else { // MP_IMPORT_STAT_FILE
-                    do_load(module_obj, &path);
+                    if (do_load(module_obj, &path)) {
+                        // exception
+                        return MP_OBJ_NULL;
+                    }
                     // This should be the last component in the import path.  If there are
                     // remaining components then it's an ImportError because the current path
                     // (the module that was just loaded) is not a package.  This will be caught
@@ -478,11 +487,14 @@
 mp_obj_t mp_builtin___import__(size_t n_args, const mp_obj_t *args) {
     // Check that it's not a relative import
     if (n_args >= 5 && MP_OBJ_SMALL_INT_VALUE(args[4]) != 0) {
-        mp_raise_NotImplementedError("relative import");
+        return mp_raise_NotImplementedError_o("relative import");
     }
 
     // Check if module already exists, and return it if it does
     qstr module_name_qstr = mp_obj_str_get_qstr(args[0]);
+    if (module_name_qstr == MP_QSTR_NULL) {
+        return MP_OBJ_NULL;
+    }
     mp_obj_t module_obj = mp_module_get(module_name_qstr);
     if (module_obj != MP_OBJ_NULL) {
         return module_obj;
@@ -500,9 +512,10 @@
 
     // Couldn't find the module, so fail
     if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-        mp_raise_msg(&mp_type_ImportError, "module not found");
+        return mp_raise_msg_o(&mp_type_ImportError, "module not found");
     } else {
-        mp_raise_msg_varg(&mp_type_ImportError, "no module named '%q'", module_name_qstr);
+        return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_ImportError,
+            "no module named '%q'", module_name_qstr));
     }
 }
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/compile.c	2020-05-01 00:05:34.688250927 +0200
+++ micropython-master-no_nlr/py/compile.c	2020-04-30 23:32:39.484154916 +0200
@@ -241,6 +241,9 @@
 
 STATIC scope_t *scope_new_and_link(compiler_t *comp, scope_kind_t kind, mp_parse_node_t pn, uint emit_options) {
     scope_t *scope = scope_new(kind, pn, comp->source_file, emit_options);
+    if (scope == NULL) {
+        return NULL;
+    }
     scope->parent = comp->scope_cur;
     scope->next = NULL;
     if (comp->scope_head == NULL) {
@@ -3463,6 +3466,9 @@
     // create standard emitter; it's used at least for MP_PASS_SCOPE
     emit_t *emit_bc = emit_bc_new();
 
+    if (module_scope == NULL || emit_bc == NULL) {
+        return NULL;
+    }
     // compile pass 1
     comp->emit = emit_bc;
     #if MICROPY_EMIT_NATIVE
@@ -3478,6 +3484,10 @@
         {
             compile_scope(comp, s, MP_PASS_SCOPE);
 
+            if (MP_STATE_THREAD(active_exception) != NULL) {
+                return NULL;
+            }
+
             // Check if any implicitly declared variables should be closed over
             for (size_t i = 0; i < s->id_info_len; ++i) {
                 id_info_t *id = &s->id_info[i];
@@ -3500,6 +3510,9 @@
 
     // set max number of labels now that it's calculated
     emit_bc_set_max_num_labels(emit_bc, max_num_labels);
+    if (MP_STATE_THREAD(active_exception) != NULL) {
+        return NULL;
+    }
 
     // compile pass 2 and 3
     #if MICROPY_EMIT_NATIVE
@@ -3560,12 +3573,12 @@
             compile_scope(comp, s, MP_PASS_STACK_SIZE);
 
             // second last pass: compute code size
-            if (comp->compile_error == MP_OBJ_NULL) {
+            if (MP_STATE_THREAD(active_exception) == NULL && comp->compile_error == MP_OBJ_NULL) {
                 compile_scope(comp, s, MP_PASS_CODE_SIZE);
             }
 
             // final pass: emit code
-            if (comp->compile_error == MP_OBJ_NULL) {
+            if (MP_STATE_THREAD(active_exception) == NULL && comp->compile_error == MP_OBJ_NULL) {
                 compile_scope(comp, s, MP_PASS_EMIT);
             }
         }
@@ -3606,14 +3619,22 @@
     }
 
     if (comp->compile_error != MP_OBJ_NULL) {
-        nlr_raise(comp->compile_error);
+        mp_raise_o(comp->compile_error);
+        return NULL;
     } else {
         return outer_raw_code;
     }
 }
 
 mp_obj_t mp_compile(mp_parse_tree_t *parse_tree, qstr source_file, bool is_repl) {
+    if (MP_STATE_THREAD(active_exception) != NULL) {
+        // parser had an exception
+        return MP_OBJ_NULL;
+    }
     mp_raw_code_t *rc = mp_compile_to_raw_code(parse_tree, source_file, is_repl);
+    if (rc == NULL) {
+        return MP_OBJ_NULL;
+    }
     // return function that executes the outer module
     return mp_make_function_from_raw_code(rc, MP_OBJ_NULL, MP_OBJ_NULL);
 }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/emitcommon.c	2020-04-17 09:19:09.270299599 +0200
+++ micropython-master-no_nlr/py/emitcommon.c	2020-04-17 12:45:36.373620037 +0200
@@ -33,6 +33,9 @@
 void mp_emit_common_get_id_for_modification(scope_t *scope, qstr qst) {
     // name adding/lookup
     id_info_t *id = scope_find_or_add_id(scope, qst, ID_INFO_KIND_GLOBAL_IMPLICIT);
+    if (id == NULL) {
+        return;
+    }
     if (SCOPE_IS_FUNC_LIKE(scope->kind) && id->kind == ID_INFO_KIND_GLOBAL_IMPLICIT) {
         // rebind as a local variable
         id->kind = ID_INFO_KIND_LOCAL;
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/emitglue.c	2020-05-01 00:05:34.690250899 +0200
+++ micropython-master-no_nlr/py/emitglue.c	2020-04-30 23:32:39.484154916 +0200
@@ -52,6 +52,9 @@
 
 mp_raw_code_t *mp_emit_glue_new_raw_code(void) {
     mp_raw_code_t *rc = m_new0(mp_raw_code_t, 1);
+    if (rc == NULL) {
+        return NULL;
+    }
     rc->kind = MP_CODE_RESERVED;
     #if MICROPY_PY_SYS_SETTRACE
     rc->line_of_definition = 0;
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/emitnative.c	2020-05-01 00:05:34.690250899 +0200
+++ micropython-master-no_nlr/py/emitnative.c	2020-04-30 23:32:39.484154916 +0200
@@ -137,6 +137,9 @@
         *emit->error_slot = mp_obj_new_exception_msg_varg(&mp_type_ViperTypeError, __VA_ARGS__); \
 } while (0)
 
+#define JUMP_EXC(emit) ASM_JUMP((emit)->as, (emit)->exit_label + 3);
+#define CHECK_EXC(emit) ASM_JUMP_IF_REG_ZERO((emit)->as, REG_RET, (emit)->exit_label + 3, false)
+
 typedef enum {
     STACK_VALUE,
     STACK_REG,
@@ -586,6 +589,8 @@
             #else
             ASM_CALL_IND(emit->as, MP_F_SETUP_CODE_STATE);
             #endif
+            // Jump to ASM_EXIT if exception (MP_OBJ_NULL returned)
+            ASM_JUMP_IF_REG_ZERO(emit->as, REG_RET, *emit->label_slot + 4, false);
         }
 
         emit_native_global_exc_entry(emit);
@@ -841,7 +846,7 @@
         } else if (si->vtype == VTYPE_PTR_NONE) {
             emit_native_mov_reg_const(emit, reg_dest, MP_F_CONST_NONE_OBJ);
         } else {
-            mp_raise_NotImplementedError("conversion to object");
+            *emit->error_slot = mp_obj_new_exception_msg(&mp_type_NotImplementedError, "conversion to object");
         }
         return VTYPE_PYOBJ;
     }
@@ -1008,6 +1013,7 @@
     need_reg_all(emit);
     emit_native_mov_reg_qstr(emit, arg_reg, qst);
     ASM_CALL_IND(emit->as, fun_kind);
+    CHECK_EXC(emit);
 }
 
 // vtype of all n_pop objects is VTYPE_PYOBJ
@@ -1186,19 +1192,8 @@
         }
 
         if (emit->scope->exc_stack_size == 0) {
-            if (!(emit->scope->scope_flags & MP_SCOPE_FLAG_GENERATOR)) {
-                // Optimisation: if globals didn't change don't push the nlr context
-                ASM_JUMP_IF_REG_ZERO(emit->as, REG_RET, start_label, false);
-            }
-
-            // Wrap everything in an nlr context
-            ASM_MOV_REG_LOCAL_ADDR(emit->as, REG_ARG_1, 0);
-            emit_call(emit, MP_F_NLR_PUSH);
-            #if N_NLR_SETJMP
-            ASM_MOV_REG_LOCAL_ADDR(emit->as, REG_ARG_1, 2);
-            emit_call(emit, MP_F_SETJMP);
-            #endif
-            ASM_JUMP_IF_REG_ZERO(emit->as, REG_RET, start_label, true);
+            ASM_JUMP(emit->as, start_label);
+            emit_native_label_assign(emit, global_except_label);
         } else {
             // Clear the unwind state
             ASM_XOR_REG_REG(emit->as, REG_TEMP0, REG_TEMP0);
@@ -1207,41 +1202,25 @@
             // Put PC of start code block into REG_LOCAL_1
             ASM_MOV_REG_PCREL(emit->as, REG_LOCAL_1, start_label);
 
+#if HAVE_NLR
             // Wrap everything in an nlr context
             emit_native_label_assign(emit, nlr_label);
-            ASM_MOV_REG_LOCAL(emit->as, REG_LOCAL_2, LOCAL_IDX_EXC_HANDLER_UNWIND(emit));
-            ASM_MOV_REG_LOCAL_ADDR(emit->as, REG_ARG_1, 0);
-            emit_call(emit, MP_F_NLR_PUSH);
-            #if N_NLR_SETJMP
-            ASM_MOV_REG_LOCAL_ADDR(emit->as, REG_ARG_1, 2);
-            emit_call(emit, MP_F_SETJMP);
-            #endif
-            ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_EXC_HANDLER_UNWIND(emit), REG_LOCAL_2);
-            ASM_JUMP_IF_REG_NONZERO(emit->as, REG_RET, global_except_label, true);
-
+            emit_call(emit, MP_F_NATIVE_CLR_EXC); // clear active_exception because we are handling it (may need to re-raise it later)
+#endif
             // Clear PC of current code block, and jump there to resume execution
             ASM_XOR_REG_REG(emit->as, REG_TEMP0, REG_TEMP0);
             ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_EXC_HANDLER_PC(emit), REG_TEMP0);
             ASM_JUMP_REG(emit->as, REG_LOCAL_1);
-
+#if HAVE_NLR
             // Global exception handler: check for valid exception handler
             emit_native_label_assign(emit, global_except_label);
-            #if N_NLR_SETJMP
-            // Reload REG_FUN_TABLE, since it may be clobbered by longjmp
-            emit_native_mov_reg_state(emit, REG_LOCAL_1, LOCAL_IDX_FUN_OBJ(emit));
-            ASM_LOAD_REG_REG_OFFSET(emit->as, REG_LOCAL_1, REG_LOCAL_1, offsetof(mp_obj_fun_bc_t, const_table) / sizeof(uintptr_t));
-            ASM_LOAD_REG_REG_OFFSET(emit->as, REG_FUN_TABLE, REG_LOCAL_1, emit->scope->num_pos_args + emit->scope->num_kwonly_args);
-            #endif
+            emit_call(emit, MP_F_NATIVE_GET_EXC);
+#endif
+            ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_EXC_VAL(emit), REG_RET); // get active_exception and store it locally; TODO could perhaps change this so we load it on demand
             ASM_MOV_REG_LOCAL(emit->as, REG_LOCAL_1, LOCAL_IDX_EXC_HANDLER_PC(emit));
             ASM_JUMP_IF_REG_NONZERO(emit->as, REG_LOCAL_1, nlr_label, false);
         }
 
-        if (!(emit->scope->scope_flags & MP_SCOPE_FLAG_GENERATOR)) {
-            // Restore old globals
-            emit_native_mov_reg_state(emit, REG_ARG_1, LOCAL_IDX_OLD_GLOBALS(emit));
-            emit_call(emit, MP_F_NATIVE_SWAP_GLOBALS);
-        }
-
         if (emit->scope->scope_flags & MP_SCOPE_FLAG_GENERATOR) {
             // Store return value in state[0]
             ASM_MOV_REG_LOCAL(emit->as, REG_TEMP0, LOCAL_IDX_EXC_VAL(emit));
@@ -1250,11 +1229,13 @@
             // Load return kind
             ASM_MOV_REG_IMM(emit->as, REG_PARENT_RET, MP_VM_RETURN_EXCEPTION);
 
+            // TODO optimise with a jump to last ASM_EXIT?
             ASM_EXIT(emit->as);
         } else {
             // Re-raise exception out to caller
-            ASM_MOV_REG_LOCAL(emit->as, REG_ARG_1, LOCAL_IDX_EXC_VAL(emit));
-            emit_call(emit, MP_F_NATIVE_RAISE);
+            ASM_MOV_REG_IMM(emit->as, REG_RET, (mp_uint_t)MP_OBJ_NULL);
+            ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_RET_VAL(emit), REG_RET);
+            ASM_JUMP(emit->as, emit->exit_label);
         }
 
         // Label for start of function
@@ -1269,7 +1250,8 @@
 
             // Check LOCAL_IDX_EXC_VAL for any injected value
             ASM_MOV_REG_LOCAL(emit->as, REG_ARG_1, LOCAL_IDX_EXC_VAL(emit));
-            emit_call(emit, MP_F_NATIVE_RAISE);
+            emit_call(emit, MP_F_NATIVE_RAISE); // returns MP_OBJ_NULL if there's something to raise
+            CHECK_EXC(emit);
         }
     }
 }
@@ -1284,18 +1266,13 @@
             emit_native_mov_reg_state(emit, REG_ARG_1, LOCAL_IDX_OLD_GLOBALS(emit));
 
             if (emit->scope->exc_stack_size == 0) {
-                // Optimisation: if globals didn't change then don't restore them and don't do nlr_pop
+                // Optimisation: if globals didn't change then don't restore them
                 ASM_JUMP_IF_REG_ZERO(emit->as, REG_ARG_1, emit->exit_label + 1, false);
             }
 
             // Restore old globals
             emit_call(emit, MP_F_NATIVE_SWAP_GLOBALS);
-        }
-
-        // Pop the nlr context
-        emit_call(emit, MP_F_NLR_POP);
 
-        if (!(emit->scope->scope_flags & MP_SCOPE_FLAG_GENERATOR)) {
             if (emit->scope->exc_stack_size == 0) {
                 // Destination label for above optimisation
                 emit_native_label_assign(emit, emit->exit_label + 1);
@@ -1304,6 +1281,17 @@
 
         // Load return value
         ASM_MOV_REG_LOCAL(emit->as, REG_PARENT_RET, LOCAL_IDX_RET_VAL(emit));
+    } else {
+        // Without a global except handler there may still be exceptions but there is
+        // no special handling needed, just exit with REG_RET=MP_OBJ_NULL, which must
+        // be the case for all jumps that end up here.
+        mp_uint_t global_except_label = emit->exit_label + 3;
+        emit_native_label_assign(emit, global_except_label);
+    }
+
+    if (!emit->do_viper_types) {
+        // Add a label for ASM_EXIT to reduce generated code size (only used for non-viper)
+        emit_native_label_assign(emit, emit->exit_label + 4);
     }
 
     ASM_EXIT(emit->as);
@@ -1521,6 +1509,7 @@
         }
         emit_pre_pop_reg(emit, &vtype_base, REG_ARG_1);
         emit_call_with_imm_arg(emit, MP_F_OBJ_SUBSCR, (mp_uint_t)MP_OBJ_SENTINEL, REG_ARG_3);
+        CHECK_EXC(emit);
         emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);
     } else {
         // viper load
@@ -1730,6 +1719,7 @@
         }
         emit_pre_pop_reg_reg_reg(emit, &vtype_index, REG_ARG_2, &vtype_base, REG_ARG_1, &vtype_value, REG_ARG_3);
         emit_call(emit, MP_F_OBJ_SUBSCR);
+        CHECK_EXC(emit);
     } else {
         // viper store
         // TODO The different machine architectures have very different
@@ -1922,6 +1912,7 @@
     assert(vtype_index == VTYPE_PYOBJ);
     assert(vtype_base == VTYPE_PYOBJ);
     emit_call_with_imm_arg(emit, MP_F_OBJ_SUBSCR, (mp_uint_t)MP_OBJ_NULL, REG_ARG_3);
+    CHECK_EXC(emit);
 }
 
 STATIC void emit_native_subscr(emit_t *emit, int kind) {
@@ -2105,6 +2096,7 @@
     // call __enter__ method
     emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_3, 2); // pointer to items, including meth and self
     emit_call_with_2_imm_args(emit, MP_F_CALL_METHOD_N_KW, 0, REG_ARG_1, 0, REG_ARG_2);
+    CHECK_EXC(emit);
     emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET); // push return value of __enter__
     // stack: (..., __exit__, self, as_value)
 
@@ -2146,6 +2138,7 @@
     emit_post_push_imm(emit, VTYPE_PTR_NONE, 0);
     emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_3, 5);
     emit_call_with_2_imm_args(emit, MP_F_CALL_METHOD_N_KW, 3, REG_ARG_1, 0, REG_ARG_2);
+    CHECK_EXC(emit);
 
     // Replace exc with None and finish
     emit_native_jump(emit, *emit->label_slot);
@@ -2175,6 +2168,7 @@
     // call __exit__ method
     emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_3, 5);
     emit_call_with_2_imm_args(emit, MP_F_CALL_METHOD_N_KW, 3, REG_ARG_1, 0, REG_ARG_2);
+    // TODO write test for when the above MP_F_CALL_METHOD_N_KW fails
     // Stack: (...)
 
     // If REG_RET is true then we need to replace exception with None (swallow exception)
@@ -2193,9 +2187,13 @@
     emit_native_label_assign(emit, *emit->label_slot + 1);
 
     // Exception is in nlr_buf.ret_val slot
+
+    ASM_MOV_REG_LOCAL(emit->as, REG_ARG_1, LOCAL_IDX_EXC_VAL(emit)); // get exc
+    emit_call(emit, MP_F_NATIVE_RAISE); // re-raise (won't do anything if it's None from swallowed above)
 }
 
 STATIC void emit_native_end_finally(emit_t *emit) {
+    // TODO rewrite this comment
     // logic:
     //   exc = pop_stack
     //   if exc == None: pass
@@ -2203,7 +2201,8 @@
     // the check if exc is None is done in the MP_F_NATIVE_RAISE stub
     emit_native_pre(emit);
     ASM_MOV_REG_LOCAL(emit->as, REG_ARG_1, LOCAL_IDX_EXC_VAL(emit));
-    emit_call(emit, MP_F_NATIVE_RAISE);
+    emit_call(emit, MP_F_NATIVE_RAISE); // returns MP_OBJ_NULL if there's something to raise
+    CHECK_EXC(emit);
 
     // Get state for this finally and see if we need to unwind
     exc_stack_entry_t *e = emit_native_pop_exc_stack(emit);
@@ -2231,10 +2230,12 @@
     if (use_stack) {
         emit_get_stack_pointer_to_reg_for_push(emit, REG_ARG_2, MP_OBJ_ITER_BUF_NSLOTS);
         emit_call(emit, MP_F_NATIVE_GETITER);
+        CHECK_EXC(emit);
     } else {
         // mp_getiter will allocate the iter_buf on the heap
         ASM_MOV_REG_IMM(emit->as, REG_ARG_2, 0);
         emit_call(emit, MP_F_NATIVE_GETITER);
+        CHECK_EXC(emit);
         emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);
     }
 }
@@ -2244,6 +2245,7 @@
     emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_1, MP_OBJ_ITER_BUF_NSLOTS);
     adjust_stack(emit, MP_OBJ_ITER_BUF_NSLOTS);
     emit_call(emit, MP_F_NATIVE_ITERNEXT);
+    CHECK_EXC(emit);
     #if MICROPY_DEBUG_MP_OBJ_SENTINELS
     ASM_MOV_REG_IMM(emit->as, REG_TEMP1, (mp_uint_t)MP_OBJ_STOP_ITERATION);
     ASM_JUMP_IF_REG_EQ(emit->as, REG_RET, REG_TEMP1, label);
@@ -2277,6 +2279,7 @@
     emit_pre_pop_reg(emit, &vtype, REG_ARG_2);
     if (vtype == VTYPE_PYOBJ) {
         emit_call_with_imm_arg(emit, MP_F_UNARY_OP, op, REG_ARG_1);
+        CHECK_EXC(emit);
         emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);
     } else {
         adjust_stack(emit, 1);
@@ -2453,9 +2456,11 @@
             op = MP_BINARY_OP_IS;
         }
         emit_call_with_imm_arg(emit, MP_F_BINARY_OP, op, REG_ARG_1);
+        CHECK_EXC(emit);
         if (invert) {
             ASM_MOV_REG_REG(emit->as, REG_ARG_2, REG_RET);
             emit_call_with_imm_arg(emit, MP_F_UNARY_OP, MP_UNARY_OP_NOT, REG_ARG_1);
+            CHECK_EXC(emit);
         }
         emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);
     } else {
@@ -2488,6 +2493,7 @@
         emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_2, n_args); // pointer to items
     }
     emit_call_with_imm_arg(emit, MP_F_BUILD_TUPLE + kind, n_args, REG_ARG_1);
+    CHECK_EXC(emit);
     emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET); // new tuple/list/map/set
 }
 
@@ -2498,6 +2504,7 @@
     assert(vtype_value == VTYPE_PYOBJ);
     assert(vtype_map == VTYPE_PYOBJ);
     emit_call(emit, MP_F_STORE_MAP);
+    CHECK_EXC(emit);
     emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET); // map
 }
 
@@ -2519,6 +2526,7 @@
         assert(vtype_step == VTYPE_PYOBJ);
     }
     emit_call(emit, MP_F_NEW_SLICE);
+    CHECK_EXC(emit);
     emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);
 }
 #endif
@@ -2549,6 +2557,7 @@
     emit_access_stack(emit, collection_index, &vtype_collection, REG_ARG_1);
     assert(vtype_collection == VTYPE_PYOBJ);
     emit_call(emit, f);
+    // TODO write test for failure here
     emit_post(emit);
 }
 
@@ -2559,6 +2568,7 @@
     assert(vtype_base == VTYPE_PYOBJ);
     emit_get_stack_pointer_to_reg_for_push(emit, REG_ARG_3, n_args); // arg3 = dest ptr
     emit_call_with_imm_arg(emit, MP_F_UNPACK_SEQUENCE, n_args, REG_ARG_2); // arg2 = n_args
+    CHECK_EXC(emit);
 }
 
 STATIC void emit_native_unpack_ex(emit_t *emit, mp_uint_t n_left, mp_uint_t n_right) {
@@ -2568,6 +2578,7 @@
     assert(vtype_base == VTYPE_PYOBJ);
     emit_get_stack_pointer_to_reg_for_push(emit, REG_ARG_3, n_left + n_right + 1); // arg3 = dest ptr
     emit_call_with_imm_arg(emit, MP_F_UNPACK_EX, n_left | (n_right << 8), REG_ARG_2); // arg2 = n_left + n_right
+    CHECK_EXC(emit);
 }
 
 STATIC void emit_native_make_function(emit_t *emit, scope_t *scope, mp_uint_t n_pos_defaults, mp_uint_t n_kw_defaults) {
@@ -2639,13 +2650,16 @@
                 break;
             default:
                 // this can happen when casting a cast: int(int)
-                mp_raise_NotImplementedError("casting");
+                adjust_stack(emit, -1);
+                *emit->error_slot = mp_obj_new_exception_msg(&mp_type_NotImplementedError, "casting");
+                break;
         }
     } else {
         assert(vtype_fun == VTYPE_PYOBJ);
         if (star_flags) {
             emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_3, n_positional + 2 * n_keyword + 3); // pointer to args
             emit_call_with_2_imm_args(emit, MP_F_CALL_METHOD_N_KW_VAR, 0, REG_ARG_1, n_positional | (n_keyword << 8), REG_ARG_2);
+            CHECK_EXC(emit);
             emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);
         } else {
             if (n_positional != 0 || n_keyword != 0) {
@@ -2653,6 +2667,7 @@
             }
             emit_pre_pop_reg(emit, &vtype_fun, REG_ARG_1); // the function
             emit_call_with_imm_arg(emit, MP_F_NATIVE_CALL_FUNCTION_N_KW, n_positional | (n_keyword << 8), REG_ARG_2);
+            CHECK_EXC(emit);
             emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);
         }
     }
@@ -2662,11 +2677,13 @@
     if (star_flags) {
         emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_3, n_positional + 2 * n_keyword + 4); // pointer to args
         emit_call_with_2_imm_args(emit, MP_F_CALL_METHOD_N_KW_VAR, 1, REG_ARG_1, n_positional | (n_keyword << 8), REG_ARG_2);
+        CHECK_EXC(emit);
         emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);
     } else {
         emit_native_pre(emit);
         emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_3, 2 + n_positional + 2 * n_keyword); // pointer to items, including meth and self
         emit_call_with_2_imm_args(emit, MP_F_CALL_METHOD_N_KW, n_positional, REG_ARG_1, n_keyword, REG_ARG_2);
+        CHECK_EXC(emit);
         emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);
     }
 }
@@ -2735,14 +2752,15 @@
         EMIT_NATIVE_VIPER_TYPE_ERROR(emit, "must raise an object");
     }
     // TODO probably make this 1 call to the runtime (which could even call convert, native_raise(obj, type))
-    emit_call(emit, MP_F_NATIVE_RAISE);
+    emit_call(emit, MP_F_NATIVE_RAISE); // returns MP_OBJ_NULL if there's something to raise
+    JUMP_EXC(emit);
 }
 
 STATIC void emit_native_yield(emit_t *emit, int kind) {
     // Note: 1 (yield) or 3 (yield from) labels are reserved for this function, starting at *emit->label_slot
 
     if (emit->do_viper_types) {
-        mp_raise_NotImplementedError("native yield");
+        *emit->error_slot = mp_obj_new_exception_msg(&mp_type_NotImplementedError, "native yield");
     }
     emit->scope->scope_flags |= MP_SCOPE_FLAG_GENERATOR;
 
@@ -2798,7 +2816,8 @@
     if (kind == MP_EMIT_YIELD_VALUE) {
         // Check LOCAL_IDX_EXC_VAL for any injected value
         ASM_MOV_REG_LOCAL(emit->as, REG_ARG_1, LOCAL_IDX_EXC_VAL(emit));
-        emit_call(emit, MP_F_NATIVE_RAISE);
+        emit_call(emit, MP_F_NATIVE_RAISE); // returns MP_OBJ_NULL if there's something to raise
+        CHECK_EXC(emit);
     } else {
         // Label loop entry
         emit_native_label_assign(emit, *emit->label_slot + 2);
@@ -2814,7 +2833,12 @@
 
         // If returned non-zero then generator continues
         ASM_JUMP_IF_REG_NONZERO(emit->as, REG_RET, *emit->label_slot + 1, true);
-
+#if HAVE_NLR
+        // Check if native yield from raised an exception
+        // TODO could improve by having three options for return value of native yield from
+        emit_call(emit, MP_F_NATIVE_IS_EXC); // returns MP_OBJ_NULL if there's something to raise
+        CHECK_EXC(emit);
+#endif
         // Pop exhausted gen, replace with ret_value
         emit_native_adjust_stack_size(emit, 1); // ret_value
         emit_fold_stack_top(emit, REG_ARG_1);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/gc.c	2020-05-01 00:05:34.692250871 +0200
+++ micropython-master-no_nlr/py/gc.c	2020-05-01 00:23:54.784920693 +0200
@@ -328,11 +328,14 @@
     // Trace root pointers.  This relies on the root pointers being organised
     // correctly in the mp_state_ctx structure.  We scan nlr_top, dict_locals,
     // dict_globals, then the root pointer section of mp_state_vm.
-    void **ptrs = (void **)(void *)&mp_state_ctx;
+    void **ptrs = (void**)(void*)&mp_state_ctx;
+#if !defined(__EMSCRIPTEN__)
     size_t root_start = offsetof(mp_state_ctx_t, thread.dict_locals);
     size_t root_end = offsetof(mp_state_ctx_t, vm.qstr_last_chunk);
-    gc_collect_root(ptrs + root_start / sizeof(void *), (root_end - root_start) / sizeof(void *));
-
+    gc_collect_root(ptrs + root_start / sizeof(void*), (root_end - root_start) / sizeof(void*));
+#else
+    #pragma message "gc_collect_root : root collection turned off"
+#endif
     #if MICROPY_ENABLE_PYSTACK
     // Trace root pointers from the Python stack.
     ptrs = (void **)(void *)MP_STATE_THREAD(pystack_start);
@@ -434,6 +437,9 @@
     GC_EXIT();
 }
 
+unsigned gc_alloc_count_max = (unsigned)-1;
+static unsigned gc_alloc_count = 0;
+
 void *gc_alloc(size_t n_bytes, unsigned int alloc_flags) {
     bool has_finaliser = alloc_flags & GC_ALLOC_FLAG_HAS_FINALISER;
     size_t n_blocks = ((n_bytes + BYTES_PER_BLOCK - 1) & (~(BYTES_PER_BLOCK - 1))) / BYTES_PER_BLOCK;
@@ -452,6 +458,16 @@
         return NULL;
     }
 
+    if (gc_alloc_count_max != (unsigned)-1) {
+        if (gc_alloc_count == gc_alloc_count_max) {
+            GC_EXIT();
+            printf("** gc_alloc: %u force fail n_bytes=%u\n", gc_alloc_count, (unsigned)n_bytes);
+            return NULL;
+        }
+        printf("** gc_alloc: %u\n", gc_alloc_count);
+        ++gc_alloc_count;
+    }
+
     size_t i;
     size_t end_block;
     size_t start_block;
@@ -845,7 +861,7 @@
             /* this prints out if the object is reachable from BSS or STACK (for unix only)
             case AT_HEAD: {
                 c = 'h';
-                void **ptrs = (void**)(void*)&mp_state_ctx;
+                void **ptrs = (void **)(void *)&mp_state_ctx;
                 mp_uint_t len = offsetof(mp_state_ctx_t, vm.stack_top) / sizeof(mp_uint_t);
                 for (mp_uint_t i = 0; i < len; i++) {
                     mp_uint_t ptr = (mp_uint_t)ptrs[i];
@@ -855,7 +871,7 @@
                     }
                 }
                 if (c == 'h') {
-                    ptrs = (void**)&c;
+                    ptrs = (void **)&c;
                     len = ((mp_uint_t)MP_STATE_THREAD(stack_top) - (mp_uint_t)&c) / sizeof(mp_uint_t);
                     for (mp_uint_t i = 0; i < len; i++) {
                         mp_uint_t ptr = (mp_uint_t)ptrs[i];
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/lexer.c	2020-05-01 00:05:34.692250871 +0200
+++ micropython-master-no_nlr/py/lexer.c	2020-04-30 23:32:39.486154887 +0200
@@ -360,7 +360,8 @@
                             // 3MB of text; even gzip-compressed and with minimal structure, it'll take
                             // roughly half a meg of storage. This form of Unicode escape may be added
                             // later on, but it's definitely not a priority right now. -- CJA 20140607
-                            mp_raise_NotImplementedError("unicode name escapes");
+                            mp_raise_NotImplementedError_o("unicode name escapes");
+                            // TODO can we just safely break and expect caller to handle exception?
                             break;
                         default:
                             if (c >= '0' && c <= '7') {
@@ -689,6 +690,9 @@
 
 mp_lexer_t *mp_lexer_new(qstr src_name, mp_reader_t reader) {
     mp_lexer_t *lex = m_new_obj(mp_lexer_t);
+    if (lex == NULL) {
+        return NULL;
+    }
 
     lex->source_name = src_name;
     lex->reader = reader;
@@ -699,6 +703,9 @@
     lex->alloc_indent_level = MICROPY_ALLOC_LEXER_INDENT_INIT;
     lex->num_indent_level = 1;
     lex->indent_level = m_new(uint16_t, lex->alloc_indent_level);
+    if (lex->indent_level == NULL) {
+        return NULL;
+    }
     vstr_init(&lex->vstr, 32);
 
     // store sentinel for first indentation level
@@ -720,6 +727,10 @@
         lex->tok_kind = MP_TOKEN_INDENT;
     }
 
+    if (MP_STATE_THREAD(active_exception) != NULL) {
+        return NULL;
+    }
+
     return lex;
 }
 
@@ -734,6 +745,9 @@
 mp_lexer_t *mp_lexer_new_from_file(const char *filename) {
     mp_reader_t reader;
     mp_reader_new_file(&reader, filename);
+    if (MP_STATE_THREAD(active_exception) != NULL) {
+        return NULL;
+    }
     return mp_lexer_new(qstr_from_str(filename), reader);
 }
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/malloc.c	2020-05-01 00:05:34.692250871 +0200
+++ micropython-master-no_nlr/py/malloc.c	2020-04-30 23:32:39.486154887 +0200
@@ -85,7 +85,7 @@
 void *m_malloc(size_t num_bytes) {
     void *ptr = malloc(num_bytes);
     if (ptr == NULL && num_bytes != 0) {
-        m_malloc_fail(num_bytes);
+        return m_malloc_fail(num_bytes);
     }
     #if MICROPY_MEM_STATS
     MP_STATE_MEM(total_bytes_allocated) += num_bytes;
@@ -111,7 +111,7 @@
 void *m_malloc_with_finaliser(size_t num_bytes) {
     void *ptr = malloc_with_finaliser(num_bytes);
     if (ptr == NULL && num_bytes != 0) {
-        m_malloc_fail(num_bytes);
+        return m_malloc_fail(num_bytes);
     }
     #if MICROPY_MEM_STATS
     MP_STATE_MEM(total_bytes_allocated) += num_bytes;
@@ -140,7 +140,7 @@
 {
     void *new_ptr = realloc(ptr, new_num_bytes);
     if (new_ptr == NULL && new_num_bytes != 0) {
-        m_malloc_fail(new_num_bytes);
+        return m_malloc_fail(new_num_bytes);
     }
     #if MICROPY_MEM_STATS
     // At first thought, "Total bytes allocated" should only grow,
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/map.c	2020-05-01 00:05:34.692250871 +0200
+++ micropython-master-no_nlr/py/map.c	2020-04-30 23:32:39.486154887 +0200
@@ -118,12 +118,15 @@
     map->table = NULL;
 }
 
-STATIC void mp_map_rehash(mp_map_t *map) {
+STATIC int mp_map_rehash(mp_map_t *map) {
     size_t old_alloc = map->alloc;
     size_t new_alloc = get_hash_alloc_greater_or_equal_to(map->alloc + 1);
     DEBUG_printf("mp_map_rehash(%p): " UINT_FMT " -> " UINT_FMT "\n", map, old_alloc, new_alloc);
     mp_map_elem_t *old_table = map->table;
     mp_map_elem_t *new_table = m_new0(mp_map_elem_t, new_alloc);
+    if (new_table == NULL) {
+        return -1;
+    }
     // If we reach this point, table resizing succeeded, now we can edit the old map.
     map->alloc = new_alloc;
     map->used = 0;
@@ -135,6 +138,7 @@
         }
     }
     m_del(mp_map_elem_t, old_table, old_alloc);
+    return 0; // success
 }
 
 // MP_MAP_LOOKUP behaviour:
@@ -143,6 +147,7 @@
 //  - returns slot, with key non-null and value=MP_OBJ_NULL if it was added
 // MP_MAP_LOOKUP_REMOVE_IF_FOUND behaviour:
 //  - returns NULL if not found, else the slot if was found in with key null and value non-null
+// TODO: NULL return can mean 1) not found; 2) exception
 mp_map_elem_t *mp_map_lookup(mp_map_t *map, mp_obj_t index, mp_map_lookup_kind_t lookup_kind) {
     // If the map is a fixed array then we must only be called for a lookup
     assert(!map->is_fixed || lookup_kind == MP_MAP_LOOKUP);
@@ -210,7 +215,10 @@
 
     if (map->alloc == 0) {
         if (lookup_kind == MP_MAP_LOOKUP_ADD_IF_NOT_FOUND) {
-            mp_map_rehash(map);
+            if (mp_map_rehash(map)) {
+                // exception
+                return NULL;
+            }
         } else {
             return NULL;
         }
@@ -221,7 +229,11 @@
     if (mp_obj_is_qstr(index)) {
         hash = qstr_hash(MP_OBJ_QSTR_VALUE(index));
     } else {
-        hash = MP_OBJ_SMALL_INT_VALUE(mp_unary_op(MP_UNARY_OP_HASH, index));
+        mp_obj_t hash_o = mp_unary_op(MP_UNARY_OP_HASH, index);
+        if (hash_o == MP_OBJ_NULL) {
+            return NULL;
+        }
+        hash = MP_OBJ_SMALL_INT_VALUE(hash_o);
     }
 
     size_t pos = hash % map->alloc;
@@ -284,7 +296,10 @@
                     return avail_slot;
                 } else {
                     // not enough room in table, rehash it
-                    mp_map_rehash(map);
+                    if (mp_map_rehash(map)) {
+                        // exception
+                        return NULL;
+                    }
                     // restart the search for the new element
                     start_pos = pos = hash % map->alloc;
                 }
@@ -320,6 +335,7 @@
     m_del(mp_obj_t, old_table, old_alloc);
 }
 
+// TODO: MP_OBJ_NULL return can mean 1) not found; 2) exception
 mp_obj_t mp_set_lookup(mp_set_t *set, mp_obj_t index, mp_map_lookup_kind_t lookup_kind) {
     // Note: lookup_kind can be MP_MAP_LOOKUP_ADD_IF_NOT_FOUND_OR_REMOVE_IF_FOUND which
     // is handled by using bitwise operations.
@@ -331,7 +347,11 @@
             return MP_OBJ_NULL;
         }
     }
-    mp_uint_t hash = MP_OBJ_SMALL_INT_VALUE(mp_unary_op(MP_UNARY_OP_HASH, index));
+    mp_obj_t hash_o = mp_unary_op(MP_UNARY_OP_HASH, index);
+    if (hash_o == MP_OBJ_NULL) {
+        return MP_OBJ_NULL;
+    }
+    mp_uint_t hash = MP_OBJ_SMALL_INT_VALUE(hash_o);
     size_t pos = hash % set->alloc;
     size_t start_pos = pos;
     mp_obj_t *avail_slot = NULL;
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/misc.h	2020-05-01 00:05:34.692250871 +0200
+++ micropython-master-no_nlr/py/misc.h	2020-04-30 23:32:39.486154887 +0200
@@ -97,7 +97,7 @@
 void *m_realloc_maybe(void *ptr, size_t new_num_bytes, bool allow_move);
 void m_free(void *ptr);
 #endif
-NORETURN void m_malloc_fail(size_t num_bytes);
+void *m_malloc_fail(size_t num_bytes);
 
 #if MICROPY_MEM_STATS
 size_t m_get_total_bytes_allocated(void);
@@ -191,8 +191,8 @@
 char *vstr_null_terminated_str(vstr_t *vstr);
 void vstr_add_byte(vstr_t *vstr, byte v);
 void vstr_add_char(vstr_t *vstr, unichar chr);
-void vstr_add_str(vstr_t *vstr, const char *str);
-void vstr_add_strn(vstr_t *vstr, const char *str, size_t len);
+int vstr_add_str(vstr_t *vstr, const char *str);
+int vstr_add_strn(vstr_t *vstr, const char *str, size_t len);
 void vstr_ins_byte(vstr_t *vstr, size_t byte_pos, byte b);
 void vstr_ins_char(vstr_t *vstr, size_t char_pos, unichar chr);
 void vstr_cut_head_bytes(vstr_t *vstr, size_t bytes_to_cut);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/modbuiltins.c	2020-05-01 01:09:34.239637921 +0200
+++ micropython-master-no_nlr/py/modbuiltins.c	2020-05-01 00:25:17.295772895 +0200
@@ -97,11 +97,14 @@
     mp_obj_iter_buf_t iter_buf;
     mp_obj_t iterable = mp_getiter(o_in, &iter_buf);
     mp_obj_t item;
-    while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {
+    while ((item = mp_iternext2(iterable)) != MP_OBJ_NULL) {
         if (!mp_obj_is_true(item)) {
             return mp_const_false;
         }
     }
+    if (mp_iternext_had_exc()) {
+        return MP_OBJ_NULL;
+    }
     return mp_const_true;
 }
 MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_all_obj, mp_builtin_all);
@@ -110,11 +113,14 @@
     mp_obj_iter_buf_t iter_buf;
     mp_obj_t iterable = mp_getiter(o_in, &iter_buf);
     mp_obj_t item;
-    while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {
+    while ((item = mp_iternext2(iterable)) != MP_OBJ_NULL) {
         if (mp_obj_is_true(item)) {
             return mp_const_true;
         }
     }
+    if (mp_iternext_had_exc()) {
+        return MP_OBJ_NULL;
+    }
     return mp_const_false;
 }
 MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_any_obj, mp_builtin_any);
@@ -158,7 +164,7 @@
         str[3] = (c & 0x3F) | 0x80;
         len = 4;
     } else {
-        mp_raise_ValueError("chr() arg not in range(0x110000)");
+        return mp_raise_ValueError_o("chr() arg not in range(0x110000)");
     }
     return mp_obj_new_str_via_qstr((char *)str, len);
     #else
@@ -167,7 +173,7 @@
         uint8_t str[1] = {ord};
         return mp_obj_new_str_via_qstr((char *)str, 1);
     } else {
-        mp_raise_ValueError("chr() arg not in range(256)");
+        return mp_raise_ValueError_o("chr() arg not in range(256)");
     }
     #endif
 }
@@ -274,19 +280,22 @@
         mp_obj_t best_key = MP_OBJ_NULL;
         mp_obj_t best_obj = MP_OBJ_NULL;
         mp_obj_t item;
-        while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {
+        while ((item = mp_iternext2(iterable)) != MP_OBJ_NULL) {
             mp_obj_t key = key_fn == MP_OBJ_NULL ? item : mp_call_function_1(key_fn, item);
             if (best_obj == MP_OBJ_NULL || (mp_binary_op(op, key, best_key) == mp_const_true)) {
                 best_key = key;
                 best_obj = item;
             }
         }
+        if (mp_iternext_had_exc()) {
+            return MP_OBJ_NULL;
+        }
         if (best_obj == MP_OBJ_NULL) {
             default_elem = mp_map_lookup(kwargs, MP_OBJ_NEW_QSTR(MP_QSTR_default), MP_MAP_LOOKUP);
             if (default_elem != NULL) {
                 best_obj = default_elem->value;
             } else {
-                mp_raise_ValueError("arg is an empty sequence");
+                return mp_raise_ValueError_o("arg is an empty sequence");
             }
         }
         return best_obj;
@@ -322,7 +331,8 @@
     if (n_args == 1) {
         mp_obj_t ret = mp_iternext_allow_raise(args[0]);
         if (ret == MP_OBJ_STOP_ITERATION) {
-            mp_raise_type(&mp_type_StopIteration);
+            //mp_raise_type(&mp_type_StopIteration);
+            return mp_raise_o(mp_obj_new_exception(&mp_type_StopIteration));
         } else {
             return ret;
         }
@@ -336,7 +346,8 @@
 STATIC mp_obj_t mp_builtin_next(mp_obj_t o) {
     mp_obj_t ret = mp_iternext_allow_raise(o);
     if (ret == MP_OBJ_STOP_ITERATION) {
-        mp_raise_type(&mp_type_StopIteration);
+        // mp_raise_type(&mp_type_StopIteration);
+        return mp_raise_o(mp_obj_new_exception(&mp_type_StopIteration));
     } else {
         return ret;
     }
@@ -357,6 +368,10 @@
 STATIC mp_obj_t mp_builtin_ord(mp_obj_t o_in) {
     size_t len;
     const byte *str = (const byte *)mp_obj_str_get_data(o_in, &len);
+    if (str == NULL) {
+        // exception
+        return MP_OBJ_NULL;
+    }
     #if MICROPY_PY_BUILTINS_STR_UNICODE
     if (mp_obj_is_str(o_in)) {
         len = utf8_charlen(str, len);
@@ -373,10 +388,10 @@
     }
 
     if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-        mp_raise_TypeError("ord expects a character");
+        return mp_raise_TypeError_o("ord expects a character");
     } else {
-        mp_raise_msg_varg(&mp_type_TypeError,
-            "ord() expected a character, but string of length %d found", (int)len);
+        return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+            "ord() expected a character, but string of length %d found", (int)len));
     }
 }
 MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_ord_obj, mp_builtin_ord);
@@ -387,7 +402,7 @@
             return mp_binary_op(MP_BINARY_OP_POWER, args[0], args[1]);
         default:
             #if !MICROPY_PY_BUILTINS_POW3
-            mp_raise_NotImplementedError("3-arg pow() not supported");
+            return mp_raise_msg_o(&mp_type_NotImplementedError, "3-arg pow() not supported");
             #elif MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_MPZ
             return mp_binary_op(MP_BINARY_OP_MODULO, mp_binary_op(MP_BINARY_OP_POWER, args[0], args[1]), args[2]);
             #else
@@ -415,7 +430,9 @@
     mp_arg_parse_all(0, NULL, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, u.args);
 
     #if MICROPY_PY_IO && MICROPY_PY_SYS_STDFILES
-    mp_get_stream_raise(u.args[ARG_file].u_obj, MP_STREAM_OP_WRITE);
+    if (mp_get_stream_raise(u.args[ARG_file].u_obj, MP_STREAM_OP_WRITE) == NULL) {
+        return MP_OBJ_NULL;
+    }
     mp_print_t print = {MP_OBJ_TO_PTR(u.args[ARG_file].u_obj), mp_stream_write_adaptor};
     #endif
 
@@ -444,6 +461,10 @@
     #else
     mp_print_strn(&mp_plat_print, end_data, u.len[1], 0, 0, 0);
     #endif
+    if (MP_STATE_THREAD(active_exception) != NULL) {
+        // some printing function above had an exception
+        return MP_OBJ_NULL;
+    }
     return mp_const_none;
 }
 MP_DEFINE_CONST_FUN_OBJ_KW(mp_builtin_print_obj, 0, mp_builtin_print);
@@ -479,7 +500,7 @@
         }
 
         #if !MICROPY_PY_BUILTINS_ROUND_INT
-        mp_raise_NotImplementedError(NULL);
+        return mp_raise_NotImplementedError_o(NULL);
         #else
         mp_int_t num_dig = mp_obj_get_int(args[1]);
         if (num_dig >= 0) {
@@ -536,16 +557,19 @@
     mp_obj_iter_buf_t iter_buf;
     mp_obj_t iterable = mp_getiter(args[0], &iter_buf);
     mp_obj_t item;
-    while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {
+    while ((item = mp_iternext2(iterable)) != MP_OBJ_NULL) {
         value = mp_binary_op(MP_BINARY_OP_ADD, value, item);
     }
+    if (mp_iternext_had_exc()) {
+        return MP_OBJ_NULL;
+    }
     return value;
 }
 MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_sum_obj, 1, 2, mp_builtin_sum);
 
 STATIC mp_obj_t mp_builtin_sorted(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {
     if (n_args > 1) {
-        mp_raise_TypeError("must use keyword argument for key function");
+        return mp_raise_TypeError_o("must use keyword argument for key function");
     }
     mp_obj_t self = mp_type_list.make_new(&mp_type_list, 1, 0, args);
     mp_obj_list_sort(1, &self, kwargs);
@@ -580,7 +604,9 @@
 MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_getattr_obj, 2, 3, mp_builtin_getattr);
 
 STATIC mp_obj_t mp_builtin_setattr(mp_obj_t base, mp_obj_t attr, mp_obj_t value) {
-    mp_store_attr(base, mp_obj_str_get_qstr(attr), value);
+    if (mp_store_attr(base, mp_obj_str_get_qstr(attr), value) == MP_OBJ_NULL) {
+        return MP_OBJ_NULL;
+    }
     return mp_const_none;
 }
 MP_DEFINE_CONST_FUN_OBJ_3(mp_builtin_setattr_obj, mp_builtin_setattr);
@@ -594,8 +620,14 @@
 
 STATIC mp_obj_t mp_builtin_hasattr(mp_obj_t object_in, mp_obj_t attr_in) {
     qstr attr = mp_obj_str_get_qstr(attr_in);
+    if (attr == MP_QSTR_NULL) {
+        // exception
+        return MP_OBJ_NULL;
+    }
     mp_obj_t dest[2];
-    mp_load_method_protected(object_in, attr, dest, false);
+    if (mp_load_method_protected(object_in, attr, dest, false) == MP_OBJ_NULL) {
+        return MP_OBJ_NULL;
+    }
     return mp_obj_new_bool(dest[0] != MP_OBJ_NULL);
 }
 MP_DEFINE_CONST_FUN_OBJ_2(mp_builtin_hasattr_obj, mp_builtin_hasattr);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/modmath.c	2020-05-01 01:09:34.239637921 +0200
+++ micropython-master-no_nlr/py/modmath.c	2020-04-30 23:32:39.486154887 +0200
@@ -35,15 +35,15 @@
 // And by defining our own we can ensure it uses the correct const format.
 #define MP_PI MICROPY_FLOAT_CONST(3.14159265358979323846)
 
-STATIC NORETURN void math_error(void) {
-    mp_raise_ValueError("math domain error");
+STATIC mp_obj_t math_error(void) {
+    return mp_raise_ValueError_o("math domain error");
 }
 
 STATIC mp_obj_t math_generic_1(mp_obj_t x_obj, mp_float_t (*f)(mp_float_t)) {
     mp_float_t x = mp_obj_get_float(x_obj);
     mp_float_t ans = f(x);
     if ((isnan(ans) && !isnan(x)) || (isinf(ans) && !isinf(x))) {
-        math_error();
+        return math_error();
     }
     return mp_obj_new_float(ans);
 }
@@ -53,7 +53,7 @@
     mp_float_t y = mp_obj_get_float(y_obj);
     mp_float_t ans = f(x, y);
     if ((isnan(ans) && !isnan(x) && !isnan(y)) || (isinf(ans) && !isinf(x))) {
-        math_error();
+        return math_error();
     }
     return mp_obj_new_float(ans);
 }
@@ -188,7 +188,7 @@
         ? (mp_float_t)1e-9 : mp_obj_get_float(args[ARG_rel_tol].u_obj);
     const mp_float_t abs_tol = mp_obj_get_float(args[ARG_abs_tol].u_obj);
     if (rel_tol < (mp_float_t)0.0 || abs_tol < (mp_float_t)0.0) {
-        math_error();
+        return math_error();
     }
     if (a == b) {
         return mp_const_true;
@@ -213,7 +213,7 @@
 STATIC mp_obj_t mp_math_log(size_t n_args, const mp_obj_t *args) {
     mp_float_t x = mp_obj_get_float(args[0]);
     if (x <= (mp_float_t)0.0) {
-        math_error();
+        return math_error();
     }
     mp_float_t l = MICROPY_FLOAT_C_FUN(log)(x);
     if (n_args == 1) {
@@ -221,9 +221,9 @@
     } else {
         mp_float_t base = mp_obj_get_float(args[1]);
         if (base <= (mp_float_t)0.0) {
-            math_error();
+            return math_error();
         } else if (base == (mp_float_t)1.0) {
-            mp_raise_msg(&mp_type_ZeroDivisionError, "divide by zero");
+            return mp_raise_msg_o(&mp_type_ZeroDivisionError, "divide by zero");
         }
         return mp_obj_new_float(l / MICROPY_FLOAT_C_FUN(log)(base));
     }
@@ -294,7 +294,7 @@
 STATIC mp_obj_t mp_math_factorial(mp_obj_t x_obj) {
     mp_int_t max = mp_obj_get_int(x_obj);
     if (max < 0) {
-        mp_raise_ValueError("negative factorial");
+        return mp_raise_msg_o(&mp_type_ValueError, "negative factorial");
     } else if (max == 0) {
         return MP_OBJ_NEW_SMALL_INT(1);
     }
@@ -308,7 +308,7 @@
 STATIC mp_obj_t mp_math_factorial(mp_obj_t x_obj) {
     mp_int_t max = mp_obj_get_int(x_obj);
     if (max < 0) {
-        mp_raise_ValueError("negative factorial");
+        return mp_raise_msg_o(&mp_type_ValueError, "negative factorial");
     } else if (max <= 1) {
         return MP_OBJ_NEW_SMALL_INT(1);
     }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/modmicropython.c	2020-05-01 01:09:34.239637921 +0200
+++ micropython-master-no_nlr/py/modmicropython.c	2020-05-01 00:57:32.193592830 +0200
@@ -157,7 +157,7 @@
 #if MICROPY_ENABLE_SCHEDULER
 STATIC mp_obj_t mp_micropython_schedule(mp_obj_t function, mp_obj_t arg) {
     if (!mp_sched_schedule(function, arg)) {
-        mp_raise_msg(&mp_type_RuntimeError, "schedule queue full");
+        return mp_raise_msg_o(&mp_type_RuntimeError, "schedule queue full");
     }
     return mp_const_none;
 }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/modstruct.c	2020-05-01 00:05:34.694250842 +0200
+++ micropython-master-no_nlr/py/modstruct.c	2020-04-30 23:32:39.488154859 +0200
@@ -99,6 +99,9 @@
             total_cnt += cnt;
             size_t align;
             size_t sz = mp_binary_get_size(fmt_type, *fmt, &align);
+            if (sz == 0) {
+                return (size_t)-1;
+            }
             while (cnt--) {
                 // Apply alignment
                 size = (size + align - 1) & ~(align - 1);
@@ -112,8 +115,13 @@
 
 STATIC mp_obj_t struct_calcsize(mp_obj_t fmt_in) {
     const char *fmt = mp_obj_str_get_str(fmt_in);
+    if (fmt == NULL) {
+        return MP_OBJ_NULL;
+    }
     size_t size;
-    calc_size_items(fmt, &size);
+    if (calc_size_items(fmt, &size) == (size_t)-1) {
+        return MP_OBJ_NULL;
+    }
     return MP_OBJ_NEW_SMALL_INT(size);
 }
 MP_DEFINE_CONST_FUN_OBJ_1(struct_calcsize_obj, struct_calcsize);
@@ -126,6 +134,9 @@
     const char *fmt = mp_obj_str_get_str(args[0]);
     size_t total_sz;
     size_t num_items = calc_size_items(fmt, &total_sz);
+    if (num_items == (size_t)-1) {
+        return MP_OBJ_NULL;
+    }
     char fmt_type = get_fmt_type(&fmt);
     mp_obj_tuple_t *res = MP_OBJ_TO_PTR(mp_obj_new_tuple(num_items, NULL));
     mp_buffer_info_t bufinfo;
@@ -141,7 +152,7 @@
             // negative offsets are relative to the end of the buffer
             offset = bufinfo.len + offset;
             if (offset < 0) {
-                mp_raise_ValueError("buffer too small");
+                return mp_raise_ValueError_o("buffer too small");
             }
         }
         p += offset;
@@ -150,7 +161,7 @@
 
     // Check that the input buffer is big enough to unpack all the values
     if (p + total_sz > end_p) {
-        mp_raise_ValueError("buffer too small");
+        return mp_raise_ValueError_o("buffer too small");
     }
 
     for (size_t i = 0; i < num_items;) {
@@ -214,7 +225,11 @@
 
 STATIC mp_obj_t struct_pack(size_t n_args, const mp_obj_t *args) {
     // TODO: "The arguments must match the values required by the format exactly."
-    mp_int_t size = MP_OBJ_SMALL_INT_VALUE(struct_calcsize(args[0]));
+    mp_obj_t size_obj = struct_calcsize(args[0]);
+    if (size_obj == MP_OBJ_NULL) {
+        return MP_OBJ_NULL;
+    }
+    mp_int_t size = MP_OBJ_SMALL_INT_VALUE(size_obj);
     vstr_t vstr;
     vstr_init_len(&vstr, size);
     byte *p = (byte *)vstr.buf;
@@ -232,7 +247,7 @@
         // negative offsets are relative to the end of the buffer
         offset = (mp_int_t)bufinfo.len + offset;
         if (offset < 0) {
-            mp_raise_ValueError("buffer too small");
+            return mp_raise_ValueError_o("buffer too small");
         }
     }
     byte *p = (byte *)bufinfo.buf;
@@ -240,9 +255,13 @@
     p += offset;
 
     // Check that the output buffer is big enough to hold all the values
-    mp_int_t sz = MP_OBJ_SMALL_INT_VALUE(struct_calcsize(args[0]));
+    mp_obj_t sz_obj = struct_calcsize(args[0]);
+    if (sz_obj == MP_OBJ_NULL) {
+        return MP_OBJ_NULL;
+    }
+    mp_int_t sz = MP_OBJ_SMALL_INT_VALUE(sz_obj);
     if (p + sz > end_p) {
-        mp_raise_ValueError("buffer too small");
+        return mp_raise_ValueError_o("buffer too small");
     }
 
     struct_pack_into_internal(args[0], p, n_args - 3, &args[3]);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/modsys.c	2020-05-01 00:05:34.694250842 +0200
+++ micropython-master-no_nlr/py/modsys.c	2020-04-30 23:32:39.488154859 +0200
@@ -116,7 +116,7 @@
     } else {
         exc = mp_obj_new_exception_arg1(&mp_type_SystemExit, args[0]);
     }
-    nlr_raise(exc);
+    return mp_raise_o(exc);
 }
 MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_sys_exit_obj, 0, 1, mp_sys_exit);
 
@@ -124,7 +124,9 @@
     #if MICROPY_PY_IO && MICROPY_PY_SYS_STDFILES
     void *stream_obj = &mp_sys_stdout_obj;
     if (n_args > 1) {
-        mp_get_stream_raise(args[1], MP_STREAM_OP_WRITE);
+        if (mp_get_stream_raise(args[1], MP_STREAM_OP_WRITE) == NULL) {
+            return MP_OBJ_NULL;
+        }
         stream_obj = MP_OBJ_TO_PTR(args[1]);
     }
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/modthread.c	2020-05-01 00:05:34.694250842 +0200
+++ micropython-master-no_nlr/py/modthread.c	2020-05-01 00:25:53.263272334 +0200
@@ -77,7 +77,7 @@
         self->locked = true;
         return mp_const_true;
     } else {
-        mp_raise_OSError(-ret);
+        return mp_raise_OSError_o(-ret);
     }
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(thread_lock_acquire_obj, 1, 3, thread_lock_acquire);
@@ -85,7 +85,7 @@
 STATIC mp_obj_t thread_lock_release(mp_obj_t self_in) {
     mp_obj_thread_lock_t *self = MP_OBJ_TO_PTR(self_in);
     if (!self->locked) {
-        mp_raise_msg(&mp_type_RuntimeError, NULL);
+        return mp_raise_msg_o(&mp_type_RuntimeError, NULL);
     }
     self->locked = false;
     MP_THREAD_GIL_EXIT();
@@ -175,6 +175,8 @@
     mp_locals_set(args->dict_locals);
     mp_globals_set(args->dict_globals);
 
+    MP_STATE_THREAD(active_exception) = NULL;
+
     MP_THREAD_GIL_ENTER();
 
     // signal that we are set up and running
@@ -186,14 +188,11 @@
 
     DEBUG_printf("[thread] start ts=%p args=%p stack=%p\n", &ts, &args, MP_STATE_THREAD(stack_top));
 
-    nlr_buf_t nlr;
-    if (nlr_push(&nlr) == 0) {
-        mp_call_function_n_kw(args->fun, args->n_args, args->n_kw, args->args);
-        nlr_pop();
-    } else {
+    mp_call_function_n_kw(args->fun, args->n_args, args->n_kw, args->args);
+    if (MP_STATE_THREAD(active_exception) != NULL) {
         // uncaught exception
         // check for SystemExit
-        mp_obj_base_t *exc = (mp_obj_base_t *)nlr.ret_val;
+        mp_obj_base_t *exc = (mp_obj_base_t *)MP_STATE_THREAD(active_exception);
         if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(exc->type), MP_OBJ_FROM_PTR(&mp_type_SystemExit))) {
             // swallow exception silently
         } else {
@@ -235,7 +234,7 @@
     } else {
         // positional and keyword arguments
         if (mp_obj_get_type(args[2]) != &mp_type_dict) {
-            mp_raise_TypeError("expecting a dict for keyword args");
+            return mp_raise_TypeError_o("expecting a dict for keyword args");
         }
         mp_map_t *map = &((mp_obj_dict_t *)MP_OBJ_TO_PTR(args[2]))->map;
         th_args = m_new_obj_var(thread_entry_args_t, mp_obj_t, pos_args_len + 2 * map->used);
@@ -271,7 +270,8 @@
 STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_thread_start_new_thread_obj, 2, 3, mod_thread_start_new_thread);
 
 STATIC mp_obj_t mod_thread_exit(void) {
-    mp_raise_type(&mp_type_SystemExit);
+    //mp_raise_type(&mp_type_SystemExit);
+    return mp_raise_o(mp_obj_new_exception(&mp_type_SystemExit));
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_0(mod_thread_exit_obj, mod_thread_exit);
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/mpconfig.h	2020-05-01 01:09:34.241637894 +0200
+++ micropython-master-no_nlr/py/mpconfig.h	2020-05-01 00:57:32.193592830 +0200
@@ -438,8 +438,9 @@
 #endif
 
 // Whether to enable debugging versions of MP_OBJ_NULL/STOP_ITERATION/SENTINEL
+// Note: this is currently required for no NLR, to distinguish MP_OBJ_NULL (exception) from MP_OBJ_STOP_ITERATION
 #ifndef MICROPY_DEBUG_MP_OBJ_SENTINELS
-#define MICROPY_DEBUG_MP_OBJ_SENTINELS (0)
+#define MICROPY_DEBUG_MP_OBJ_SENTINELS (1)
 #endif
 
 // Whether to enable a simple VM stack overflow check
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/mpstate.h	2020-04-17 13:54:02.114895799 +0200
+++ micropython-master-no_nlr/py/mpstate.h	2020-04-17 13:05:28.061979138 +0200
@@ -257,6 +257,8 @@
     mp_obj_dict_t *dict_locals;
     mp_obj_dict_t *dict_globals;
 
+    mp_obj_base_t *active_exception;
+
     nlr_buf_t *nlr_top;
 
     #if MICROPY_PY_SYS_SETTRACE
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/nativeglue.c	2020-05-01 00:05:34.694250842 +0200
+++ micropython-master-no_nlr/py/nativeglue.c	2020-04-30 23:32:39.488154859 +0200
@@ -159,10 +159,27 @@
 
 // wrapper that makes raise obj and raises it
 // END_FINALLY opcode requires that we don't raise if o==None
-STATIC void mp_native_raise(mp_obj_t o) {
+STATIC mp_obj_t mp_native_raise(mp_obj_t o) {
     if (o != MP_OBJ_NULL && o != mp_const_none) {
-        nlr_raise(mp_make_raise_obj(o));
+        return mp_raise_o(mp_make_raise_obj(o));
     }
+    return MP_OBJ_SENTINEL;
+}
+
+STATIC mp_obj_t mp_native_is_exc(void) {
+    if (MP_STATE_THREAD(active_exception) == NULL) {
+        return MP_OBJ_SENTINEL;
+    } else {
+        return MP_OBJ_NULL;
+    }
+}
+
+STATIC mp_obj_t mp_native_get_exc(void) {
+    return MP_STATE_THREAD(active_exception);
+}
+
+STATIC void mp_native_clr_exc(void) {
+    MP_STATE_THREAD(active_exception) = NULL;
 }
 
 // wrapper that handles iterator buffer
@@ -171,12 +188,15 @@
         return mp_getiter(obj, NULL);
     } else {
         obj = mp_getiter(obj, iter);
+        if (obj == MP_OBJ_NULL) {
+            return MP_OBJ_NULL;
+        }
         if (obj != MP_OBJ_FROM_PTR(iter)) {
             // Iterator didn't use the stack so indicate that with MP_OBJ_NULL.
             iter->base.type = MP_OBJ_NULL;
             iter->buf[0] = obj;
         }
-        return NULL;
+        return MP_OBJ_SENTINEL;
     }
 }
 
@@ -192,19 +212,11 @@
 }
 
 STATIC bool mp_native_yield_from(mp_obj_t gen, mp_obj_t send_value, mp_obj_t *ret_value) {
-    mp_vm_return_kind_t ret_kind;
-    nlr_buf_t nlr_buf;
     mp_obj_t throw_value = *ret_value;
-    if (nlr_push(&nlr_buf) == 0) {
-        if (throw_value != MP_OBJ_NULL) {
-            send_value = MP_OBJ_NULL;
-        }
-        ret_kind = mp_resume(gen, send_value, throw_value, ret_value);
-        nlr_pop();
-    } else {
-        ret_kind = MP_VM_RETURN_EXCEPTION;
-        *ret_value = nlr_buf.ret_val;
+    if (throw_value != MP_OBJ_NULL) {
+        send_value = MP_OBJ_NULL;
     }
+    mp_vm_return_kind_t ret_kind = mp_resume(gen, send_value, throw_value, ret_value);
 
     if (ret_kind == MP_VM_RETURN_YIELD) {
         return true;
@@ -215,16 +227,18 @@
     } else {
         assert(ret_kind == MP_VM_RETURN_EXCEPTION);
         if (!mp_obj_exception_match(*ret_value, MP_OBJ_FROM_PTR(&mp_type_StopIteration))) {
-            nlr_raise(*ret_value);
+            mp_raise_o(*ret_value);
+            return false; // caller must also check active_exception
         }
         *ret_value = mp_obj_exception_get_value(*ret_value);
     }
 
     if (throw_value != MP_OBJ_NULL && mp_obj_exception_match(throw_value, MP_OBJ_FROM_PTR(&mp_type_GeneratorExit))) {
-        nlr_raise(mp_make_raise_obj(throw_value));
+        mp_raise_o(mp_make_raise_obj(throw_value));
+        return false; // caller must also check active_exception
     }
 
-    return false;
+    return false; // caller must also check active_exception (should be NULL)
 }
 
 #if MICROPY_PY_BUILTINS_FLOAT
@@ -310,6 +324,9 @@
     #endif
     nlr_pop,
     mp_native_raise,
+    mp_native_is_exc,
+    mp_native_get_exc,
+    mp_native_clr_exc,
     mp_import_name,
     mp_import_from,
     mp_import_all,
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/nlr.h	2020-05-01 00:05:34.696250814 +0200
+++ micropython-master-no_nlr/py/nlr.h	2020-04-30 23:32:39.428155708 +0200
@@ -119,6 +119,7 @@
 
 // Helper macro to use at the start of a specific nlr_jump implementation
 #define MP_NLR_JUMP_HEAD(val, top) \
+    nlr_jump_fail(val); \
     nlr_buf_t **_top_ptr = &MP_STATE_THREAD(nlr_top); \
     nlr_buf_t *top = *_top_ptr; \
     if (top == NULL) { \
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objarray.c	2020-05-01 00:05:34.696250814 +0200
+++ micropython-master-no_nlr/py/objarray.c	2020-05-01 00:28:35.299028045 +0200
@@ -95,7 +95,13 @@
 #if MICROPY_PY_BUILTINS_BYTEARRAY || MICROPY_PY_ARRAY
 STATIC mp_obj_array_t *array_new(char typecode, size_t n) {
     int typecode_size = mp_binary_get_size('@', typecode, NULL);
+    if (typecode_size == 0) {
+        return NULL;
+    }
     mp_obj_array_t *o = m_new_obj(mp_obj_array_t);
+    if (o == NULL) {
+        return NULL;
+    }
     #if MICROPY_PY_BUILTINS_BYTEARRAY && MICROPY_PY_ARRAY
     o->base.type = (typecode == BYTEARRAY_TYPECODE) ? &mp_type_bytearray : &mp_type_array;
     #elif MICROPY_PY_BUILTINS_BYTEARRAY
@@ -112,6 +118,7 @@
 #endif
 
 #if MICROPY_PY_BUILTINS_BYTEARRAY || MICROPY_PY_ARRAY
+#include <stdio.h>
 STATIC mp_obj_t array_construct(char typecode, mp_obj_t initializer) {
     // bytearrays can be raw-initialised from anything with the buffer protocol
     // other arrays can only be raw-initialised from bytes and bytearray objects
@@ -127,6 +134,9 @@
         size_t sz = mp_binary_get_size('@', typecode, NULL);
         size_t len = bufinfo.len / sz;
         mp_obj_array_t *o = array_new(typecode, len);
+        if (o == NULL) {
+            return MP_OBJ_NULL;
+        }
         memcpy(o->items, bufinfo.buf, len * sz);
         return MP_OBJ_FROM_PTR(o);
     }
@@ -141,17 +151,23 @@
     }
 
     mp_obj_array_t *array = array_new(typecode, len);
+    if (array == NULL) {
+        return MP_OBJ_NULL;
+    }
 
     mp_obj_t iterable = mp_getiter(initializer, NULL);
     mp_obj_t item;
     size_t i = 0;
-    while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {
+    while ((item = mp_iternext2(iterable)) != MP_OBJ_NULL) {
         if (len == 0) {
             array_append(MP_OBJ_FROM_PTR(array), item);
         } else {
             mp_binary_set_val_array(typecode, array->items, i++, item);
         }
     }
+    if (mp_iternext_had_exc()) {
+        return MP_OBJ_NULL;
+    }
 
     return MP_OBJ_FROM_PTR(array);
 }
@@ -187,7 +203,13 @@
     } else if (mp_obj_is_int(args[0])) {
         // 1 arg, an integer: construct a blank bytearray of that length
         mp_uint_t len = mp_obj_get_int(args[0]);
+        if (MP_STATE_THREAD(active_exception) != NULL) {
+            return MP_OBJ_NULL;
+        }
         mp_obj_array_t *o = array_new(BYTEARRAY_TYPECODE, len);
+        if (o == NULL) {
+            return MP_OBJ_NULL;
+        }
         memset(o->items, 0, len);
         return MP_OBJ_FROM_PTR(o);
     } else {
@@ -201,6 +223,9 @@
 
 mp_obj_t mp_obj_new_memoryview(byte typecode, size_t nitems, void *items) {
     mp_obj_array_t *self = m_new_obj(mp_obj_array_t);
+    if (self == NULL) {
+        return MP_OBJ_NULL;
+    }
     self->base.type = &mp_type_memoryview;
     self->typecode = typecode;
     self->memview_offset = 0;
@@ -266,7 +291,9 @@
             mp_buffer_info_t lhs_bufinfo;
             mp_buffer_info_t rhs_bufinfo;
             array_get_buffer(lhs_in, &lhs_bufinfo, MP_BUFFER_READ);
-            mp_get_buffer_raise(rhs_in, &rhs_bufinfo, MP_BUFFER_READ);
+            if (!mp_get_buffer_raise(rhs_in, &rhs_bufinfo, MP_BUFFER_READ)) {
+                return MP_OBJ_NULL;
+            }
 
             size_t sz = mp_binary_get_size('@', lhs_bufinfo.typecode, NULL);
 
@@ -275,6 +302,9 @@
 
             // note: lhs->len is element count of lhs, lhs_bufinfo.len is byte count
             mp_obj_array_t *res = array_new(lhs_bufinfo.typecode, lhs->len + rhs_len);
+            if (res == NULL) {
+                return MP_OBJ_NULL;
+            }
             mp_seq_cat((byte *)res->items, lhs_bufinfo.buf, lhs_bufinfo.len, rhs_bufinfo.buf, rhs_len * sz, byte);
             return MP_OBJ_FROM_PTR(res);
         }
@@ -285,7 +315,9 @@
                 return MP_OBJ_NULL; // op not supported
             }
             #endif
-            array_extend(lhs_in, rhs_in);
+            if (array_extend(lhs_in, rhs_in) == MP_OBJ_NULL) {
+                return MP_OBJ_NULL;
+            }
             return lhs_in;
         }
 
@@ -306,7 +338,7 @@
 
             // Otherwise, can only look for a scalar numeric value in an array
             if (mp_obj_is_int(rhs_in) || mp_obj_is_float(rhs_in)) {
-                mp_raise_NotImplementedError(NULL);
+                return mp_raise_NotImplementedError_o(NULL);
             }
 
             return mp_const_false;
@@ -337,11 +369,18 @@
     if (self->free == 0) {
         size_t item_sz = mp_binary_get_size('@', self->typecode, NULL);
         // TODO: alloc policy
+        byte *new_items = m_renew(byte, self->items, item_sz * self->len, item_sz * (self->len + 8));
+        if (new_items == NULL) {
+            return MP_OBJ_NULL;
+        }
         self->free = 8;
-        self->items = m_renew(byte, self->items, item_sz * self->len, item_sz * (self->len + self->free));
+        self->items = new_items;
         mp_seq_clear(self->items, self->len + 1, self->len + self->free, item_sz);
     }
     mp_binary_set_val_array(self->typecode, self->items, self->len, arg);
+    if (MP_STATE_THREAD(active_exception) != NULL) {
+        return MP_OBJ_NULL;
+    }
     // only update length/free if set succeeded
     self->len++;
     self->free--;
@@ -367,7 +406,11 @@
     // make sure we have enough room to extend
     // TODO: alloc policy; at the moment we go conservative
     if (self->free < len) {
-        self->items = m_renew(byte, self->items, (self->len + self->free) * sz, (self->len + len) * sz);
+        byte *new_items = m_renew(byte, self->items, (self->len + self->free) * sz, (self->len + len) * sz);
+        if (new_items == NULL) {
+            return MP_OBJ_NULL;
+        }
+        self->items = new_items;
         self->free = 0;
     } else {
         self->free -= len;
@@ -395,7 +438,7 @@
         if (mp_obj_is_type(index_in, &mp_type_slice)) {
             mp_bound_slice_t slice;
             if (!mp_seq_get_fast_slice_indexes(o->len, index_in, &slice)) {
-                mp_raise_NotImplementedError("only slices with step=1 (aka None) are supported");
+                return mp_raise_NotImplementedError_o("only slices with step=1 (aka None) are supported");
             }
             if (value != MP_OBJ_SENTINEL) {
                 #if MICROPY_PY_ARRAY_SLICE_ASSIGN
@@ -408,7 +451,7 @@
                     mp_obj_array_t *src_slice = MP_OBJ_TO_PTR(value);
                     if (item_sz != mp_binary_get_size('@', src_slice->typecode & TYPECODE_MASK, NULL)) {
                     compat_error:
-                        mp_raise_ValueError("lhs and rhs should be compatible");
+                        return mp_raise_ValueError_o("lhs and rhs should be compatible");
                     }
                     src_len = src_slice->len;
                     src_items = src_slice->items;
@@ -426,7 +469,7 @@
                     src_len = bufinfo.len;
                     src_items = bufinfo.buf;
                 } else {
-                    mp_raise_NotImplementedError("array/bytes required on right side");
+                    return mp_raise_NotImplementedError_o("array/bytes required on right side");
                 }
 
                 // TODO: check src/dst compat
@@ -447,9 +490,12 @@
                 if (len_adj > 0) {
                     if (len_adj > o->free) {
                         // TODO: alloc policy; at the moment we go conservative
-                        o->items = m_renew(byte, o->items, (o->len + o->free) * item_sz, (o->len + len_adj) * item_sz);
+                        dest_items = m_renew(byte, o->items, (o->len + o->free) * item_sz, (o->len + len_adj) * item_sz);
+                        if (dest_items == NULL) {
+                            return MP_OBJ_NULL;
+                        }
+                        o->items = dest_items;
                         o->free = len_adj;
-                        dest_items = o->items;
                     }
                     mp_seq_replace_slice_grow_inplace(dest_items, o->len,
                         slice.start, slice.stop, src_items, src_len, len_adj, item_sz);
@@ -475,6 +521,9 @@
             #if MICROPY_PY_BUILTINS_MEMORYVIEW
             if (o->base.type == &mp_type_memoryview) {
                 res = m_new_obj(mp_obj_array_t);
+                if (res == NULL) {
+                    return MP_OBJ_NULL;
+                }
                 *res = *o;
                 res->memview_offset += slice.start;
                 res->len = slice.stop - slice.start;
@@ -482,13 +531,19 @@
             #endif
             {
                 res = array_new(o->typecode, slice.stop - slice.start);
+                if (res == NULL) {
+                    return MP_OBJ_NULL;
+                }
                 memcpy(res->items, (uint8_t *)o->items + slice.start * sz, (slice.stop - slice.start) * sz);
             }
             return MP_OBJ_FROM_PTR(res);
         } else
-        #endif
+#endif
         {
             size_t index = mp_get_index(o->base.type, o->len, index_in, false);
+            if (index == (size_t)-1) {
+                return MP_OBJ_NULL;
+            }
             #if MICROPY_PY_BUILTINS_MEMORYVIEW
             if (o->base.type == &mp_type_memoryview) {
                 index += o->memview_offset;
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/obj.c	2020-05-01 00:05:34.696250814 +0200
+++ micropython-master-no_nlr/py/obj.c	2020-05-01 00:27:19.086077414 +0200
@@ -101,7 +101,9 @@
 
 void mp_obj_print_helper(const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {
     // There can be data structures nested too deep, or just recursive
-    MP_STACK_CHECK();
+    if (MP_STACK_CHECK()) {
+        return;
+    }
     #ifndef NDEBUG
     if (o_in == MP_OBJ_NULL) {
         mp_print_str(print, "(nil)");
@@ -301,6 +303,9 @@
         return mp_obj_int_get_checked(arg);
     } else {
         mp_obj_t res = mp_unary_op(MP_UNARY_OP_INT, (mp_obj_t)arg);
+        if (res == MP_OBJ_NULL) {
+            return 0; // TODO caller should check for error
+        }
         return mp_obj_int_get_checked(res);
     }
 }
@@ -360,18 +365,19 @@
 
     if (!mp_obj_get_float_maybe(arg, &val)) {
         if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-            mp_raise_TypeError("can't convert to float");
+            mp_raise_TypeError_o("can't convert to float");
         } else {
-            mp_raise_msg_varg(&mp_type_TypeError,
-                "can't convert %s to float", mp_obj_get_type_str(arg));
+            mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                "can't convert %s to float", mp_obj_get_type_str(arg)));
         }
+        return 0;
     }
 
     return val;
 }
 
 #if MICROPY_PY_BUILTINS_COMPLEX
-void mp_obj_get_complex(mp_obj_t arg, mp_float_t *real, mp_float_t *imag) {
+int mp_obj_get_complex(mp_obj_t arg, mp_float_t *real, mp_float_t *imag) {
     if (arg == mp_const_false) {
         *real = 0;
         *imag = 0;
@@ -393,29 +399,34 @@
         mp_obj_complex_get(arg, real, imag);
     } else {
         if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-            mp_raise_TypeError("can't convert to complex");
+            mp_raise_TypeError_o("can't convert to complex");
         } else {
-            mp_raise_msg_varg(&mp_type_TypeError,
-                "can't convert %s to complex", mp_obj_get_type_str(arg));
+            mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                "can't convert %s to complex", mp_obj_get_type_str(arg)));
         }
+        return 1;
     }
+    return 0;
 }
 #endif
 #endif
 
 // note: returned value in *items may point to the interior of a GC block
-void mp_obj_get_array(mp_obj_t o, size_t *len, mp_obj_t **items) {
+int mp_obj_get_array(mp_obj_t o, size_t *len, mp_obj_t **items) {
     if (mp_obj_is_type(o, &mp_type_tuple)) {
         mp_obj_tuple_get(o, len, items);
+        return 0;
     } else if (mp_obj_is_type(o, &mp_type_list)) {
         mp_obj_list_get(o, len, items);
+        return 0;
     } else {
         if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-            mp_raise_TypeError("expected tuple/list");
+            mp_raise_TypeError_o("expected tuple/list");
         } else {
-            mp_raise_msg_varg(&mp_type_TypeError,
-                "object '%s' isn't a tuple or list", mp_obj_get_type_str(o));
+            mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                "object '%s' isn't a tuple or list", mp_obj_get_type_str(o)));
         }
+        return 1;
     }
 }
 
@@ -440,12 +451,13 @@
         i = MP_OBJ_SMALL_INT_VALUE(index);
     } else if (!mp_obj_get_int_maybe(index, &i)) {
         if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-            mp_raise_TypeError("indices must be integers");
+            mp_raise_TypeError_o("indices must be integers");
         } else {
-            mp_raise_msg_varg(&mp_type_TypeError,
+            mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
                 "%q indices must be integers, not %s",
-                type->name, mp_obj_get_type_str(index));
+                type->name, mp_obj_get_type_str(index)));
         }
+        return (size_t)-1;
     }
 
     if (i < 0) {
@@ -460,10 +472,12 @@
     } else {
         if (i < 0 || (mp_uint_t)i >= len) {
             if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-                mp_raise_msg(&mp_type_IndexError, "index out of range");
+                mp_raise_msg_o(&mp_type_IndexError, "index out of range");
             } else {
-                mp_raise_msg_varg(&mp_type_IndexError, "%q index out of range", type->name);
+                mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_IndexError,
+                    "%q index out of range", type->name));
             }
+            return (size_t)-1;
         }
     }
 
@@ -494,10 +508,10 @@
     mp_obj_t len = mp_obj_len_maybe(o_in);
     if (len == MP_OBJ_NULL) {
         if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-            mp_raise_TypeError("object has no len");
+            return mp_raise_TypeError_o("object has no len");
         } else {
-            mp_raise_msg_varg(&mp_type_TypeError,
-                "object of type '%s' has no len()", mp_obj_get_type_str(o_in));
+            return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                "object of type '%s' has no len()", mp_obj_get_type_str(o_in)));
         }
     } else {
         return len;
@@ -531,28 +545,32 @@
         if (ret != MP_OBJ_NULL) {
             return ret;
         }
+        // MP_OBJ_NULL return can mean either unsupported or exception
+        if (MP_STATE_THREAD(active_exception) != NULL) {
+            return MP_OBJ_NULL;
+        }
         // TODO: call base classes here?
     }
     if (value == MP_OBJ_NULL) {
         if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-            mp_raise_TypeError("object doesn't support item deletion");
+            return mp_raise_TypeError_o("object doesn't support item deletion");
         } else {
-            mp_raise_msg_varg(&mp_type_TypeError,
-                "'%s' object doesn't support item deletion", mp_obj_get_type_str(base));
+            return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                "'%s' object doesn't support item deletion", mp_obj_get_type_str(base)));
         }
     } else if (value == MP_OBJ_SENTINEL) {
         if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-            mp_raise_TypeError("object isn't subscriptable");
+            return mp_raise_TypeError_o("object isn't subscriptable");
         } else {
-            mp_raise_msg_varg(&mp_type_TypeError,
-                "'%s' object isn't subscriptable", mp_obj_get_type_str(base));
+            return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                "'%s' object isn't subscriptable", mp_obj_get_type_str(base)));
         }
     } else {
         if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-            mp_raise_TypeError("object doesn't support item assignment");
+            return mp_raise_TypeError_o("object doesn't support item assignment");
         } else {
-            mp_raise_msg_varg(&mp_type_TypeError,
-                "'%s' object doesn't support item assignment", mp_obj_get_type_str(base));
+            return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                "'%s' object doesn't support item assignment", mp_obj_get_type_str(base)));
         }
     }
 }
@@ -581,10 +599,12 @@
     return true;
 }
 
-void mp_get_buffer_raise(mp_obj_t obj, mp_buffer_info_t *bufinfo, mp_uint_t flags) {
+bool mp_get_buffer_raise(mp_obj_t obj, mp_buffer_info_t *bufinfo, mp_uint_t flags) {
     if (!mp_get_buffer(obj, bufinfo, flags)) {
-        mp_raise_TypeError("object with buffer protocol required");
+        mp_raise_TypeError_o("object with buffer protocol required");
+        return false;
     }
+    return true;
 }
 
 mp_obj_t mp_generic_unary_op(mp_unary_op_t op, mp_obj_t o_in) {
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objcomplex.c	2020-05-01 00:05:34.698250785 +0200
+++ micropython-master-no_nlr/py/objcomplex.c	2020-04-30 23:32:39.490154831 +0200
@@ -178,7 +178,9 @@
 
 mp_obj_t mp_obj_complex_binary_op(mp_binary_op_t op, mp_float_t lhs_real, mp_float_t lhs_imag, mp_obj_t rhs_in) {
     mp_float_t rhs_real, rhs_imag;
-    mp_obj_get_complex(rhs_in, &rhs_real, &rhs_imag); // can be any type, this function will convert to float (if possible)
+    if (mp_obj_get_complex(rhs_in, &rhs_real, &rhs_imag)) { // can be any type, this function will convert to float (if possible)
+        return MP_OBJ_NULL;
+    }
     switch (op) {
         case MP_BINARY_OP_ADD:
         case MP_BINARY_OP_INPLACE_ADD:
@@ -201,13 +203,13 @@
         }
         case MP_BINARY_OP_FLOOR_DIVIDE:
         case MP_BINARY_OP_INPLACE_FLOOR_DIVIDE:
-            mp_raise_TypeError("can't truncate-divide a complex number");
+            return mp_raise_TypeError_o("can't truncate-divide a complex number");
 
         case MP_BINARY_OP_TRUE_DIVIDE:
         case MP_BINARY_OP_INPLACE_TRUE_DIVIDE:
             if (rhs_imag == 0) {
                 if (rhs_real == 0) {
-                    mp_raise_msg(&mp_type_ZeroDivisionError, "complex divide by zero");
+                    return mp_raise_msg_o(&mp_type_ZeroDivisionError, "complex divide by zero");
                 }
                 lhs_real /= rhs_real;
                 lhs_imag /= rhs_real;
@@ -235,7 +237,7 @@
                 if (rhs_imag == 0 && rhs_real >= 0) {
                     lhs_real = (rhs_real == 0);
                 } else {
-                    mp_raise_msg(&mp_type_ZeroDivisionError, "0.0 to a complex power");
+                    return mp_raise_msg_o(&mp_type_ZeroDivisionError, "0.0 to a complex power");
                 }
             } else {
                 mp_float_t ln1 = MICROPY_FLOAT_C_FUN(log)(abs1);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objdeque.c	2020-05-01 00:05:34.698250785 +0200
+++ micropython-master-no_nlr/py/objdeque.c	2020-04-30 23:32:39.490154831 +0200
@@ -43,18 +43,20 @@
 } mp_obj_deque_t;
 
 STATIC mp_obj_t deque_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
-    mp_arg_check_num(n_args, n_kw, 2, 3, false);
+    if (mp_arg_check_num(n_args, n_kw, 2, 3, false)) {
+        return MP_OBJ_NULL;
+    }
 
     /* Initialization from existing sequence is not supported, so an empty
        tuple must be passed as such. */
     if (args[0] != mp_const_empty_tuple) {
-        mp_raise_ValueError(NULL);
+        return mp_raise_ValueError_o(NULL);
     }
 
     // Protect against -1 leading to zero-length allocation and bad array access
     mp_int_t maxlen = mp_obj_get_int(args[1]);
     if (maxlen < 0) {
-        mp_raise_ValueError(NULL);
+        return mp_raise_ValueError_o(NULL);
     }
 
     mp_obj_deque_t *o = m_new_obj(mp_obj_deque_t);
@@ -102,7 +104,7 @@
     }
 
     if (self->flags & FLAG_CHECK_OVERFLOW && new_i_put == self->i_get) {
-        mp_raise_msg(&mp_type_IndexError, "full");
+        return mp_raise_msg_o(&mp_type_IndexError, "full");
     }
 
     self->items[self->i_put] = arg;
@@ -122,7 +124,7 @@
     mp_obj_deque_t *self = MP_OBJ_TO_PTR(self_in);
 
     if (self->i_get == self->i_put) {
-        mp_raise_msg(&mp_type_IndexError, "empty");
+        return mp_raise_msg_o(&mp_type_IndexError, "empty");
     }
 
     mp_obj_t ret = self->items[self->i_get];
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objdict.c	2020-05-01 00:05:34.698250785 +0200
+++ micropython-master-no_nlr/py/objdict.c	2020-04-30 23:32:39.490154831 +0200
@@ -101,7 +101,9 @@
         mp_obj_t args2[2] = {dict_out, args[0]}; // args[0] is always valid, even if it's not a positional arg
         mp_map_t kwargs;
         mp_map_init_fixed_table(&kwargs, n_kw, args + n_args);
-        dict_update(n_args + 1, args2, &kwargs); // dict_update will check that n_args + 1 == 1 or 2
+        if (dict_update(n_args + 1, args2, &kwargs) == MP_OBJ_NULL) { // dict_update will check that n_args + 1 == 1 or 2
+            return MP_OBJ_NULL;
+        }
     }
     return dict_out;
 }
@@ -178,7 +180,7 @@
     mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);
     mp_map_elem_t *elem = mp_map_lookup(&self->map, index, MP_MAP_LOOKUP);
     if (elem == NULL) {
-        nlr_raise(mp_obj_new_exception_arg1(&mp_type_KeyError, index));
+        return mp_raise_o(mp_obj_new_exception_arg1(&mp_type_KeyError, index));
     } else {
         return elem->value;
     }
@@ -187,20 +189,24 @@
 STATIC mp_obj_t dict_subscr(mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {
     if (value == MP_OBJ_NULL) {
         // delete
-        mp_obj_dict_delete(self_in, index);
+        if (mp_obj_dict_delete(self_in, index) == MP_OBJ_NULL) {
+            return MP_OBJ_NULL;
+        }
         return mp_const_none;
     } else if (value == MP_OBJ_SENTINEL) {
         // load
         mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);
         mp_map_elem_t *elem = mp_map_lookup(&self->map, index, MP_MAP_LOOKUP);
         if (elem == NULL) {
-            nlr_raise(mp_obj_new_exception_arg1(&mp_type_KeyError, index));
+            return mp_raise_o(mp_obj_new_exception_arg1(&mp_type_KeyError, index));
         } else {
             return elem->value;
         }
     } else {
         // store
-        mp_obj_dict_store(self_in, index, value);
+        if (mp_obj_dict_store(self_in, index, value) == MP_OBJ_NULL) {
+            return MP_OBJ_NULL;
+        }
         return mp_const_none;
     }
 }
@@ -208,16 +214,20 @@
 /******************************************************************************/
 /* dict methods                                                               */
 
-STATIC void mp_ensure_not_fixed(const mp_obj_dict_t *dict) {
+STATIC int mp_ensure_not_fixed(const mp_obj_dict_t *dict) {
     if (dict->map.is_fixed) {
-        mp_raise_TypeError(NULL);
+        mp_raise_TypeError_o(NULL);
+        return 1;
     }
+    return 0;
 }
 
 STATIC mp_obj_t dict_clear(mp_obj_t self_in) {
     mp_check_self(mp_obj_is_dict_type(self_in));
     mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);
-    mp_ensure_not_fixed(self);
+    if (mp_ensure_not_fixed(self)) {
+        return MP_OBJ_NULL;
+    }
 
     mp_map_clear(&self->map);
 
@@ -276,14 +286,16 @@
     mp_check_self(mp_obj_is_dict_type(args[0]));
     mp_obj_dict_t *self = MP_OBJ_TO_PTR(args[0]);
     if (lookup_kind != MP_MAP_LOOKUP) {
-        mp_ensure_not_fixed(self);
+        if (mp_ensure_not_fixed(self)) {
+            return MP_OBJ_NULL;
+        }
     }
     mp_map_elem_t *elem = mp_map_lookup(&self->map, args[1], lookup_kind);
     mp_obj_t value;
     if (elem == NULL || elem->value == MP_OBJ_NULL) {
         if (n_args == 2) {
             if (lookup_kind == MP_MAP_LOOKUP_REMOVE_IF_FOUND) {
-                nlr_raise(mp_obj_new_exception_arg1(&mp_type_KeyError, args[1]));
+                return mp_raise_o(mp_obj_new_exception_arg1(&mp_type_KeyError, args[1]));
             } else {
                 value = mp_const_none;
             }
@@ -320,11 +332,13 @@
 STATIC mp_obj_t dict_popitem(mp_obj_t self_in) {
     mp_check_self(mp_obj_is_dict_type(self_in));
     mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);
-    mp_ensure_not_fixed(self);
+    if (mp_ensure_not_fixed(self)) {
+        return MP_OBJ_NULL;
+    }
     size_t cur = 0;
     mp_map_elem_t *next = dict_iter_next(self, &cur);
     if (next == NULL) {
-        mp_raise_msg(&mp_type_KeyError, "popitem(): dictionary is empty");
+        return mp_raise_msg_o(&mp_type_KeyError, "popitem(): dictionary is empty");
     }
     self->map.used--;
     mp_obj_t items[] = {next->key, next->value};
@@ -339,9 +353,13 @@
 STATIC mp_obj_t dict_update(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {
     mp_check_self(mp_obj_is_dict_type(args[0]));
     mp_obj_dict_t *self = MP_OBJ_TO_PTR(args[0]);
-    mp_ensure_not_fixed(self);
+    if (mp_ensure_not_fixed(self)) {
+        return MP_OBJ_NULL;
+    }
 
-    mp_arg_check_num(n_args, kwargs->used, 1, 2, true);
+    if (mp_arg_check_num(n_args, kwargs->used, 1, 2, true)) {
+        return MP_OBJ_NULL;
+    }
 
     if (n_args == 2) {
         // given a positional argument
@@ -367,7 +385,7 @@
                 if (key == MP_OBJ_STOP_ITERATION
                     || value == MP_OBJ_STOP_ITERATION
                     || stop != MP_OBJ_STOP_ITERATION) {
-                    mp_raise_ValueError("dict update sequence has wrong length");
+                    return mp_raise_ValueError_o("dict update sequence has wrong length");
                 } else {
                     mp_map_lookup(&self->map, key, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)->value = value;
                 }
@@ -497,6 +515,9 @@
 
 STATIC mp_obj_t mp_obj_new_dict_view(mp_obj_t dict, mp_dict_view_kind_t kind) {
     mp_obj_dict_view_t *o = m_new_obj(mp_obj_dict_view_t);
+    if (o == NULL) {
+        return MP_OBJ_NULL;
+    }
     o->base.type = &dict_view_type;
     o->dict = dict;
     o->kind = kind;
@@ -595,6 +616,9 @@
 
 mp_obj_t mp_obj_new_dict(size_t n_args) {
     mp_obj_dict_t *o = m_new_obj(mp_obj_dict_t);
+    if (o == NULL) {
+        return MP_OBJ_NULL;
+    }
     mp_obj_dict_init(o, n_args);
     return MP_OBJ_FROM_PTR(o);
 }
@@ -607,13 +631,22 @@
 mp_obj_t mp_obj_dict_store(mp_obj_t self_in, mp_obj_t key, mp_obj_t value) {
     mp_check_self(mp_obj_is_dict_type(self_in));
     mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);
-    mp_ensure_not_fixed(self);
-    mp_map_lookup(&self->map, key, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)->value = value;
+    if (mp_ensure_not_fixed(self)) {
+        return MP_OBJ_NULL;
+    }
+    mp_map_elem_t *elem = mp_map_lookup(&self->map, key, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);
+    if (elem == NULL) {
+        // exception
+        return MP_OBJ_NULL;
+    }
+    elem->value = value;
     return self_in;
 }
 
 mp_obj_t mp_obj_dict_delete(mp_obj_t self_in, mp_obj_t key) {
     mp_obj_t args[2] = {self_in, key};
-    dict_get_helper(2, args, MP_MAP_LOOKUP_REMOVE_IF_FOUND);
+    if (dict_get_helper(2, args, MP_MAP_LOOKUP_REMOVE_IF_FOUND) == MP_OBJ_NULL) {
+        return MP_OBJ_NULL;
+    }
     return self_in;
 }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objenumerate.c	2020-05-01 00:05:34.698250785 +0200
+++ micropython-master-no_nlr/py/objenumerate.c	2020-05-01 00:29:14.150512391 +0200
@@ -50,8 +50,10 @@
     struct {
         mp_arg_val_t iterable, start;
     } arg_vals;
-    mp_arg_parse_all_kw_array(n_args, n_kw, args,
-        MP_ARRAY_SIZE(allowed_args), allowed_args, (mp_arg_val_t *)&arg_vals);
+    if (mp_arg_parse_all_kw_array(n_args, n_kw, args,
+        MP_ARRAY_SIZE(allowed_args), allowed_args, (mp_arg_val_t *)&arg_vals)) {
+        return MP_OBJ_NULL;
+    }
 
     // create enumerate object
     mp_obj_enumerate_t *o = m_new_obj(mp_obj_enumerate_t);
@@ -81,6 +83,9 @@
     assert(mp_obj_is_type(self_in, &mp_type_enumerate));
     mp_obj_enumerate_t *self = MP_OBJ_TO_PTR(self_in);
     mp_obj_t next = mp_iternext(self->iter);
+    if (next == MP_OBJ_NULL) {
+        return MP_OBJ_NULL;
+    }
     if (next == MP_OBJ_STOP_ITERATION) {
         return MP_OBJ_STOP_ITERATION;
     } else {
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objfilter.c	2020-04-17 09:19:09.278299486 +0200
+++ micropython-master-no_nlr/py/objfilter.c	2020-04-17 12:45:36.379619961 +0200
@@ -47,7 +47,7 @@
     mp_check_self(mp_obj_is_type(self_in, &mp_type_filter));
     mp_obj_filter_t *self = MP_OBJ_TO_PTR(self_in);
     mp_obj_t next;
-    while ((next = mp_iternext(self->iter)) != MP_OBJ_STOP_ITERATION) {
+    while ((next = mp_iternext2(self->iter)) != MP_OBJ_NULL) {
         mp_obj_t val;
         if (self->fun != mp_const_none) {
             val = mp_call_function_n_kw(self->fun, 1, 0, &next);
@@ -58,6 +58,9 @@
             return next;
         }
     }
+    if (mp_iternext_had_exc()) {
+        return MP_OBJ_NULL;
+    }
     return MP_OBJ_STOP_ITERATION;
 }
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objfloat.c	2020-05-01 00:05:34.698250785 +0200
+++ micropython-master-no_nlr/py/objfloat.c	2020-05-01 00:30:28.661521801 +0200
@@ -116,7 +116,9 @@
 
 STATIC mp_obj_t float_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
     (void)type_in;
-    mp_arg_check_num(n_args, n_kw, 0, 1, false);
+    if (mp_arg_check_num(n_args, n_kw, 0, 1, false)) {
+        return MP_OBJ_NULL;
+    }
 
     switch (n_args) {
         case 0:
@@ -133,7 +135,11 @@
                 return args[0];
             } else {
                 // something else, try to cast it to a float
-                return mp_obj_new_float(mp_obj_get_float(args[0]));
+                mp_float_t val = mp_obj_get_float(args[0]);
+                if (MP_STATE_THREAD(active_exception) != NULL) {
+                    return MP_OBJ_NULL;
+                }
+                return mp_obj_new_float(val);
             }
         }
     }
@@ -243,21 +249,18 @@
     switch (op) {
         case MP_BINARY_OP_ADD:
         case MP_BINARY_OP_INPLACE_ADD:
-            lhs_val += rhs_val;
-            break;
+            lhs_val += rhs_val; break;
         case MP_BINARY_OP_SUBTRACT:
         case MP_BINARY_OP_INPLACE_SUBTRACT:
-            lhs_val -= rhs_val;
-            break;
+            lhs_val -= rhs_val; break;
         case MP_BINARY_OP_MULTIPLY:
         case MP_BINARY_OP_INPLACE_MULTIPLY:
-            lhs_val *= rhs_val;
-            break;
+            lhs_val *= rhs_val; break;
         case MP_BINARY_OP_FLOOR_DIVIDE:
         case MP_BINARY_OP_INPLACE_FLOOR_DIVIDE:
             if (rhs_val == 0) {
-            zero_division_error:
-                mp_raise_msg(&mp_type_ZeroDivisionError, "divide by zero");
+zero_division_error:
+                return mp_raise_msg_o(&mp_type_ZeroDivisionError, "divide by zero");
             }
             // Python specs require that x == (x//y)*y + (x%y) so we must
             // call divmod to compute the correct floor division, which
@@ -295,7 +298,7 @@
                 #if MICROPY_PY_BUILTINS_COMPLEX
                 return mp_obj_complex_binary_op(MP_BINARY_OP_POWER, lhs_val, 0, rhs_in);
                 #else
-                mp_raise_ValueError("complex values not supported");
+                return mp_raise_ValueError_o("complex values not supported");
                 #endif
             }
             lhs_val = MICROPY_FLOAT_C_FUN(pow)(lhs_val, rhs_val);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objfun.c	2020-05-01 00:56:48.648186005 +0200
+++ micropython-master-no_nlr/py/objfun.c	2020-05-01 00:54:49.259810163 +0200
@@ -52,7 +52,9 @@
     (void)args;
     assert(mp_obj_is_type(self_in, &mp_type_fun_builtin_0));
     mp_obj_fun_builtin_fixed_t *self = MP_OBJ_TO_PTR(self_in);
-    mp_arg_check_num(n_args, n_kw, 0, 0, false);
+    if (mp_arg_check_num(n_args, n_kw, 0, 0, false)) {
+        return MP_OBJ_NULL;
+    }
     return self->fun._0();
 }
 
@@ -66,7 +68,9 @@
 STATIC mp_obj_t fun_builtin_1_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
     assert(mp_obj_is_type(self_in, &mp_type_fun_builtin_1));
     mp_obj_fun_builtin_fixed_t *self = MP_OBJ_TO_PTR(self_in);
-    mp_arg_check_num(n_args, n_kw, 1, 1, false);
+    if (mp_arg_check_num(n_args, n_kw, 1, 1, false)) {
+        return MP_OBJ_NULL;
+    }
     return self->fun._1(args[0]);
 }
 
@@ -80,7 +84,9 @@
 STATIC mp_obj_t fun_builtin_2_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
     assert(mp_obj_is_type(self_in, &mp_type_fun_builtin_2));
     mp_obj_fun_builtin_fixed_t *self = MP_OBJ_TO_PTR(self_in);
-    mp_arg_check_num(n_args, n_kw, 2, 2, false);
+    if (mp_arg_check_num(n_args, n_kw, 2, 2, false)) {
+        return MP_OBJ_NULL;
+    }
     return self->fun._2(args[0], args[1]);
 }
 
@@ -94,7 +100,9 @@
 STATIC mp_obj_t fun_builtin_3_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
     assert(mp_obj_is_type(self_in, &mp_type_fun_builtin_3));
     mp_obj_fun_builtin_fixed_t *self = MP_OBJ_TO_PTR(self_in);
-    mp_arg_check_num(n_args, n_kw, 3, 3, false);
+    if (mp_arg_check_num(n_args, n_kw, 3, 3, false)) {
+        return MP_OBJ_NULL;
+    }
     return self->fun._3(args[0], args[1], args[2]);
 }
 
@@ -110,7 +118,9 @@
     mp_obj_fun_builtin_var_t *self = MP_OBJ_TO_PTR(self_in);
 
     // check number of arguments
-    mp_arg_check_num_sig(n_args, n_kw, self->sig);
+    if (mp_arg_check_num_sig(n_args, n_kw, self->sig)) {
+        return MP_OBJ_NULL;
+    }
 
     if (self->sig & 1) {
         // function allows keywords
@@ -201,16 +211,21 @@
             + n_exc_stack *sizeof(mp_exc_stack_t);                \
     }
 
-#define INIT_CODESTATE(code_state, _fun_bc, _n_state, n_args, n_kw, args) \
+static inline mp_obj_t INIT_CODESTATE(mp_code_state_t *code_state, mp_obj_fun_bc_t *_fun_bc, size_t _n_state, size_t n_args, size_t n_kw, const mp_obj_t *args) {
     code_state->fun_bc = _fun_bc; \
     code_state->ip = 0; \
     code_state->n_state = _n_state; \
-    mp_setup_code_state(code_state, n_args, n_kw, args); \
+    // TODO can we save old_globals before this call?
+    mp_obj_t ret = mp_setup_code_state(code_state, n_args, n_kw, args); \
     code_state->old_globals = mp_globals_get();
+    return ret;
+}
 
 #if MICROPY_STACKLESS
 mp_code_state_t *mp_obj_fun_bc_prepare_codestate(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
-    MP_STACK_CHECK();
+    if (MP_STACK_CHECK()) {
+        return NULL;
+    }
     mp_obj_fun_bc_t *self = MP_OBJ_TO_PTR(self_in);
 
     size_t n_state, state_size;
@@ -231,7 +246,16 @@
     }
     #endif
 
-    INIT_CODESTATE(code_state, self, n_state, n_args, n_kw, args);
+    // TODO write test where this fails
+    if (INIT_CODESTATE(code_state, self, n_state, n_args, n_kw, args) == MP_OBJ_NULL) {
+        #if MICROPY_ENABLE_PYSTACK
+        mp_nonlocal_free(code_state, sizeof(mp_code_state_t));
+        #else
+        m_del_var(mp_code_state_t, byte, state_size, code_state);
+        #endif
+        // exception
+        return NULL;
+    }
 
     // execute the byte code with the correct globals context
     mp_globals_set(self->globals);
@@ -241,7 +265,9 @@
 #endif
 
 STATIC mp_obj_t fun_bc_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
-    MP_STACK_CHECK();
+    if (MP_STACK_CHECK()) {
+        return MP_OBJ_NULL;
+    }
 
     DEBUG_printf("Input n_args: " UINT_FMT ", n_kw: " UINT_FMT "\n", n_args, n_kw);
     DEBUG_printf("Input pos args: ");
@@ -276,7 +302,18 @@
     }
     #endif
 
-    INIT_CODESTATE(code_state, self, n_state, n_args, n_kw, args);
+    if (INIT_CODESTATE(code_state, self, n_state, n_args, n_kw, args) == MP_OBJ_NULL) {
+        // exception
+        #if MICROPY_ENABLE_PYSTACK
+        mp_pystack_free(code_state);
+        #else
+        // free the state if it was allocated on the heap
+        if (state_size != 0) {
+            m_del_var(mp_code_state_t, byte, state_size, code_state);
+        }
+        #endif
+        return MP_OBJ_NULL;
+    }
 
     // execute the byte code with the correct globals context
     mp_globals_set(self->globals);
@@ -337,7 +374,7 @@
     if (vm_return_kind == MP_VM_RETURN_NORMAL) {
         return result;
     } else { // MP_VM_RETURN_EXCEPTION
-        nlr_raise(result);
+        return mp_raise_o(result);
     }
 }
 
@@ -379,6 +416,9 @@
         n_extra_args += 1;
     }
     mp_obj_fun_bc_t *o = m_new_obj_var(mp_obj_fun_bc_t, mp_obj_t, n_extra_args);
+    if (o == NULL) {
+        return MP_OBJ_NULL;
+    }
     o->base.type = &mp_type_fun_bc;
     o->globals = mp_globals_get();
     o->bytecode = code;
@@ -398,7 +438,9 @@
 #if MICROPY_EMIT_NATIVE
 
 STATIC mp_obj_t fun_native_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
-    MP_STACK_CHECK();
+    if (MP_STACK_CHECK()) {
+        return MP_OBJ_NULL;
+    }
     mp_obj_fun_bc_t *self = self_in;
     mp_call_fun_t fun = MICROPY_MAKE_POINTER_CALLABLE((void *)self->bytecode);
     return fun(self_in, n_args, n_kw, args);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objgenerator.c	2020-05-01 00:05:34.698250785 +0200
+++ micropython-master-no_nlr/py/objgenerator.c	2020-04-30 23:32:39.492154802 +0200
@@ -67,6 +67,7 @@
     o->code_state.fun_bc = self_fun;
     o->code_state.ip = 0;
     o->code_state.n_state = n_state;
+    // TODO write test where this call fails
     mp_setup_code_state(&o->code_state, n_args, n_kw, args);
     return MP_OBJ_FROM_PTR(o);
 }
@@ -112,6 +113,7 @@
     o->code_state.fun_bc = self_fun;
     o->code_state.ip = (const byte *)prelude_offset;
     o->code_state.n_state = n_state;
+    // TODO write test where this call fails
     mp_setup_code_state(&o->code_state, n_args, n_kw, args);
 
     // Indicate we are a native function, which doesn't use this variable
@@ -146,7 +148,11 @@
 }
 
 mp_vm_return_kind_t mp_obj_gen_resume(mp_obj_t self_in, mp_obj_t send_value, mp_obj_t throw_value, mp_obj_t *ret_val) {
-    MP_STACK_CHECK();
+    if (MP_STACK_CHECK()) {
+        *ret_val = MP_OBJ_FROM_PTR(MP_STATE_THREAD(active_exception));
+        MP_STATE_THREAD(active_exception) = NULL;
+        return MP_VM_RETURN_EXCEPTION;
+    }
     mp_check_self(mp_obj_is_type(self_in, &mp_type_gen_instance));
     mp_obj_gen_instance_t *self = MP_OBJ_TO_PTR(self_in);
     if (self->code_state.ip == 0) {
@@ -157,7 +163,11 @@
 
     // Ensure the generator cannot be reentered during execution
     if (self->pend_exc == MP_OBJ_NULL) {
-        mp_raise_ValueError("generator already executing");
+        //mp_raise_ValueError("generator already executing");
+        mp_raise_ValueError_o("generator already executing");
+        *ret_val = MP_OBJ_FROM_PTR(MP_STATE_THREAD(active_exception));
+        MP_STATE_THREAD(active_exception) = NULL;
+        return MP_VM_RETURN_EXCEPTION;
     }
 
     #if MICROPY_PY_GENERATOR_PEND_THROW
@@ -170,7 +180,10 @@
     // If the generator is started, allow sending a value.
     if (self->code_state.sp == self->code_state.state - 1) {
         if (send_value != mp_const_none) {
-            mp_raise_TypeError("can't send non-None value to a just-started generator");
+            mp_raise_TypeError_o("can't send non-None value to a just-started generator");
+            *ret_val = MP_OBJ_FROM_PTR(MP_STATE_THREAD(active_exception));
+            MP_STATE_THREAD(active_exception) = NULL;
+            return MP_VM_RETURN_EXCEPTION;
         }
     } else {
         *self->code_state.sp = send_value;
@@ -222,7 +235,16 @@
 
         case MP_VM_RETURN_EXCEPTION: {
             self->code_state.ip = 0;
+            // TODO probably makes sense to have bytecode also place exception in active_exception
+            #if MICROPY_EMIT_NATIVE
+            if (self->code_state.exc_sp_idx == MP_CODE_STATE_EXC_SP_IDX_SENTINEL) {
+                *ret_val = MP_STATE_THREAD(active_exception);
+                MP_STATE_THREAD(active_exception) = NULL; // clear it
+            } else
+            #endif
+            {
             *ret_val = self->code_state.state[0];
+            }
             // PEP479: if StopIteration is raised inside a generator it is replaced with RuntimeError
             if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(mp_obj_get_type(*ret_val)), MP_OBJ_FROM_PTR(&mp_type_StopIteration))) {
                 *ret_val = mp_obj_new_exception_msg(&mp_type_RuntimeError, "generator raised StopIteration");
@@ -243,14 +265,15 @@
             if (ret == mp_const_none || ret == MP_OBJ_STOP_ITERATION) {
                 return MP_OBJ_STOP_ITERATION;
             } else {
-                nlr_raise(mp_obj_new_exception_arg1(&mp_type_StopIteration, ret));
+                //mp_raise_type(&mp_type_StopIteration);
+                return mp_raise_o(mp_obj_new_exception_args(&mp_type_StopIteration, 1, &ret));
             }
 
         case MP_VM_RETURN_YIELD:
             return ret;
 
         case MP_VM_RETURN_EXCEPTION:
-            nlr_raise(ret);
+            return mp_raise_o(ret);
     }
 }
 
@@ -261,7 +284,8 @@
 STATIC mp_obj_t gen_instance_send(mp_obj_t self_in, mp_obj_t send_value) {
     mp_obj_t ret = gen_resume_and_raise(self_in, send_value, MP_OBJ_NULL);
     if (ret == MP_OBJ_STOP_ITERATION) {
-        mp_raise_type(&mp_type_StopIteration);
+        //mp_raise_type(&mp_type_StopIteration);
+        return mp_raise_o(mp_obj_new_exception(&mp_type_StopIteration));
     } else {
         return ret;
     }
@@ -288,7 +312,7 @@
 
     mp_obj_t ret = gen_resume_and_raise(args[0], mp_const_none, exc);
     if (ret == MP_OBJ_STOP_ITERATION) {
-        mp_raise_type(&mp_type_StopIteration);
+        return mp_raise_o(mp_obj_new_exception(&mp_type_StopIteration));
     } else {
         return ret;
     }
@@ -299,7 +323,7 @@
     mp_obj_t ret;
     switch (mp_obj_gen_resume(self_in, mp_const_none, MP_OBJ_FROM_PTR(&mp_const_GeneratorExit_obj), &ret)) {
         case MP_VM_RETURN_YIELD:
-            mp_raise_msg(&mp_type_RuntimeError, "generator ignored GeneratorExit");
+            return mp_raise_msg_o(&mp_type_RuntimeError, "generator ignored GeneratorExit");
 
         // Swallow GeneratorExit (== successful close), and re-raise any other
         case MP_VM_RETURN_EXCEPTION:
@@ -307,7 +331,7 @@
             if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(mp_obj_get_type(ret)), MP_OBJ_FROM_PTR(&mp_type_GeneratorExit))) {
                 return mp_const_none;
             }
-            nlr_raise(ret);
+            return mp_raise_o(ret);
 
         default:
             // The only choice left is MP_VM_RETURN_NORMAL which is successful close
@@ -320,7 +344,9 @@
 STATIC mp_obj_t gen_instance_pend_throw(mp_obj_t self_in, mp_obj_t exc_in) {
     mp_obj_gen_instance_t *self = MP_OBJ_TO_PTR(self_in);
     if (self->pend_exc == MP_OBJ_NULL) {
-        mp_raise_ValueError("generator already executing");
+        //mp_raise_ValueError("generator already executing");
+#pragma message "TODO: ValueError or TypeError ?"
+        return mp_raise_TypeError_o("can't pend throw to just-started generator");
     }
     mp_obj_t prev = self->pend_exc;
     self->pend_exc = exc_in;
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objgetitemiter.c	2020-05-01 00:05:34.698250785 +0200
+++ micropython-master-no_nlr/py/objgetitemiter.c	2020-05-01 00:31:04.275047589 +0200
@@ -37,24 +37,22 @@
 
 STATIC mp_obj_t it_iternext(mp_obj_t self_in) {
     mp_obj_getitem_iter_t *self = MP_OBJ_TO_PTR(self_in);
-    nlr_buf_t nlr;
-    if (nlr_push(&nlr) == 0) {
-        // try to get next item
-        mp_obj_t value = mp_call_method_n_kw(1, 0, self->args);
-        self->args[2] = MP_OBJ_NEW_SMALL_INT(MP_OBJ_SMALL_INT_VALUE(self->args[2]) + 1);
-        nlr_pop();
-        return value;
-    } else {
+    // try to get next item
+    mp_obj_t value = mp_call_method_n_kw(1, 0, self->args);
+    if (value == MP_OBJ_NULL) {
         // an exception was raised
-        mp_obj_type_t *t = (mp_obj_type_t *)((mp_obj_base_t *)nlr.ret_val)->type;
+        mp_obj_type_t *t = (mp_obj_type_t *)MP_STATE_THREAD(active_exception)->type;
         if (t == &mp_type_StopIteration || t == &mp_type_IndexError) {
             // return MP_OBJ_STOP_ITERATION instead of raising
+            MP_STATE_THREAD(active_exception) = NULL;
             return MP_OBJ_STOP_ITERATION;
         } else {
             // re-raise exception
-            nlr_jump(nlr.ret_val);
+            return MP_OBJ_NULL;
         }
     }
+    self->args[2] = MP_OBJ_NEW_SMALL_INT(MP_OBJ_SMALL_INT_VALUE(self->args[2]) + 1);
+    return value;
 }
 
 STATIC const mp_obj_type_t it_type = {
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/obj.h	2020-05-01 00:05:34.696250814 +0200
+++ micropython-master-no_nlr/py/obj.h	2020-04-30 23:32:39.490154831 +0200
@@ -516,7 +516,7 @@
     mp_int_t (*get_buffer)(mp_obj_t obj, mp_buffer_info_t *bufinfo, mp_uint_t flags);
 } mp_buffer_p_t;
 bool mp_get_buffer(mp_obj_t obj, mp_buffer_info_t *bufinfo, mp_uint_t flags);
-void mp_get_buffer_raise(mp_obj_t obj, mp_buffer_info_t *bufinfo, mp_uint_t flags);
+bool mp_get_buffer_raise(mp_obj_t obj, mp_buffer_info_t *bufinfo, mp_uint_t flags);
 
 struct _mp_obj_type_t {
     // A type is an object so must start with this entry, which points to mp_type_type.
@@ -774,9 +774,9 @@
 #if MICROPY_PY_BUILTINS_FLOAT
 mp_float_t mp_obj_get_float(mp_obj_t self_in);
 bool mp_obj_get_float_maybe(mp_obj_t arg, mp_float_t *value);
-void mp_obj_get_complex(mp_obj_t self_in, mp_float_t *real, mp_float_t *imag);
+int mp_obj_get_complex(mp_obj_t self_in, mp_float_t *real, mp_float_t *imag);
 #endif
-void mp_obj_get_array(mp_obj_t o, size_t *len, mp_obj_t **items); // *items may point inside a GC block
+int mp_obj_get_array(mp_obj_t o, size_t *len, mp_obj_t **items); // *items may point inside a GC block
 void mp_obj_get_array_fixed_n(mp_obj_t o, size_t len, mp_obj_t **items); // *items may point inside a GC block
 size_t mp_get_index(const mp_obj_type_t *type, size_t len, mp_obj_t index, bool is_slice);
 mp_obj_t mp_obj_id(mp_obj_t o_in);
@@ -940,7 +940,7 @@
 
 void mp_seq_multiply(const void *items, size_t item_sz, size_t len, size_t times, void *dest);
 #if MICROPY_PY_BUILTINS_SLICE
-bool mp_seq_get_fast_slice_indexes(mp_uint_t len, mp_obj_t slice, mp_bound_slice_t *indexes);
+int mp_seq_get_fast_slice_indexes(mp_uint_t len, mp_obj_t slice, mp_bound_slice_t *indexes);
 #endif
 #define mp_seq_copy(dest, src, len, item_t) memcpy(dest, src, len * sizeof(item_t))
 #define mp_seq_cat(dest, src1, len1, src2, len2, item_t) { memcpy(dest, src1, (len1) * sizeof(item_t)); memcpy(dest + (len1), src2, (len2) * sizeof(item_t)); }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objint.c	2020-05-01 00:05:34.698250785 +0200
+++ micropython-master-no_nlr/py/objint.c	2020-04-30 23:32:39.492154802 +0200
@@ -137,9 +137,12 @@
 mp_obj_t mp_obj_new_int_from_float(mp_float_t val) {
     int cl = fpclassify(val);
     if (cl == FP_INFINITE) {
-        mp_raise_msg(&mp_type_OverflowError, "can't convert inf to int");
+        //mp_raise_msg(&mp_type_OverflowError, "can't convert inf to int");
+#pragma message "TODO: remove obj creation"
+        return mp_raise_o(mp_obj_new_exception_msg(&mp_type_OverflowError, "can't convert inf to int"));
     } else if (cl == FP_NAN) {
-        mp_raise_ValueError("can't convert NaN to int");
+        //mp_raise_ValueError("can't convert NaN to int");
+        return mp_raise_ValueError_o("can't convert NaN to int");
     } else {
         mp_fp_as_int_class_t icl = mp_classify_fp_as_int(val);
         if (icl == MP_FP_CLASS_FIT_SMALLINT) {
@@ -156,7 +159,7 @@
             return mp_obj_new_int_from_ll((long long)val);
         #endif
         } else {
-            mp_raise_ValueError("float too big");
+            return mp_raise_ValueError_o("float too big");
         }
         #endif
     }
@@ -321,20 +324,17 @@
 
 // This is called only with strings whose value doesn't fit in SMALL_INT
 mp_obj_t mp_obj_new_int_from_str_len(const char **str, size_t len, bool neg, unsigned int base) {
-    mp_raise_msg(&mp_type_OverflowError, "long int not supported in this build");
-    return mp_const_none;
+    return mp_raise_msg_o(&mp_type_OverflowError, "long int not supported in this build");
 }
 
 // This is called when an integer larger than a SMALL_INT is needed (although val might still fit in a SMALL_INT)
 mp_obj_t mp_obj_new_int_from_ll(long long val) {
-    mp_raise_msg(&mp_type_OverflowError, "small int overflow");
-    return mp_const_none;
+    return mp_raise_msg_o(&mp_type_OverflowError, "small int overflow");
 }
 
 // This is called when an integer larger than a SMALL_INT is needed (although val might still fit in a SMALL_INT)
 mp_obj_t mp_obj_new_int_from_ull(unsigned long long val) {
-    mp_raise_msg(&mp_type_OverflowError, "small int overflow");
-    return mp_const_none;
+    return mp_raise_msg_o(&mp_type_OverflowError, "small int overflow");
 }
 
 mp_obj_t mp_obj_new_int_from_uint(mp_uint_t value) {
@@ -343,16 +343,14 @@
     if ((value & ~MP_SMALL_INT_POSITIVE_MASK) == 0) {
         return MP_OBJ_NEW_SMALL_INT(value);
     }
-    mp_raise_msg(&mp_type_OverflowError, "small int overflow");
-    return mp_const_none;
+    return mp_raise_msg_o(&mp_type_OverflowError, "small int overflow");
 }
 
 mp_obj_t mp_obj_new_int(mp_int_t value) {
     if (MP_SMALL_INT_FITS(value)) {
         return MP_OBJ_NEW_SMALL_INT(value);
     }
-    mp_raise_msg(&mp_type_OverflowError, "small int overflow");
-    return mp_const_none;
+    return mp_raise_msg_o(&mp_type_OverflowError, "small int overflow");
 }
 
 mp_int_t mp_obj_int_get_truncated(mp_const_obj_t self_in) {
@@ -422,7 +420,7 @@
 
     mp_int_t len = mp_obj_get_int(args[1]);
     if (len < 0) {
-        mp_raise_ValueError(NULL);
+        return mp_raise_ValueError_o(NULL);
     }
     bool big_endian = args[2] != MP_OBJ_NEW_QSTR(MP_QSTR_little);
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objint_mpz.c	2020-05-01 00:05:34.700250758 +0200
+++ micropython-master-no_nlr/py/objint_mpz.c	2020-05-01 00:31:42.260541291 +0200
@@ -236,11 +236,10 @@
             case MP_BINARY_OP_FLOOR_DIVIDE:
             case MP_BINARY_OP_INPLACE_FLOOR_DIVIDE: {
                 if (mpz_is_zero(zrhs)) {
-                zero_division_error:
-                    mp_raise_msg(&mp_type_ZeroDivisionError, "divide by zero");
+zero_division_error:
+                    return mp_raise_msg_o(&mp_type_ZeroDivisionError, "divide by zero");
                 }
-                mpz_t rem;
-                mpz_init_zero(&rem);
+                mpz_t rem; mpz_init_zero(&rem);
                 mpz_divmod_inpl(&res->mpz, &rem, zlhs, zrhs);
                 mpz_deinit(&rem);
                 break;
@@ -275,8 +274,11 @@
             case MP_BINARY_OP_RSHIFT:
             case MP_BINARY_OP_INPLACE_RSHIFT: {
                 mp_int_t irhs = mp_obj_int_get_checked(rhs_in);
+                if (MP_STATE_THREAD(active_exception) != NULL) {
+                    return MP_OBJ_NULL;
+                }
                 if (irhs < 0) {
-                    mp_raise_ValueError("negative shift count");
+                    return mp_raise_ValueError_o("negative shift count");
                 }
                 if (op == MP_BINARY_OP_LSHIFT || op == MP_BINARY_OP_INPLACE_LSHIFT) {
                     mpz_shl_inpl(&res->mpz, zlhs, irhs);
@@ -345,7 +347,7 @@
 
 mp_obj_t mp_obj_int_pow3(mp_obj_t base, mp_obj_t exponent,  mp_obj_t modulus) {
     if (!mp_obj_is_int(base) || !mp_obj_is_int(exponent) || !mp_obj_is_int(modulus)) {
-        mp_raise_TypeError("pow() with 3 arguments requires integers");
+        return mp_raise_TypeError_o("pow() with 3 arguments requires integers");
     } else {
         mp_obj_t result = mp_obj_new_int_from_ull(0); // Use the _from_ull version as this forces an mpz int
         mp_obj_int_t *res_p = (mp_obj_int_t *) MP_OBJ_TO_PTR(result);
@@ -426,7 +428,8 @@
             return value;
         } else {
             // overflow
-            mp_raise_msg(&mp_type_OverflowError, "overflow converting long int to machine word");
+            mp_raise_msg_o(&mp_type_OverflowError, "overflow converting long int to machine word");
+            return 0; // TODO callers must handle exceptions
         }
     }
 }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objlist.c	2020-05-01 00:05:34.700250758 +0200
+++ micropython-master-no_nlr/py/objlist.c	2020-05-01 00:33:04.253446638 +0200
@@ -60,8 +60,13 @@
 STATIC mp_obj_t list_extend_from_iter(mp_obj_t list, mp_obj_t iterable) {
     mp_obj_t iter = mp_getiter(iterable, NULL);
     mp_obj_t item;
-    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
-        mp_obj_list_append(list, item);
+    while ((item = mp_iternext2(iter)) != MP_OBJ_NULL) {
+        if (mp_obj_list_append(list, item) == MP_OBJ_NULL) {
+            return MP_OBJ_NULL;
+        }
+    }
+    if (mp_iternext_had_exc()) {
+        return MP_OBJ_NULL;
     }
     return list;
 }
@@ -103,6 +108,7 @@
     }
 }
 
+#include <stdio.h>
 STATIC mp_obj_t list_binary_op(mp_binary_op_t op, mp_obj_t lhs, mp_obj_t rhs) {
     mp_obj_list_t *o = MP_OBJ_TO_PTR(lhs);
     switch (op) {
@@ -128,6 +134,9 @@
                 n = 0;
             }
             mp_obj_list_t *s = list_new(o->len * n);
+            if (s == NULL) {
+                return MP_OBJ_NULL;
+            }
             mp_seq_multiply(o->items, sizeof(*o->items), o->len, n, s->items);
             return MP_OBJ_FROM_PTR(s);
         }
@@ -160,8 +169,11 @@
         if (mp_obj_is_type(index, &mp_type_slice)) {
             mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);
             mp_bound_slice_t slice;
-            if (!mp_seq_get_fast_slice_indexes(self->len, index, &slice)) {
-                mp_raise_NotImplementedError(NULL);
+            int ret = mp_seq_get_fast_slice_indexes(self->len, index, &slice);
+            if (ret < 0) {
+                return MP_OBJ_NULL;
+            } else if (!ret) {
+                return mp_raise_NotImplementedError_o(NULL);
             }
 
             mp_int_t len_adj = slice.start - slice.stop;
@@ -182,33 +194,51 @@
         #if MICROPY_PY_BUILTINS_SLICE
         if (mp_obj_is_type(index, &mp_type_slice)) {
             mp_bound_slice_t slice;
-            if (!mp_seq_get_fast_slice_indexes(self->len, index, &slice)) {
+            int ret = mp_seq_get_fast_slice_indexes(self->len, index, &slice);
+            if (ret < 0) {
+                return MP_OBJ_NULL;
+            } else if (!ret) {
                 return mp_seq_extract_slice(self->len, self->items, &slice);
             }
             mp_obj_list_t *res = list_new(slice.stop - slice.start);
+            if (res == NULL) {
+                return MP_OBJ_NULL;
+            }
             mp_seq_copy(res->items, self->items + slice.start, res->len, mp_obj_t);
             return MP_OBJ_FROM_PTR(res);
         }
         #endif
         size_t index_val = mp_get_index(self->base.type, self->len, index, false);
+        if (index_val == (size_t)-1) {
+            // exception
+            return MP_OBJ_NULL;
+        }
         return self->items[index_val];
     } else {
         #if MICROPY_PY_BUILTINS_SLICE
         if (mp_obj_is_type(index, &mp_type_slice)) {
             mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);
-            size_t value_len;
-            mp_obj_t *value_items;
-            mp_obj_get_array(value, &value_len, &value_items);
+            size_t value_len; mp_obj_t *value_items;
+            if (mp_obj_get_array(value, &value_len, &value_items)) {
+                return MP_OBJ_NULL;
+            }
             mp_bound_slice_t slice_out;
-            if (!mp_seq_get_fast_slice_indexes(self->len, index, &slice_out)) {
-                mp_raise_NotImplementedError(NULL);
+            int ret = mp_seq_get_fast_slice_indexes(self->len, index, &slice_out);
+            if (ret < 0) {
+                return MP_OBJ_NULL;
+            } else if (!ret) {
+                return mp_raise_NotImplementedError_o(NULL);
             }
             mp_int_t len_adj = value_len - (slice_out.stop - slice_out.start);
             if (len_adj > 0) {
                 if (self->len + len_adj > self->alloc) {
                     // TODO: Might optimize memory copies here by checking if block can
                     // be grown inplace or not
-                    self->items = m_renew(mp_obj_t, self->items, self->alloc, self->len + len_adj);
+                    mp_obj_t *new_items = m_renew(mp_obj_t, self->items, self->alloc, self->len + len_adj);
+                    if (new_items == NULL) {
+                        return MP_OBJ_NULL;
+                    }
+                    self->items = new_items;
                     self->alloc = self->len + len_adj;
                 }
                 mp_seq_replace_slice_grow_inplace(self->items, self->len,
@@ -237,7 +267,11 @@
     mp_check_self(mp_obj_is_type(self_in, &mp_type_list));
     mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);
     if (self->len >= self->alloc) {
-        self->items = m_renew(mp_obj_t, self->items, self->alloc, self->alloc * 2);
+        mp_obj_t *items = m_renew(mp_obj_t, self->items, self->alloc, self->alloc * 2);
+        if (items == NULL) {
+            return MP_OBJ_NULL;
+        }
+        self->items = items;
         self->alloc *= 2;
         mp_seq_clear(self->items, self->len + 1, self->alloc, sizeof(*self->items));
     }
@@ -253,7 +287,11 @@
 
         if (self->len + arg->len > self->alloc) {
             // TODO: use alloc policy for "4"
-            self->items = m_renew(mp_obj_t, self->items, self->alloc, self->len + arg->len + 4);
+            mp_obj_t *items = m_renew(mp_obj_t, self->items, self->alloc, self->len + arg->len + 4);
+            if (items == NULL) {
+                return MP_OBJ_NULL;
+            }
+            self->items = items;
             self->alloc = self->len + arg->len + 4;
             mp_seq_clear(self->items, self->len + arg->len, self->alloc, sizeof(*self->items));
         }
@@ -261,7 +299,9 @@
         memcpy(self->items + self->len, arg->items, sizeof(mp_obj_t) * arg->len);
         self->len += arg->len;
     } else {
-        list_extend_from_iter(self_in, arg_in);
+        if (list_extend_from_iter(self_in, arg_in) == MP_OBJ_NULL) {
+            return MP_OBJ_NULL;
+        }
     }
     return mp_const_none; // return None, as per CPython
 }
@@ -270,7 +310,7 @@
     mp_check_self(mp_obj_is_type(args[0], &mp_type_list));
     mp_obj_list_t *self = MP_OBJ_TO_PTR(args[0]);
     if (self->len == 0) {
-        mp_raise_msg(&mp_type_IndexError, "pop from empty list");
+        return mp_raise_msg_o(&mp_type_IndexError, "pop from empty list");
     }
     size_t index = mp_get_index(self->base.type, self->len, n_args == 1 ? MP_OBJ_NEW_SMALL_INT(-1) : args[1], false);
     mp_obj_t ret = self->items[index];
@@ -286,7 +326,10 @@
 }
 
 STATIC void mp_quicksort(mp_obj_t *head, mp_obj_t *tail, mp_obj_t key_fn, mp_obj_t binop_less_result) {
-    MP_STACK_CHECK();
+    if (MP_STACK_CHECK()) {
+        // TODO propagate exception
+        return;
+    }
     while (head < tail) {
         mp_obj_t *h = head - 1;
         mp_obj_t *t = tail;
@@ -328,16 +371,18 @@
     struct {
         mp_arg_val_t key, reverse;
     } args;
-    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args,
-        MP_ARRAY_SIZE(allowed_args), allowed_args, (mp_arg_val_t *)&args);
+    if (mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args,
+        MP_ARRAY_SIZE(allowed_args), allowed_args, (mp_arg_val_t *)&args)) {
+        return MP_OBJ_NULL;
+    }
 
     mp_check_self(mp_obj_is_type(pos_args[0], &mp_type_list));
     mp_obj_list_t *self = MP_OBJ_TO_PTR(pos_args[0]);
 
     if (self->len > 1) {
         mp_quicksort(self->items, self->items + self->len - 1,
-            args.key.u_obj == mp_const_none ? MP_OBJ_NULL : args.key.u_obj,
-            args.reverse.u_bool ? mp_const_false : mp_const_true);
+             args.key.u_obj == mp_const_none ? MP_OBJ_NULL : args.key.u_obj,
+             args.reverse.u_bool ? mp_const_false : mp_const_true);
     }
 
     return mp_const_none;
@@ -400,6 +445,10 @@
     mp_check_self(mp_obj_is_type(self_in, &mp_type_list));
     mp_obj_t args[] = {self_in, value};
     args[1] = list_index(2, args);
+    if (args[1] == MP_OBJ_NULL) {
+        // exception
+        return MP_OBJ_NULL;
+    }
     list_pop(2, args);
 
     return mp_const_none;
@@ -459,23 +508,29 @@
     .locals_dict = (mp_obj_dict_t *)&list_locals_dict,
 };
 
-void mp_obj_list_init(mp_obj_list_t *o, size_t n) {
+mp_obj_list_t *mp_obj_list_init(mp_obj_list_t *o, size_t n) {
     o->base.type = &mp_type_list;
     o->alloc = n < LIST_MIN_ALLOC ? LIST_MIN_ALLOC : n;
     o->len = n;
     o->items = m_new(mp_obj_t, o->alloc);
+    if (o->items == NULL) {
+        return NULL;
+    }
     mp_seq_clear(o->items, n, o->alloc, sizeof(*o->items));
+    return o;
 }
 
 STATIC mp_obj_list_t *list_new(size_t n) {
     mp_obj_list_t *o = m_new_obj(mp_obj_list_t);
-    mp_obj_list_init(o, n);
-    return o;
+    if (o == NULL) {
+        return NULL;
+    }
+    return mp_obj_list_init(o, n);
 }
 
 mp_obj_t mp_obj_new_list(size_t n, mp_obj_t *items) {
     mp_obj_list_t *o = list_new(n);
-    if (items != NULL) {
+    if (o != NULL && items != NULL) {
         for (size_t i = 0; i < n; i++) {
             o->items[i] = items[i];
         }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objlist.h	2020-04-17 09:19:09.278299486 +0200
+++ micropython-master-no_nlr/py/objlist.h	2020-04-17 12:45:36.383619910 +0200
@@ -35,6 +35,6 @@
     mp_obj_t *items;
 } mp_obj_list_t;
 
-void mp_obj_list_init(mp_obj_list_t *o, size_t n);
+mp_obj_list_t *mp_obj_list_init(mp_obj_list_t *o, size_t n);
 
 #endif // MICROPY_INCLUDED_PY_OBJLIST_H
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objmap.c	2020-04-17 09:19:09.278299486 +0200
+++ micropython-master-no_nlr/py/objmap.c	2020-04-17 12:45:36.383619910 +0200
@@ -59,6 +59,10 @@
             m_del(mp_obj_t, nextses, self->n_iters);
             return MP_OBJ_STOP_ITERATION;
         }
+        if (next == MP_OBJ_NULL) {
+            // exception
+            return MP_OBJ_NULL;
+        }
         nextses[i] = next;
     }
     return mp_call_function_n_kw(self->fun, self->n_iters, 0, nextses);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objnamedtuple.c	2020-05-01 00:05:34.700250758 +0200
+++ micropython-master-no_nlr/py/objnamedtuple.c	2020-04-30 23:32:39.492154802 +0200
@@ -87,7 +87,7 @@
     } else {
         // delete/store attribute
         // provide more detailed error message than we'd get by just returning
-        mp_raise_msg(&mp_type_AttributeError, "can't set attribute");
+        mp_raise_msg_o(&mp_type_AttributeError, "can't set attribute");
     }
 }
 
@@ -97,14 +97,15 @@
     if (n_args + n_kw != num_fields) {
         if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
             mp_arg_error_terse_mismatch();
+            return MP_OBJ_NULL;
         } else if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_NORMAL) {
-            mp_raise_msg_varg(&mp_type_TypeError,
+            return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
                 "function takes %d positional arguments but %d were given",
-                num_fields, n_args + n_kw);
+                num_fields, n_args + n_kw));
         } else if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_DETAILED) {
-            mp_raise_msg_varg(&mp_type_TypeError,
+            return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
                 "%q() takes %d positional arguments but %d were given",
-                type->base.name, num_fields, n_args + n_kw);
+                type->base.name, num_fields, n_args + n_kw));
         }
     }
 
@@ -123,16 +124,19 @@
         if (id == (size_t)-1) {
             if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                 mp_arg_error_terse_mismatch();
+                return MP_OBJ_NULL;
             } else {
-                mp_raise_msg_varg(&mp_type_TypeError, "unexpected keyword argument '%q'", kw);
+                return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                    "unexpected keyword argument '%q'", kw));
             }
         }
         if (tuple->items[id] != MP_OBJ_NULL) {
             if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                 mp_arg_error_terse_mismatch();
+                return MP_OBJ_NULL;
             } else {
-                mp_raise_msg_varg(&mp_type_TypeError,
-                    "function got multiple values for argument '%q'", kw);
+                return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                    "function got multiple values for argument '%q'", kw));
             }
         }
         tuple->items[id] = args[i + 1];
@@ -176,7 +180,9 @@
         fields_in = mp_obj_str_split(1, &fields_in);
     }
     #endif
-    mp_obj_get_array(fields_in, &n_fields, &fields);
+    if (mp_obj_get_array(fields_in, &n_fields, &fields)) {
+        return MP_OBJ_NULL;
+    }
     return mp_obj_new_namedtuple_type(name, n_fields, fields);
 }
 MP_DEFINE_CONST_FUN_OBJ_2(mp_namedtuple_obj, new_namedtuple_type);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objobject.c	2020-05-01 00:05:34.700250758 +0200
+++ micropython-master-no_nlr/py/objobject.c	2020-05-01 00:33:55.854756471 +0200
@@ -50,7 +50,7 @@
 
 STATIC mp_obj_t object___new__(mp_obj_t cls) {
     if (!mp_obj_is_type(cls, &mp_type_type) || !mp_obj_is_instance_type((mp_obj_type_t *)MP_OBJ_TO_PTR(cls))) {
-        mp_raise_TypeError("arg must be user-type");
+        return mp_raise_TypeError_o("arg must be user-type");
     }
     // This executes only "__new__" part of instance creation.
     // TODO: This won't work well for classes with native bases.
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objrange.c	2020-05-01 00:05:34.700250758 +0200
+++ micropython-master-no_nlr/py/objrange.c	2020-04-30 23:32:39.494154774 +0200
@@ -90,7 +90,9 @@
 }
 
 STATIC mp_obj_t range_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
-    mp_arg_check_num(n_args, n_kw, 1, 3, false);
+    if (mp_arg_check_num(n_args, n_kw, 1, 3, false)) {
+        return MP_OBJ_NULL;
+    }
 
     mp_obj_range_t *o = m_new_obj(mp_obj_range_t);
     o->base.type = type;
@@ -105,11 +107,16 @@
         if (n_args == 3) {
             o->step = mp_obj_get_int(args[2]);
             if (o->step == 0) {
-                mp_raise_ValueError("zero step");
+                return mp_raise_ValueError_o("zero step");
             }
         }
     }
 
+    // check for errors from mp_obj_get_int
+    if (MP_STATE_THREAD(active_exception) != NULL) {
+        return MP_OBJ_NULL;
+    }
+
     return MP_OBJ_FROM_PTR(o);
 }
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objset.c	2020-05-01 00:05:34.700250758 +0200
+++ micropython-master-no_nlr/py/objset.c	2020-04-30 23:32:39.494154774 +0200
@@ -175,6 +175,9 @@
     check_set_or_frozenset(self_in);
     mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);
     mp_obj_set_t *other = m_new_obj(mp_obj_set_t);
+    if (other == NULL) {
+        return MP_OBJ_NULL;
+    }
     other->base.type = self->base.type;
     mp_set_init(&other->set, self->set.alloc);
     other->set.used = self->set.used;
@@ -362,7 +365,7 @@
     mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);
     mp_obj_t obj = mp_set_remove_first(&self->set);
     if (obj == MP_OBJ_NULL) {
-        mp_raise_msg(&mp_type_KeyError, "pop from an empty set");
+        return mp_raise_msg_o(&mp_type_KeyError, "pop from an empty set");
     }
     return obj;
 }
@@ -372,7 +375,7 @@
     check_set(self_in);
     mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);
     if (mp_set_lookup(&self->set, item, MP_MAP_LOOKUP_REMOVE_IF_FOUND) == MP_OBJ_NULL) {
-        nlr_raise(mp_obj_new_exception_arg1(&mp_type_KeyError, item));
+        return mp_raise_o(mp_obj_new_exception_arg1(&mp_type_KeyError, item));
     }
     return mp_const_none;
 }
@@ -579,6 +582,9 @@
 
 mp_obj_t mp_obj_new_set(size_t n_args, mp_obj_t *items) {
     mp_obj_set_t *o = m_new_obj(mp_obj_set_t);
+    if (o == NULL) {
+        return MP_OBJ_NULL;
+    }
     o->base.type = &mp_type_set;
     mp_set_init(&o->set, n_args);
     for (size_t i = 0; i < n_args; i++) {
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objslice.c	2020-05-01 00:05:34.700250758 +0200
+++ micropython-master-no_nlr/py/objslice.c	2020-04-30 23:32:39.494154774 +0200
@@ -105,6 +105,9 @@
 
 mp_obj_t mp_obj_new_slice(mp_obj_t ostart, mp_obj_t ostop, mp_obj_t ostep) {
     mp_obj_slice_t *o = m_new_obj(mp_obj_slice_t);
+    if (o == NULL) {
+        return MP_OBJ_NULL;
+    }
     o->base.type = &mp_type_slice;
     o->start = ostart;
     o->stop = ostop;
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objstr.c	2020-05-01 00:56:48.648186005 +0200
+++ micropython-master-no_nlr/py/objstr.c	2020-05-01 00:34:54.955964862 +0200
@@ -39,7 +39,7 @@
 #endif
 
 STATIC mp_obj_t mp_obj_new_bytes_iterator(mp_obj_t str, mp_obj_iter_buf_t *iter_buf);
-STATIC NORETURN void bad_implicit_conversion(mp_obj_t self_in);
+STATIC mp_obj_t bad_implicit_conversion(mp_obj_t self_in);
 
 /******************************************************************************/
 /* str                                                                        */
@@ -139,7 +139,9 @@
     }
     #endif
 
-    mp_arg_check_num(n_args, n_kw, 0, 3, false);
+    if (mp_arg_check_num(n_args, n_kw, 0, 3, false)) {
+        return MP_OBJ_NULL;
+    }
 
     switch (n_args) {
         case 0:
@@ -163,7 +165,7 @@
                 }
                 #if MICROPY_PY_BUILTINS_STR_UNICODE_CHECK
                 if (!utf8_check(str_data, str_len)) {
-                    mp_raise_msg(&mp_type_UnicodeError, NULL);
+                    return mp_raise_msg_o(&mp_type_UnicodeError, NULL);
                 }
                 #endif
 
@@ -182,7 +184,7 @@
                 mp_get_buffer_raise(args[0], &bufinfo, MP_BUFFER_READ);
                 #if MICROPY_PY_BUILTINS_STR_UNICODE_CHECK
                 if (!utf8_check(bufinfo.buf, bufinfo.len)) {
-                    mp_raise_msg(&mp_type_UnicodeError, NULL);
+                    return mp_raise_msg_o(&mp_type_UnicodeError, NULL);
                 }
                 #endif
                 return mp_obj_new_str(bufinfo.buf, bufinfo.len);
@@ -227,7 +229,7 @@
     if (mp_obj_is_small_int(args[0])) {
         mp_int_t len = MP_OBJ_SMALL_INT_VALUE(args[0]);
         if (len < 0) {
-            mp_raise_ValueError(NULL);
+            return mp_raise_ValueError_o(NULL);
         }
         vstr_t vstr;
         vstr_init_len(&vstr, len);
@@ -254,20 +256,23 @@
     mp_obj_iter_buf_t iter_buf;
     mp_obj_t iterable = mp_getiter(args[0], &iter_buf);
     mp_obj_t item;
-    while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {
+    while ((item = mp_iternext2(iterable)) != MP_OBJ_NULL) {
         mp_int_t val = mp_obj_get_int(item);
         #if MICROPY_FULL_CHECKS
         if (val < 0 || val > 255) {
-            mp_raise_ValueError("bytes value out of range");
+            return mp_raise_ValueError_o("bytes value out of range");
         }
         #endif
         vstr_add_byte(&vstr, val);
     }
+    if (mp_iternext_had_exc()) {
+        return MP_OBJ_NULL;
+    }
 
     return mp_obj_new_str_from_vstr(&mp_type_bytes, &vstr);
 
 wrong_args:
-    mp_raise_TypeError("wrong number of arguments");
+    return mp_raise_TypeError_o("wrong number of arguments");
 }
 
 // like strstr but with specified length and allows \0 bytes
@@ -373,7 +378,7 @@
     } else {
         // LHS is str and RHS has an incompatible type
         // (except if operation is EQUAL, but that's handled by mp_obj_equal)
-        bad_implicit_conversion(rhs_in);
+        return bad_implicit_conversion(rhs_in);
     }
 
     switch (op) {
@@ -428,12 +433,15 @@
         if (mp_obj_is_type(index, &mp_type_slice)) {
             mp_bound_slice_t slice;
             if (!mp_seq_get_fast_slice_indexes(self_len, index, &slice)) {
-                mp_raise_NotImplementedError("only slices with step=1 (aka None) are supported");
+                return mp_raise_NotImplementedError_o("only slices with step=1 (aka None) are supported");
             }
             return mp_obj_new_str_of_type(type, self_data + slice.start, slice.stop - slice.start);
         }
         #endif
         size_t index_val = mp_get_index(type, self_len, index, false);
+        if (index_val == (size_t)-1) {
+            return MP_OBJ_NULL; // exception
+        }
         // If we have unicode enabled the type will always be bytes, so take the short cut.
         if (MICROPY_PY_BUILTINS_STR_UNICODE || type == &mp_type_bytes) {
             return MP_OBJ_NEW_SMALL_INT(self_data[index_val]);
@@ -460,6 +468,9 @@
         // arg is not a list nor a tuple, try to convert it to a list
         // TODO: Try to optimize?
         arg = mp_type_list.make_new(&mp_type_list, 1, 0, &arg);
+        if (arg == MP_OBJ_NULL) {
+            return MP_OBJ_NULL;
+        }
     }
     mp_obj_get_array(arg, &seq_len, &seq_items);
 
@@ -467,7 +478,7 @@
     size_t required_len = 0;
     for (size_t i = 0; i < seq_len; i++) {
         if (mp_obj_get_type(seq_items[i]) != self_type) {
-            mp_raise_TypeError(
+            return mp_raise_TypeError_o(
                 "join expects a list of str/bytes objects consistent with self object");
         }
         if (i > 0) {
@@ -542,14 +553,14 @@
     } else {
         // sep given
         if (mp_obj_get_type(sep) != self_type) {
-            bad_implicit_conversion(sep);
+            return bad_implicit_conversion(sep);
         }
 
         size_t sep_len;
         const char *sep_str = mp_obj_str_get_data(sep, &sep_len);
 
         if (sep_len == 0) {
-            mp_raise_ValueError("empty separator");
+            return mp_raise_ValueError_o("empty separator");
         }
 
         for (;;) {
@@ -648,13 +659,13 @@
     mp_int_t idx = splits;
 
     if (sep == mp_const_none) {
-        mp_raise_NotImplementedError("rsplit(None,n)");
+        return mp_raise_NotImplementedError_o("rsplit(None,n)");
     } else {
         size_t sep_len;
         const char *sep_str = mp_obj_str_get_data(sep, &sep_len);
 
         if (sep_len == 0) {
-            mp_raise_ValueError("empty separator");
+            return mp_raise_ValueError_o("empty separator");
         }
 
         const byte *beg = s;
@@ -696,7 +707,7 @@
 
     // check argument type
     if (mp_obj_get_type(args[1]) != self_type) {
-        bad_implicit_conversion(args[1]);
+        return bad_implicit_conversion(args[1]);
     }
 
     GET_STR_DATA_LEN(args[0], haystack, haystack_len);
@@ -720,7 +731,7 @@
     out_error:
         // not found
         if (is_index) {
-            mp_raise_ValueError("substring not found");
+            return mp_raise_ValueError_o("substring not found");
         } else {
             return MP_OBJ_NEW_SMALL_INT(-1);
         }
@@ -761,6 +772,10 @@
     GET_STR_DATA_LEN(args[0], str, str_len);
     size_t prefix_len;
     const char *prefix = mp_obj_str_get_data(args[1], &prefix_len);
+    if (prefix == NULL) {
+        // exception
+        return MP_OBJ_NULL;
+    }
     const byte *start = str;
     if (n_args > 2) {
         start = str_index_to_ptr(self_type, str, str_len, args[2], true);
@@ -776,8 +791,11 @@
     GET_STR_DATA_LEN(args[0], str, str_len);
     size_t suffix_len;
     const char *suffix = mp_obj_str_get_data(args[1], &suffix_len);
+    if (suffix == NULL) {
+        return MP_OBJ_NULL;
+    }
     if (n_args > 2) {
-        mp_raise_NotImplementedError("start/end indices");
+        return mp_raise_NotImplementedError_o("start/end indices");
     }
 
     if (suffix_len > str_len) {
@@ -802,7 +820,7 @@
         chars_to_del_len = sizeof(whitespace) - 1;
     } else {
         if (mp_obj_get_type(args[1]) != self_type) {
-            bad_implicit_conversion(args[1]);
+            return bad_implicit_conversion(args[1]);
         }
         GET_STR_DATA_LEN(args[1], s, l);
         chars_to_del = s;
@@ -939,12 +957,14 @@
 #endif
 
 #if MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE
-STATIC NORETURN void terse_str_format_value_error(void) {
-    mp_raise_ValueError("bad format string");
+STATIC mp_obj_t terse_str_format_value_error(void) {
+    return mp_raise_ValueError_o("bad format string");
 }
 #else
 // define to nothing to improve coverage
-#define terse_str_format_value_error()
+static inline mp_obj_t terse_str_format_value_error(void) {
+    return MP_OBJ_NULL;
+}
 #endif
 
 STATIC vstr_t mp_obj_str_format_helper(const char *str, const char *top, int *arg_i, size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {
@@ -962,7 +982,9 @@
             if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                 terse_str_format_value_error();
             } else {
-                mp_raise_ValueError("single '}' encountered in format string");
+                mp_raise_ValueError_o("single '}' encountered in format string");
+                vstr.buf = NULL;
+                return vstr;
             }
         }
         if (*str != '{') {
@@ -1001,16 +1023,18 @@
                 if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                     terse_str_format_value_error();
                 } else if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_NORMAL) {
-                    mp_raise_ValueError("bad conversion specifier");
-                } else {
+                    mp_raise_ValueError_o("bad conversion specifier");
+                    } else {
                     if (str >= top) {
-                        mp_raise_ValueError(
+                        mp_raise_ValueError_o(
                             "end of format while looking for conversion specifier");
                     } else {
-                        mp_raise_msg_varg(&mp_type_ValueError,
-                            "unknown conversion specifier %c", *str);
+                        mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_ValueError,
+                            "unknown conversion specifier %c", *str));
                     }
                 }
+                vstr.buf = NULL;
+                return vstr;
             }
         }
 
@@ -1039,15 +1063,19 @@
             if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                 terse_str_format_value_error();
             } else {
-                mp_raise_ValueError("unmatched '{' in format");
+                mp_raise_ValueError_o("unmatched '{' in format");
             }
+            vstr.buf = NULL;
+            return vstr;
         }
         if (*str != '}') {
             if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                 terse_str_format_value_error();
             } else {
-                mp_raise_ValueError("expected ':' after format specifier");
+                mp_raise_ValueError_o("expected ':' after format specifier");
             }
+            vstr.buf = NULL;
+            return vstr;
         }
 
         mp_obj_t arg = mp_const_none;
@@ -1059,13 +1087,17 @@
                     if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                         terse_str_format_value_error();
                     } else {
-                        mp_raise_ValueError(
+                        mp_raise_ValueError_o(
                             "can't switch from automatic field numbering to manual field specification");
                     }
+                    vstr.buf = NULL;
+                    return vstr;
                 }
                 field_name = str_to_int(field_name, field_name_top, &index);
                 if ((uint)index >= n_args - 1) {
-                    mp_raise_msg(&mp_type_IndexError, "tuple index out of range");
+                    mp_raise_msg_o(&mp_type_IndexError, "tuple index out of range");
+                    vstr.buf = NULL;
+                    return vstr;
                 }
                 arg = args[index + 1];
                 *arg_i = -1;
@@ -1077,24 +1109,32 @@
                 field_name = lookup;
                 mp_map_elem_t *key_elem = mp_map_lookup(kwargs, field_q, MP_MAP_LOOKUP);
                 if (key_elem == NULL) {
-                    nlr_raise(mp_obj_new_exception_arg1(&mp_type_KeyError, field_q));
+                    mp_raise_o(mp_obj_new_exception_arg1(&mp_type_KeyError, field_q));
+                    vstr.buf = NULL;
+                    return vstr;
                 }
                 arg = key_elem->value;
             }
             if (field_name < field_name_top) {
-                mp_raise_NotImplementedError("attributes not supported yet");
+                mp_raise_NotImplementedError_o("attributes not supported yet");
+                vstr.buf = NULL;
+                return vstr;
             }
         } else {
             if (*arg_i < 0) {
                 if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                     terse_str_format_value_error();
                 } else {
-                    mp_raise_ValueError(
+                    mp_raise_ValueError_o(
                         "can't switch from manual field specification to automatic field numbering");
                 }
+                vstr.buf = NULL;
+                return vstr;
             }
             if ((uint)*arg_i >= n_args - 1) {
-                mp_raise_msg(&mp_type_IndexError, "tuple index out of range");
+                mp_raise_msg_o(&mp_type_IndexError, "tuple index out of range");
+                vstr.buf = NULL;
+                return vstr;
             }
             arg = args[(*arg_i) + 1];
             (*arg_i)++;
@@ -1136,8 +1176,14 @@
             // type        ::=  "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%"
 
             // recursively call the formatter to format any nested specifiers
-            MP_STACK_CHECK();
+            if (MP_STACK_CHECK()) {
+                vstr.buf = NULL;
+                return vstr;
+            }
             vstr_t format_spec_vstr = mp_obj_str_format_helper(format_spec, str, arg_i, n_args, args, kwargs);
+            if (format_spec_vstr.buf == NULL) {
+                return format_spec_vstr;
+            }
             const char *s = vstr_null_terminated_str(&format_spec_vstr);
             const char *stop = s + format_spec_vstr.len;
             if (isalignment(*s)) {
@@ -1182,8 +1228,10 @@
                 if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                     terse_str_format_value_error();
                 } else {
-                    mp_raise_ValueError("invalid format specifier");
+                    mp_raise_ValueError_o("invalid format specifier");
                 }
+                vstr.buf = NULL;
+                return vstr;
             }
             vstr_clear(&format_spec_vstr);
         }
@@ -1203,16 +1251,20 @@
                 if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                     terse_str_format_value_error();
                 } else {
-                    mp_raise_ValueError("sign not allowed in string format specifier");
+                    mp_raise_ValueError_o("sign not allowed in string format specifier");
                 }
+                vstr.buf = NULL;
+                return vstr;
             }
             if (type == 'c') {
                 if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                     terse_str_format_value_error();
                 } else {
-                    mp_raise_ValueError(
+                    mp_raise_ValueError_o(
                         "sign not allowed with integer format specifier 'c'");
                 }
+                vstr.buf = NULL;
+                return vstr;
             }
         }
 
@@ -1274,10 +1326,12 @@
                     if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                         terse_str_format_value_error();
                     } else {
-                        mp_raise_msg_varg(&mp_type_ValueError,
+                        mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_ValueError,
                             "unknown format code '%c' for object of type '%s'",
-                            type, mp_obj_get_type_str(arg));
+                            type, mp_obj_get_type_str(arg)));
                     }
+                    vstr.buf = NULL;
+                    return vstr;
             }
         }
 
@@ -1346,10 +1400,12 @@
                     if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                         terse_str_format_value_error();
                     } else {
-                        mp_raise_msg_varg(&mp_type_ValueError,
+                        mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_ValueError,
                             "unknown format code '%c' for object of type '%s'",
-                            type, mp_obj_get_type_str(arg));
+                            type, mp_obj_get_type_str(arg)));
                     }
+                    vstr.buf = NULL;
+                    return vstr;
             }
         } else {
             // arg doesn't look like a number
@@ -1358,9 +1414,11 @@
                 if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                     terse_str_format_value_error();
                 } else {
-                    mp_raise_ValueError(
+                    mp_raise_ValueError_o(
                         "'=' alignment not allowed in string format specifier");
                 }
+                vstr.buf = NULL;
+                return vstr;
             }
 
             switch (type) {
@@ -1382,11 +1440,13 @@
                     if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                         terse_str_format_value_error();
                     } else {
-                        mp_raise_msg_varg(&mp_type_ValueError,
+                        mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_ValueError,
                             "unknown format code '%c' for object of type '%s'",
-                            type, mp_obj_get_type_str(arg));
+                            type, mp_obj_get_type_str(arg)));
                     }
-            }
+                    vstr.buf = NULL;
+                    return vstr;
+                }
         }
     }
 
@@ -1399,6 +1459,9 @@
     GET_STR_DATA_LEN(args[0], str, len);
     int arg_i = 0;
     vstr_t vstr = mp_obj_str_format_helper((const char *)str, (const char *)str + len, &arg_i, n_args, args, kwargs);
+    if (vstr.buf == NULL) {
+        return MP_OBJ_NULL;
+    }
     return mp_obj_new_str_from_vstr(mp_obj_get_type(args[0]), &vstr);
 }
 MP_DEFINE_CONST_FUN_OBJ_KW(str_format_obj, 1, mp_obj_str_format);
@@ -1432,22 +1495,25 @@
         // Dictionary value lookup
         if (*str == '(') {
             if (dict == MP_OBJ_NULL) {
-                mp_raise_TypeError("format needs a dict");
+                return mp_raise_TypeError_o("format needs a dict");
             }
             arg_i = 1; // we used up the single dict argument
             const byte *key = ++str;
             while (*str != ')') {
                 if (str >= top) {
                     if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-                        terse_str_format_value_error();
+                        return terse_str_format_value_error();
                     } else {
-                        mp_raise_ValueError("incomplete format key");
+                        return mp_raise_ValueError_o("incomplete format key");
                     }
                 }
                 ++str;
             }
             mp_obj_t k_obj = mp_obj_new_str_via_qstr((const char *)key, str - key);
             arg = mp_obj_dict_get(dict, k_obj);
+            if (arg == MP_OBJ_NULL) {
+                return MP_OBJ_NULL;
+            }
             str++;
         }
 
@@ -1503,17 +1569,17 @@
         if (str >= top) {
         incomplete_format:
             if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-                terse_str_format_value_error();
+                return terse_str_format_value_error();
             } else {
-                mp_raise_ValueError("incomplete format");
+                return mp_raise_ValueError_o("incomplete format");
             }
         }
 
         // Tuple value lookup
         if (arg == MP_OBJ_NULL) {
             if (arg_i >= n_args) {
-            not_enough_args:
-                mp_raise_TypeError("format string needs more arguments");
+not_enough_args:
+                return mp_raise_TypeError_o("format string needs more arguments");
             }
             arg = args[arg_i++];
         }
@@ -1523,14 +1589,14 @@
                     size_t slen;
                     const char *s = mp_obj_str_get_data(arg, &slen);
                     if (slen != 1) {
-                        mp_raise_TypeError("%c needs int or char");
+                        return mp_raise_TypeError_o("%%c needs int or char");
                     }
                     mp_print_strn(&print, s, 1, flags, ' ', width);
                 } else if (arg_looks_integer(arg)) {
                     char ch = mp_obj_get_int(arg);
                     mp_print_strn(&print, &ch, 1, flags, ' ', width);
                 } else {
-                    mp_raise_TypeError("integer needed");
+                    return mp_raise_TypeError_o("integer needed");
                 }
                 break;
 
@@ -1589,17 +1655,17 @@
 
             default:
                 if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-                    terse_str_format_value_error();
+                    return terse_str_format_value_error();
                 } else {
-                    mp_raise_msg_varg(&mp_type_ValueError,
+                    return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_ValueError,
                         "unsupported format character '%c' (0x%x) at index %d",
-                        *str, *str, str - start_str);
+                        *str, *str, str - start_str));
                 }
         }
     }
 
     if (arg_i != n_args) {
-        mp_raise_TypeError("format string didn't convert all arguments");
+        return mp_raise_TypeError_o("format string didn't convert all arguments");
     }
 
     return mp_obj_new_str_from_vstr(is_bytes ? &mp_type_bytes : &mp_type_str, &vstr);
@@ -1628,11 +1694,11 @@
     const mp_obj_type_t *self_type = mp_obj_get_type(args[0]);
 
     if (mp_obj_get_type(args[1]) != self_type) {
-        bad_implicit_conversion(args[1]);
+        return bad_implicit_conversion(args[1]);
     }
 
     if (mp_obj_get_type(args[2]) != self_type) {
-        bad_implicit_conversion(args[2]);
+        return bad_implicit_conversion(args[2]);
     }
 
     // extract string data
@@ -1721,7 +1787,7 @@
 
     // check argument type
     if (mp_obj_get_type(args[1]) != self_type) {
-        bad_implicit_conversion(args[1]);
+        return bad_implicit_conversion(args[1]);
     }
 
     GET_STR_DATA_LEN(args[0], haystack, haystack_len);
@@ -1762,14 +1828,14 @@
     mp_check_self(mp_obj_is_str_or_bytes(self_in));
     const mp_obj_type_t *self_type = mp_obj_get_type(self_in);
     if (self_type != mp_obj_get_type(arg)) {
-        bad_implicit_conversion(arg);
+        return bad_implicit_conversion(arg);
     }
 
     GET_STR_DATA_LEN(self_in, str, str_len);
     GET_STR_DATA_LEN(arg, sep, sep_len);
 
     if (sep_len == 0) {
-        mp_raise_ValueError("empty separator");
+        return mp_raise_ValueError_o("empty separator");
     }
 
     mp_obj_t result[3];
@@ -2065,28 +2131,34 @@
 
     // make a new str/bytes object
     mp_obj_str_t *o = m_new_obj(mp_obj_str_t);
+    if (o == NULL) {
+        return MP_OBJ_NULL;
+    }
     o->base.type = type;
     o->len = vstr->len;
-    o->hash = qstr_compute_hash((byte *)vstr->buf, vstr->len);
+    o->hash = qstr_compute_hash((byte*)vstr->buf, vstr->len);
     if (vstr->len + 1 == vstr->alloc) {
-        o->data = (byte *)vstr->buf;
+        o->data = (byte*)vstr->buf;
     } else {
-        o->data = (byte *)m_renew(char, vstr->buf, vstr->alloc, vstr->len + 1);
+        o->data = (byte*)m_renew(char, vstr->buf, vstr->alloc, vstr->len + 1);
+        if (o->data == NULL) {
+            return MP_OBJ_NULL;
+        }
     }
-    ((byte *)o->data)[o->len] = '\0'; // add null byte
+    ((byte*)o->data)[o->len] = '\0'; // add null byte
     vstr->buf = NULL;
     vstr->alloc = 0;
     return MP_OBJ_FROM_PTR(o);
 }
 
-mp_obj_t mp_obj_new_str(const char *data, size_t len) {
+mp_obj_t mp_obj_new_str(const char * data, size_t len) {
     qstr q = qstr_find_strn(data, len);
     if (q != MP_QSTRnull) {
         // qstr with this data already exists
         return MP_OBJ_NEW_QSTR(q);
     } else {
         // no existing qstr, don't make one
-        return mp_obj_new_str_copy(&mp_type_str, (const byte *)data, len);
+        return mp_obj_new_str_copy(&mp_type_str, (const byte*)data, len);
     }
 }
 
@@ -2098,10 +2170,14 @@
 mp_obj_t mp_obj_str_intern_checked(mp_obj_t obj) {
     size_t len;
     const char *data = mp_obj_str_get_data(obj, &len);
+    if (data == NULL) {
+        // exception
+        return MP_OBJ_NULL;
+    }
     return mp_obj_new_str_via_qstr((const char *)data, len);
 }
 
-mp_obj_t mp_obj_new_bytes(const byte *data, size_t len) {
+mp_obj_t mp_obj_new_bytes(const byte* data, size_t len) {
     return mp_obj_new_str_copy(&mp_type_bytes, data, len);
 }
 
@@ -2124,14 +2200,14 @@
     }
 }
 
-STATIC NORETURN void bad_implicit_conversion(mp_obj_t self_in) {
+STATIC mp_obj_t bad_implicit_conversion(mp_obj_t self_in) {
     if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-        mp_raise_TypeError("can't convert to str implicitly");
+        return mp_raise_TypeError_o("can't convert to str implicitly");
     } else {
         const qstr src_name = mp_obj_get_type(self_in)->name;
-        mp_raise_msg_varg(&mp_type_TypeError,
+        return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
             "can't convert '%q' object to %q implicitly",
-            src_name, src_name == MP_QSTR_str ? MP_QSTR_bytes : MP_QSTR_str);
+            src_name, src_name == MP_QSTR_str ? MP_QSTR_bytes : MP_QSTR_str));
     }
 }
 
@@ -2145,6 +2221,7 @@
         return qstr_from_strn((char *)self->data, self->len);
     } else {
         bad_implicit_conversion(self_in);
+        return MP_QSTR_NULL; // TODO callers should handle this case
     }
 }
 
@@ -2157,6 +2234,7 @@
         return (const char *)s;
     } else {
         bad_implicit_conversion(self_in);
+        return NULL; // TODO callers should handle this case
     }
 }
 
@@ -2167,6 +2245,7 @@
         return (const char *)s;
     } else {
         bad_implicit_conversion(self_in);
+        return NULL; // TODO callers should handle this case
     }
 }
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objstringio.c	2020-05-01 00:56:48.648186005 +0200
+++ micropython-master-no_nlr/py/objstringio.c	2020-05-01 00:54:49.263810108 +0200
@@ -36,13 +36,15 @@
 #if MICROPY_PY_IO
 
 #if MICROPY_CPYTHON_COMPAT
-STATIC void check_stringio_is_open(const mp_obj_stringio_t *o) {
+STATIC int check_stringio_is_open(const mp_obj_stringio_t *o) {
     if (o->vstr == NULL) {
-        mp_raise_ValueError("I/O operation on closed file");
+        mp_raise_ValueError_o("I/O operation on closed file");
+        return 1;
     }
+    return 0;
 }
 #else
-#define check_stringio_is_open(o)
+#define check_stringio_is_open(o) 0
 #endif
 
 STATIC void stringio_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
@@ -54,7 +56,9 @@
 STATIC mp_uint_t stringio_read(mp_obj_t o_in, void *buf, mp_uint_t size, int *errcode) {
     (void)errcode;
     mp_obj_stringio_t *o = MP_OBJ_TO_PTR(o_in);
-    check_stringio_is_open(o);
+    if (check_stringio_is_open(o)) {
+        return MP_STREAM_ERROR;
+    }
     if (o->vstr->len <= o->pos) {  // read to EOF, or seeked to EOF or beyond
         return 0;
     }
@@ -78,7 +82,9 @@
 STATIC mp_uint_t stringio_write(mp_obj_t o_in, const void *buf, mp_uint_t size, int *errcode) {
     (void)errcode;
     mp_obj_stringio_t *o = MP_OBJ_TO_PTR(o_in);
-    check_stringio_is_open(o);
+    if (check_stringio_is_open(o)) {
+        return MP_STREAM_ERROR;
+    }
 
     if (o->vstr->fixed_buf) {
         stringio_copy_on_write(o);
@@ -164,7 +170,9 @@
 
 STATIC mp_obj_t stringio_getvalue(mp_obj_t self_in) {
     mp_obj_stringio_t *self = MP_OBJ_TO_PTR(self_in);
-    check_stringio_is_open(self);
+    if (check_stringio_is_open(self)) {
+        return MP_OBJ_NULL;
+    }
     // TODO: Try to avoid copying string
     return mp_obj_new_str_of_type(STREAM_TO_CONTENT_TYPE(self), (byte *)self->vstr->buf, self->vstr->len);
 }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objstrunicode.c	2020-05-01 00:05:34.702250729 +0200
+++ micropython-master-no_nlr/py/objstrunicode.c	2020-04-30 23:32:39.496154746 +0200
@@ -129,7 +129,8 @@
     if (mp_obj_is_small_int(index)) {
         i = MP_OBJ_SMALL_INT_VALUE(index);
     } else if (!mp_obj_get_int_maybe(index, &i)) {
-        mp_raise_msg_varg(&mp_type_TypeError, "string indices must be integers, not %s", mp_obj_get_type_str(index));
+        mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError, "string indices must be integers, not %s", mp_obj_get_type_str(index)));
+        return NULL;
     }
     const byte *s, *top = self_data + self_len;
     if (i < 0) {
@@ -139,7 +140,8 @@
                 if (is_slice) {
                     return self_data;
                 }
-                mp_raise_msg(&mp_type_IndexError, "string index out of range");
+                mp_raise_msg_o(&mp_type_IndexError, "string index out of range");
+                return NULL;
             }
             if (!UTF8_IS_CONT(*s)) {
                 ++i;
@@ -158,7 +160,8 @@
                 if (is_slice) {
                     return top;
                 }
-                mp_raise_msg(&mp_type_IndexError, "string index out of range");
+                mp_raise_msg_o(&mp_type_IndexError, "string index out of range");
+                return NULL;
             }
             // Then check completion
             if (i-- == 0) {
@@ -189,7 +192,7 @@
             ostep = slice->step;
 
             if (ostep != mp_const_none && ostep != MP_OBJ_NEW_SMALL_INT(1)) {
-                mp_raise_NotImplementedError("only slices with step=1 (aka None) are supported");
+                return mp_raise_NotImplementedError_o("only slices with step=1 (aka None) are supported");
             }
 
             const byte *pstart, *pstop;
@@ -212,6 +215,9 @@
         }
         #endif
         const byte *s = str_index_to_ptr(type, self_data, self_len, index, false);
+        if (s == NULL) {
+            return MP_OBJ_NULL;
+        }
         int len = 1;
         if (UTF8_IS_NONASCII(*s)) {
             // Count the number of 1 bits (after the first)
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objtuple.c	2020-05-01 00:05:34.702250729 +0200
+++ micropython-master-no_nlr/py/objtuple.c	2020-04-30 23:32:39.496154746 +0200
@@ -86,13 +86,16 @@
 
             mp_obj_t iterable = mp_getiter(args[0], NULL);
             mp_obj_t item;
-            while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {
+            while ((item = mp_iternext2(iterable)) != MP_OBJ_NULL) {
                 if (len >= alloc) {
                     items = m_renew(mp_obj_t, items, alloc, alloc * 2);
                     alloc *= 2;
                 }
                 items[len++] = item;
             }
+            if (mp_iternext_had_exc()) {
+                return MP_OBJ_NULL;
+            }
 
             mp_obj_t tuple = mp_obj_new_tuple(len, items);
             m_del(mp_obj_t, items, alloc);
@@ -185,7 +188,8 @@
         if (mp_obj_is_type(index, &mp_type_slice)) {
             mp_bound_slice_t slice;
             if (!mp_seq_get_fast_slice_indexes(self->len, index, &slice)) {
-                mp_raise_NotImplementedError("only slices with step=1 (aka None) are supported");
+                mp_raise_NotImplementedError_o("only slices with step=1 (aka None) are supported");
+                return MP_OBJ_NULL;
             }
             mp_obj_tuple_t *res = MP_OBJ_TO_PTR(mp_obj_new_tuple(slice.stop - slice.start, NULL));
             mp_seq_copy(res->items, self->items + slice.start, res->len, mp_obj_t);
@@ -193,6 +197,10 @@
         }
         #endif
         size_t index_value = mp_get_index(self->base.type, self->len, index, false);
+        if (index_value == (size_t)-1) {
+            // exception
+            return MP_OBJ_NULL;
+        }
         return self->items[index_value];
     } else {
         return MP_OBJ_NULL; // op not supported
@@ -240,6 +248,9 @@
         return mp_const_empty_tuple;
     }
     mp_obj_tuple_t *o = m_new_obj_var(mp_obj_tuple_t, mp_obj_t, n);
+    if (o == NULL) {
+        return MP_OBJ_NULL;
+    }
     o->base.type = &mp_type_tuple;
     o->len = n;
     if (items) {
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objtype.c	2020-05-01 00:05:34.702250729 +0200
+++ micropython-master-no_nlr/py/objtype.c	2020-04-30 23:32:39.496154746 +0200
@@ -349,10 +349,10 @@
         }
         if (init_ret != mp_const_none) {
             if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-                mp_raise_TypeError("__init__() should return None");
+                return mp_raise_TypeError_o("__init__() should return None");
             } else {
-                mp_raise_msg_varg(&mp_type_TypeError,
-                    "__init__() should return None, not '%s'", mp_obj_get_type_str(init_ret));
+                return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                    "__init__() should return None, not '%s'", mp_obj_get_type_str(init_ret)));
             }
         }
 
@@ -419,16 +419,18 @@
         return mp_unary_op(op, self->subobj[0]);
     } else if (member[0] != MP_OBJ_NULL) {
         mp_obj_t val = mp_call_function_1(member[0], self_in);
-
         switch (op) {
             case MP_UNARY_OP_HASH:
                 // __hash__ must return a small int
                 val = MP_OBJ_NEW_SMALL_INT(mp_obj_get_int_truncated(val));
+                if (MP_STATE_THREAD(active_exception) != NULL) {
+                    return MP_OBJ_NULL;
+                }
                 break;
             case MP_UNARY_OP_INT:
                 // Must return int
                 if (!mp_obj_is_int(val)) {
-                    mp_raise_TypeError(NULL);
+                    return mp_raise_TypeError_o(NULL);
                 }
                 break;
             default:
@@ -628,7 +630,7 @@
             // the code.
             const mp_obj_t *proxy = mp_obj_property_get(member);
             if (proxy[0] == mp_const_none) {
-                mp_raise_msg(&mp_type_AttributeError, "unreadable attribute");
+                mp_raise_msg_o(&mp_type_AttributeError, "unreadable attribute");
             } else {
                 dest[0] = mp_call_function_n_kw(proxy[0], 1, 0, &self_in);
             }
@@ -865,10 +867,10 @@
     mp_obj_t call = mp_obj_instance_get_call(self_in, member);
     if (call == MP_OBJ_NULL) {
         if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-            mp_raise_TypeError("object not callable");
+            return mp_raise_TypeError_o("object not callable");
         } else {
-            mp_raise_msg_varg(&mp_type_TypeError,
-                "'%s' object isn't callable", mp_obj_get_type_str(self_in));
+            return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                "'%s' object isn't callable", mp_obj_get_type_str(self_in)));
         }
     }
     mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);
@@ -979,7 +981,7 @@
             return mp_obj_new_type(mp_obj_str_get_qstr(args[0]), args[1], args[2]);
 
         default:
-            mp_raise_TypeError("type takes 1 or 3 arguments");
+            return mp_raise_TypeError_o("type takes 1 or 3 arguments");
     }
 }
 
@@ -990,9 +992,10 @@
 
     if (self->make_new == NULL) {
         if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-            mp_raise_TypeError("cannot create instance");
+            return mp_raise_TypeError_o("cannot create instance");
         } else {
-            mp_raise_msg_varg(&mp_type_TypeError, "cannot create '%q' instances", self->name);
+            return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                "cannot create '%q' instances", self->name));
         }
     }
 
@@ -1061,7 +1064,8 @@
                     if (check_for_special_accessors(MP_OBJ_NEW_QSTR(attr), dest[1])) {
                         if (self->flags & MP_TYPE_FLAG_IS_SUBCLASSED) {
                             // This class is already subclassed so can't have special accessors added
-                            mp_raise_msg(&mp_type_AttributeError, "can't add special method to already-subclassed class");
+                            mp_raise_msg_o(&mp_type_AttributeError, "can't add special method to already-subclassed class");
+                            return;
                         }
                         self->flags |= MP_TYPE_FLAG_HAS_SPECIAL_ACCESSORS;
                     }
@@ -1090,10 +1094,10 @@
 mp_obj_t mp_obj_new_type(qstr name, mp_obj_t bases_tuple, mp_obj_t locals_dict) {
     // Verify input objects have expected type
     if (!mp_obj_is_type(bases_tuple, &mp_type_tuple)) {
-        mp_raise_TypeError(NULL);
+        return mp_raise_TypeError_o(NULL);
     }
     if (!mp_obj_is_type(locals_dict, &mp_type_dict)) {
-        mp_raise_TypeError(NULL);
+        return mp_raise_TypeError_o(NULL);
     }
 
     // TODO might need to make a copy of locals_dict; at least that's how CPython does it
@@ -1106,16 +1110,16 @@
     mp_obj_tuple_get(bases_tuple, &bases_len, &bases_items);
     for (size_t i = 0; i < bases_len; i++) {
         if (!mp_obj_is_type(bases_items[i], &mp_type_type)) {
-            mp_raise_TypeError(NULL);
+            return mp_raise_TypeError_o(NULL);
         }
         mp_obj_type_t *t = MP_OBJ_TO_PTR(bases_items[i]);
         // TODO: Verify with CPy, tested on function type
         if (t->make_new == NULL) {
             if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-                mp_raise_TypeError("type isn't an acceptable base type");
+                return mp_raise_TypeError_o("type isn't an acceptable base type");
             } else {
-                mp_raise_msg_varg(&mp_type_TypeError,
-                    "type '%q' isn't an acceptable base type", t->name);
+                return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                    "type '%q' isn't an acceptable base type", t->name));
             }
         }
         #if ENABLE_SPECIAL_ACCESSORS
@@ -1152,7 +1156,7 @@
             #if MICROPY_MULTIPLE_INHERITANCE
             o->parent = MP_OBJ_TO_PTR(bases_tuple);
             #else
-            mp_raise_NotImplementedError("multiple inheritance not supported");
+            return mp_raise_NotImplementedError_o("multiple inheritance not supported");
             #endif
         } else {
             o->parent = MP_OBJ_TO_PTR(bases_items[0]);
@@ -1179,7 +1183,7 @@
     const mp_obj_type_t *native_base;
     size_t num_native_bases = instance_count_native_bases(o, &native_base);
     if (num_native_bases > 1) {
-        mp_raise_TypeError("multiple bases have instance lay-out conflict");
+        return mp_raise_TypeError_o("multiple bases have instance lay-out conflict");
     }
 
     mp_map_t *locals_map = &o->locals_dict->map;
@@ -1220,7 +1224,7 @@
     // 1 argument is not yet implemented
     mp_arg_check_num(n_args, n_kw, 2, 2, false);
     if (!mp_obj_is_type(args[0], &mp_type_type)) {
-        mp_raise_TypeError(NULL);
+        return mp_raise_TypeError_o(NULL);
     }
     mp_obj_super_t *o = m_new_obj(mp_obj_super_t);
     *o = (mp_obj_super_t) {{type_in}, args[0], args[1]};
@@ -1301,9 +1305,9 @@
     .attr = super_attr,
 };
 
-void mp_load_super_method(qstr attr, mp_obj_t *dest) {
+mp_obj_t mp_load_super_method(qstr attr, mp_obj_t *dest) {
     mp_obj_super_t super = {{&mp_type_super}, dest[1], dest[2]};
-    mp_load_method(MP_OBJ_FROM_PTR(&super), attr, dest);
+    return mp_load_method(MP_OBJ_FROM_PTR(&super), attr, dest);
 }
 
 /******************************************************************************/
@@ -1362,7 +1366,7 @@
     } else if (mp_obj_is_type(classinfo, &mp_type_tuple)) {
         mp_obj_tuple_get(classinfo, &len, &items);
     } else {
-        mp_raise_TypeError("issubclass() arg 2 must be a class or a tuple of classes");
+        return mp_raise_TypeError_o("issubclass() arg 2 must be a class or a tuple of classes");
     }
 
     for (size_t i = 0; i < len; i++) {
@@ -1376,7 +1380,7 @@
 
 STATIC mp_obj_t mp_builtin_issubclass(mp_obj_t object, mp_obj_t classinfo) {
     if (!mp_obj_is_type(object, &mp_type_type)) {
-        mp_raise_TypeError("issubclass() arg 1 must be a class");
+        return mp_raise_TypeError_o("issubclass() arg 1 must be a class");
     }
     return mp_obj_is_subclass(object, classinfo);
 }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/objzip.c	2020-04-17 09:19:09.282299431 +0200
+++ micropython-master-no_nlr/py/objzip.c	2020-04-17 12:45:36.387619859 +0200
@@ -58,6 +58,10 @@
 
     for (size_t i = 0; i < self->n_iters; i++) {
         mp_obj_t next = mp_iternext(self->iters[i]);
+        if (next == MP_OBJ_NULL) {
+            // exception
+            return MP_OBJ_NULL;
+        }
         if (next == MP_OBJ_STOP_ITERATION) {
             mp_obj_tuple_del(MP_OBJ_FROM_PTR(tuple));
             return MP_OBJ_STOP_ITERATION;
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/parse.c	2020-05-01 00:05:34.702250729 +0200
+++ micropython-master-no_nlr/py/parse.c	2020-05-01 00:35:45.423287964 +0200
@@ -284,6 +284,9 @@
             alloc = num_bytes;
         }
         chunk = (mp_parse_chunk_t *)m_new(byte, sizeof(mp_parse_chunk_t) + alloc);
+        if (chunk == NULL) {
+            return NULL;
+        }
         chunk->alloc = alloc;
         chunk->union_.used = 0;
         parser->cur_chunk = chunk;
@@ -453,6 +456,9 @@
 
 STATIC mp_parse_node_t make_node_const_object(parser_t *parser, size_t src_line, mp_obj_t obj) {
     mp_parse_node_struct_t *pn = parser_alloc(parser, sizeof(mp_parse_node_struct_t) + sizeof(mp_obj_t));
+    if (pn == NULL) {
+        return MP_PARSE_NODE_NULL;
+    }
     pn->source_line = src_line;
     #if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_D
     // nodes are 32-bit pointers, but need to store 64-bit object
@@ -611,7 +617,7 @@
     return false;
 }
 
-STATIC bool fold_constants(parser_t *parser, uint8_t rule_id, size_t num_args) {
+STATIC int fold_constants(parser_t *parser, uint8_t rule_id, size_t num_args) {
     // this code does folding of arbitrary integer expressions, eg 1 + 2 * 3 + 4
     // it does not do partial folding, eg 1 + 2 + x -> 3 + x
 
@@ -717,7 +723,8 @@
                         "constant must be an integer");
                     mp_obj_exception_add_traceback(exc, parser->lexer->source_name,
                         ((mp_parse_node_struct_t *)pn1)->source_line, MP_QSTRnull);
-                    nlr_raise(exc);
+                    mp_raise_o(exc);
+                    return -1;
                 }
 
                 // store the value in the table of dynamic constants
@@ -818,6 +825,9 @@
     #endif
 
     mp_parse_node_struct_t *pn = parser_alloc(parser, sizeof(mp_parse_node_struct_t) + sizeof(mp_parse_node_t) * num_args);
+    if (pn == NULL) {
+        return;
+    }
     pn->source_line = src_line;
     pn->kind_num_nodes = (rule_id & 0xff) | (num_args << 8);
     for (size_t i = num_args; i > 0; i--) {
@@ -840,6 +850,10 @@
     parser.result_stack_top = 0;
     parser.result_stack = m_new(mp_parse_node_t, parser.result_stack_alloc);
 
+    if (MP_STATE_THREAD(active_exception) != NULL) {
+        return parser.tree;
+    }
+
     parser.lexer = lex;
 
     parser.tree.chunk = NULL;
@@ -1119,6 +1133,10 @@
                 break;
             }
         }
+
+        if (MP_STATE_THREAD(active_exception) != NULL) {
+            return parser.tree;
+        }
     }
 
     #if MICROPY_COMP_CONST
@@ -1155,7 +1173,8 @@
         // add traceback to give info about file name and location
         // we don't have a 'block' name, so just pass the NULL qstr to indicate this
         mp_obj_exception_add_traceback(exc, lex->source_name, lex->tok_line, MP_QSTRnull);
-        nlr_raise(exc);
+        mp_raise_o(exc);
+        return parser.tree;
     }
 
     // get the root parse node that we created
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/parsenum.c	2020-05-01 00:05:34.702250729 +0200
+++ micropython-master-no_nlr/py/parsenum.c	2020-05-01 00:37:47.195653863 +0200
@@ -36,14 +36,14 @@
 #include <math.h>
 #endif
 
-STATIC NORETURN void raise_exc(mp_obj_t exc, mp_lexer_t *lex) {
+STATIC mp_obj_t raise_exc(mp_obj_t exc, mp_lexer_t *lex) {
     // if lex!=NULL then the parser called us and we need to convert the
     // exception's type from ValueError to SyntaxError and add traceback info
     if (lex != NULL) {
         ((mp_obj_base_t *)MP_OBJ_TO_PTR(exc))->type = &mp_type_SyntaxError;
         mp_obj_exception_add_traceback(exc, lex->source_name, lex->tok_line, MP_QSTRnull);
     }
-    nlr_raise(exc);
+    return mp_raise_o(exc);
 }
 
 mp_obj_t mp_parse_num_integer(const char *restrict str_, size_t len, int base, mp_lexer_t *lex) {
@@ -55,7 +55,7 @@
     // check radix base
     if ((base != 0 && base < 2) || base > 36) {
         // this won't be reached if lex!=NULL
-        mp_raise_ValueError("int() arg 2 must be >= 2 and <= 36");
+        return mp_raise_ValueError_o("int() arg 2 must be >= 2 and <= 36");
     }
 
     // skip leading space
@@ -147,11 +147,11 @@
     if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
         mp_obj_t exc = mp_obj_new_exception_msg(&mp_type_ValueError,
             "invalid syntax for integer");
-        raise_exc(exc, lex);
+        return raise_exc(exc, lex);
     } else if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_NORMAL) {
         mp_obj_t exc = mp_obj_new_exception_msg_varg(&mp_type_ValueError,
             "invalid syntax for integer with base %d", base);
-        raise_exc(exc, lex);
+        return raise_exc(exc, lex);
     } else {
         vstr_t vstr;
         mp_print_t print;
@@ -160,7 +160,7 @@
         mp_str_print_quoted(&print, str_val_start, top - str_val_start, true);
         mp_obj_t exc = mp_obj_new_exception_arg1(&mp_type_ValueError,
             mp_obj_new_str_from_vstr(&mp_type_str, &vstr));
-        raise_exc(exc, lex);
+        return raise_exc(exc, lex);
     }
 }
 
@@ -340,19 +340,19 @@
     } else if (force_complex) {
         return mp_obj_new_complex(dec_val, 0);
     }
-    #else
+    #else //MICROPY_PY_BUILTINS_COMPLEX
     if (imag || force_complex) {
-        raise_exc(mp_obj_new_exception_msg(&mp_type_ValueError, "complex values not supported"), lex);
+        return raise_exc(mp_obj_new_exception_msg(&mp_type_ValueError, "complex values not supported"), lex);
     }
-    #endif
+    #endif //MICROPY_PY_BUILTINS_COMPLEX
     else {
         return mp_obj_new_float(dec_val);
     }
 
 value_error:
-    raise_exc(mp_obj_new_exception_msg(&mp_type_ValueError, "invalid syntax for number"), lex);
+    return raise_exc(mp_obj_new_exception_msg(&mp_type_ValueError, "invalid syntax for number"), lex);
 
-    #else
-    raise_exc(mp_obj_new_exception_msg(&mp_type_ValueError, "decimal numbers not supported"), lex);
-    #endif
+    #else //MICROPY_PY_BUILTINS_FLOAT
+    return raise_exc(mp_obj_new_exception_msg(&mp_type_ValueError, "decimal numbers not supported"), lex);
+    #endif //MICROPY_PY_BUILTINS_FLOAT
 }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/persistentcode.c	2020-05-01 00:05:34.704250701 +0200
+++ micropython-master-no_nlr/py/persistentcode.c	2020-04-30 23:32:39.498154717 +0200
@@ -542,12 +542,14 @@
         || MPY_FEATURE_DECODE_FLAGS(header[2]) != MPY_FEATURE_FLAGS
         || header[3] > mp_small_int_bits()
         || read_uint(reader, NULL) > QSTR_WINDOW_SIZE) {
-        mp_raise_ValueError("incompatible .mpy file");
+        mp_raise_ValueError_o("incompatible .mpy file");
+        return NULL;
     }
     if (MPY_FEATURE_DECODE_ARCH(header[2]) != MP_NATIVE_ARCH_NONE) {
         byte arch = MPY_FEATURE_DECODE_ARCH(header[2]);
         if (!MPY_FEATURE_ARCH_TEST(arch)) {
-            mp_raise_ValueError("incompatible .mpy arch");
+            mp_raise_ValueError_o("incompatible .mpy arch");
+            return NULL;
         }
     }
     qstr_window_t qw;
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/qstr.c	2020-05-01 00:05:34.704250701 +0200
+++ micropython-master-no_nlr/py/qstr.c	2020-04-30 23:32:39.498154717 +0200
@@ -155,6 +155,7 @@
         if (pool == NULL) {
             QSTR_EXIT();
             m_malloc_fail(new_alloc);
+            return 0;
         }
         pool->prev = MP_STATE_VM(last_pool);
         pool->total_prev_len = MP_STATE_VM(last_pool)->total_prev_len + MP_STATE_VM(last_pool)->len;
@@ -233,6 +234,7 @@
                 if (MP_STATE_VM(qstr_last_chunk) == NULL) {
                     QSTR_EXIT();
                     m_malloc_fail(n_bytes);
+                    return 0;
                 }
                 al = n_bytes;
             }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/reader.c	2020-05-01 00:05:34.704250701 +0200
+++ micropython-master-no_nlr/py/reader.c	2020-04-30 23:32:39.498154717 +0200
@@ -113,6 +113,9 @@
 
 void mp_reader_new_file_from_fd(mp_reader_t *reader, int fd, bool close_fd) {
     mp_reader_posix_t *rp = m_new_obj(mp_reader_posix_t);
+    if (rp == NULL) {
+        return;
+    }
     rp->close_fd = close_fd;
     rp->fd = fd;
     MP_THREAD_GIL_EXIT();
@@ -122,7 +125,8 @@
             close(fd);
         }
         MP_THREAD_GIL_ENTER();
-        mp_raise_OSError(errno);
+        mp_raise_OSError_o(errno);
+        return;
     }
     MP_THREAD_GIL_ENTER();
     rp->len = n;
@@ -139,7 +143,8 @@
     int fd = open(filename, O_RDONLY, 0644);
     MP_THREAD_GIL_ENTER();
     if (fd < 0) {
-        mp_raise_OSError(errno);
+        mp_raise_OSError_o(errno);
+        return;
     }
     mp_reader_new_file_from_fd(reader, fd, true);
 }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/runtime0.h	2020-04-17 13:54:02.122895691 +0200
+++ micropython-master-no_nlr/py/runtime0.h	2020-04-17 12:49:40.710516908 +0200
@@ -156,4 +156,5 @@
     MP_BINARY_OP_IS_NOT,
 } mp_binary_op_t;
 
+
 #endif // MICROPY_INCLUDED_PY_RUNTIME0_H
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/runtime.c	2020-05-01 00:05:34.704250701 +0200
+++ micropython-master-no_nlr/py/runtime.c	2020-05-01 00:38:50.000811594 +0200
@@ -59,6 +59,8 @@
 };
 
 void mp_init(void) {
+    MP_STATE_THREAD(active_exception) = NULL;
+
     qstr_init();
 
     // no pending exceptions to start with
@@ -92,9 +94,15 @@
 
     // init global module dict
     mp_obj_dict_init(&MP_STATE_VM(mp_loaded_modules_dict), 3);
+    if (MP_STATE_THREAD(active_exception) != NULL) {
+        return;
+    }
 
     // initialise the __main__ module
     mp_obj_dict_init(&MP_STATE_VM(dict_main), 1);
+    if (MP_STATE_THREAD(active_exception) != NULL) {
+        return;
+    }
     mp_obj_dict_store(MP_OBJ_FROM_PTR(&MP_STATE_VM(dict_main)), MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR___main__));
 
     // locals = globals for outer module (see Objects/frameobject.c/PyFrame_New())
@@ -186,9 +194,10 @@
         elem = mp_map_lookup((mp_map_t *)&mp_module_builtins_globals.map, MP_OBJ_NEW_QSTR(qst), MP_MAP_LOOKUP);
         if (elem == NULL) {
             if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-                mp_raise_msg(&mp_type_NameError, "name not defined");
+                return mp_raise_msg_o(&mp_type_NameError, "name not defined");
             } else {
-                mp_raise_msg_varg(&mp_type_NameError, "name '%q' isn't defined", qst);
+                return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_NameError,
+                    "name '%q' isn't defined", qst));
             }
         }
     }
@@ -214,10 +223,10 @@
     mp_obj_dict_store(MP_OBJ_FROM_PTR(mp_locals_get()), MP_OBJ_NEW_QSTR(qst), obj);
 }
 
-void mp_delete_name(qstr qst) {
+mp_obj_t mp_delete_name(qstr qst) {
     DEBUG_OP_printf("delete name %s\n", qstr_str(qst));
     // TODO convert KeyError to NameError if qst not found
-    mp_obj_dict_delete(MP_OBJ_FROM_PTR(mp_locals_get()), MP_OBJ_NEW_QSTR(qst));
+    return mp_obj_dict_delete(MP_OBJ_FROM_PTR(mp_locals_get()), MP_OBJ_NEW_QSTR(qst));
 }
 
 void mp_store_global(qstr qst, mp_obj_t obj) {
@@ -225,10 +234,10 @@
     mp_obj_dict_store(MP_OBJ_FROM_PTR(mp_globals_get()), MP_OBJ_NEW_QSTR(qst), obj);
 }
 
-void mp_delete_global(qstr qst) {
+mp_obj_t mp_delete_global(qstr qst) {
     DEBUG_OP_printf("delete global %s\n", qstr_str(qst));
     // TODO convert KeyError to NameError if qst not found
-    mp_obj_dict_delete(MP_OBJ_FROM_PTR(mp_globals_get()), MP_OBJ_NEW_QSTR(qst));
+    return mp_obj_dict_delete(MP_OBJ_FROM_PTR(mp_globals_get()), MP_OBJ_NEW_QSTR(qst));
 }
 
 mp_obj_t mp_unary_op(mp_unary_op_t op, mp_obj_t arg) {
@@ -287,18 +296,18 @@
         // In this case provide a more focused error message to not confuse, e.g. chr(1.0)
         if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
             if (op == MP_UNARY_OP_INT) {
-                mp_raise_TypeError("can't convert to int");
+                return mp_raise_TypeError_o("can't convert to int");
             } else {
-                mp_raise_TypeError("unsupported type for operator");
+                return mp_raise_TypeError_o("unsupported type for operator");
             }
         } else {
             if (op == MP_UNARY_OP_INT) {
-                mp_raise_msg_varg(&mp_type_TypeError,
-                    "can't convert %s to int", mp_obj_get_type_str(arg));
+                return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                    "can't convert %s to int", mp_obj_get_type_str(arg)));
             } else {
-                mp_raise_msg_varg(&mp_type_TypeError,
+                return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
                     "unsupported type for %q: '%s'",
-                    mp_unary_op_method_name[op], mp_obj_get_type_str(arg));
+                    mp_unary_op_method_name[op], mp_obj_get_type_str(arg)));
             }
         }
     }
@@ -382,7 +391,7 @@
                 case MP_BINARY_OP_INPLACE_LSHIFT: {
                     if (rhs_val < 0) {
                         // negative shift not allowed
-                        mp_raise_ValueError("negative shift count");
+                        return mp_raise_ValueError_o("negative shift count");
                     } else if (rhs_val >= (mp_int_t)BITS_PER_WORD || lhs_val > (MP_SMALL_INT_MAX >> rhs_val) || lhs_val < (MP_SMALL_INT_MIN >> rhs_val)) {
                         // left-shift will overflow, so use higher precision integer
                         lhs = mp_obj_new_int_from_ll(lhs_val);
@@ -397,7 +406,7 @@
                 case MP_BINARY_OP_INPLACE_RSHIFT:
                     if (rhs_val < 0) {
                         // negative shift not allowed
-                        mp_raise_ValueError("negative shift count");
+                        return mp_raise_ValueError_o("negative shift count");
                     } else {
                         // standard precision is enough for right-shift
                         if (rhs_val >= (mp_int_t)BITS_PER_WORD) {
@@ -571,6 +580,9 @@
         if (result != MP_OBJ_NULL) {
             return result;
         }
+        if (MP_STATE_THREAD(active_exception) != NULL) {
+            return MP_OBJ_NULL;
+        }
     }
 
     #if MICROPY_PY_REVERSE_SPECIAL_METHODS
@@ -594,6 +606,10 @@
         // mp_getiter will raise the appropriate exception if lhs is not iterable.
         mp_obj_iter_buf_t iter_buf;
         mp_obj_t iter = mp_getiter(lhs, &iter_buf);
+        if (iter == MP_OBJ_NULL) {
+            // exception
+            return MP_OBJ_NULL;
+        }
         mp_obj_t next;
         while ((next = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
             if (mp_obj_equal(next, rhs)) {
@@ -605,15 +621,15 @@
 
 unsupported_op:
     if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-        mp_raise_TypeError("unsupported type for operator");
+        return mp_raise_TypeError_o("unsupported type for operator");
     } else {
-        mp_raise_msg_varg(&mp_type_TypeError,
+        return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
             "unsupported types for %q: '%s', '%s'",
-            mp_binary_op_method_name[op], mp_obj_get_type_str(lhs), mp_obj_get_type_str(rhs));
+            mp_binary_op_method_name[op], mp_obj_get_type_str(lhs), mp_obj_get_type_str(rhs)));
     }
 
 zero_division:
-    mp_raise_msg(&mp_type_ZeroDivisionError, "divide by zero");
+    return mp_raise_msg_o(&mp_type_ZeroDivisionError, "divide by zero");
 }
 
 mp_obj_t mp_call_function_0(mp_obj_t fun) {
@@ -647,10 +663,10 @@
     }
 
     if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-        mp_raise_TypeError("object not callable");
+        return mp_raise_TypeError_o("object not callable");
     } else {
-        mp_raise_msg_varg(&mp_type_TypeError,
-            "'%s' object isn't callable", mp_obj_get_type_str(fun_in));
+        return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+            "'%s' object isn't callable", mp_obj_get_type_str(fun_in)));
     }
 }
 
@@ -666,7 +682,7 @@
 #if !MICROPY_STACKLESS
 STATIC
 #endif
-void mp_call_prepare_args_n_kw_var(bool have_self, size_t n_args_n_kw, const mp_obj_t *args, mp_call_args_t *out_args) {
+int mp_call_prepare_args_n_kw_var(bool have_self, size_t n_args_n_kw, const mp_obj_t *args, mp_call_args_t *out_args) {
     mp_obj_t fun = *args++;
     mp_obj_t self = MP_OBJ_NULL;
     if (have_self) {
@@ -783,6 +799,10 @@
                 mp_obj_t key = map->table[i].key;
                 if (!mp_obj_is_qstr(key)) {
                     key = mp_obj_str_intern_checked(key);
+                    if (key == MP_OBJ_NULL) {
+                        // exception
+                        return 1;
+                    }
                 }
                 args2[args2_len++] = key;
                 args2[args2_len++] = map->table[i].value;
@@ -831,11 +851,15 @@
     out_args->n_args = pos_args_len;
     out_args->n_kw = (args2_len - pos_args_len) / 2;
     out_args->n_alloc = args2_alloc;
+
+    return 0;
 }
 
 mp_obj_t mp_call_method_n_kw_var(bool have_self, size_t n_args_n_kw, const mp_obj_t *args) {
     mp_call_args_t out_args;
-    mp_call_prepare_args_n_kw_var(have_self, n_args_n_kw, args, &out_args);
+    if (mp_call_prepare_args_n_kw_var(have_self, n_args_n_kw, args, &out_args)) {
+        return MP_OBJ_NULL;
+    }
 
     mp_obj_t res = mp_call_function_n_kw(out_args.fun, out_args.n_args, out_args.n_kw, out_args.args);
     mp_nonlocal_free(out_args.args, out_args.n_alloc * sizeof(mp_obj_t));
@@ -844,7 +868,7 @@
 }
 
 // unpacked items are stored in reverse order into the array pointed to by items
-void mp_unpack_sequence(mp_obj_t seq_in, size_t num, mp_obj_t *items) {
+mp_obj_t mp_unpack_sequence(mp_obj_t seq_in, size_t num, mp_obj_t *items) {
     size_t seq_len;
     if (mp_obj_is_type(seq_in, &mp_type_tuple) || mp_obj_is_type(seq_in, &mp_type_list)) {
         mp_obj_t *seq_items;
@@ -872,24 +896,26 @@
             goto too_long;
         }
     }
-    return;
+    return MP_OBJ_SENTINEL; // success
 
 too_short:
     if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-        mp_raise_ValueError("wrong number of values to unpack");
+        return mp_raise_ValueError_o("wrong number of values to unpack");
     } else {
-        mp_raise_msg_varg(&mp_type_ValueError, "need more than %d values to unpack", (int)seq_len);
+        return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_ValueError,
+            "need more than %d values to unpack", (int)seq_len));
     }
 too_long:
     if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-        mp_raise_ValueError("wrong number of values to unpack");
+        return mp_raise_ValueError_o("wrong number of values to unpack");
     } else {
-        mp_raise_msg_varg(&mp_type_ValueError, "too many values to unpack (expected %d)", (int)num);
+        return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_ValueError,
+            "too many values to unpack (expected %d)", (int)num));
     }
 }
 
 // unpacked items are stored in reverse order into the array pointed to by items
-void mp_unpack_ex(mp_obj_t seq_in, size_t num_in, mp_obj_t *items) {
+mp_obj_t mp_unpack_ex(mp_obj_t seq_in, size_t num_in, mp_obj_t *items) {
     size_t num_left = num_in & 0xff;
     size_t num_right = (num_in >> 8) & 0xff;
     DEBUG_OP_printf("unpack ex " UINT_FMT " " UINT_FMT "\n", num_left, num_right);
@@ -939,13 +965,14 @@
         }
         mp_obj_list_set_len(MP_OBJ_FROM_PTR(rest), rest->len - num_right);
     }
-    return;
+    return MP_OBJ_SENTINEL; // success
 
 too_short:
     if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-        mp_raise_ValueError("wrong number of values to unpack");
+        return mp_raise_ValueError_o("wrong number of values to unpack");
     } else {
-        mp_raise_msg_varg(&mp_type_ValueError, "need more than %d values to unpack", (int)seq_len);
+        return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_ValueError,
+            "need more than %d values to unpack", (int)seq_len));
     }
 }
 
@@ -953,7 +980,9 @@
     DEBUG_OP_printf("load attr %p.%s\n", base, qstr_str(attr));
     // use load_method
     mp_obj_t dest[2];
-    mp_load_method(base, attr, dest);
+    if (mp_load_method(base, attr, dest) == MP_OBJ_NULL) {
+        return MP_OBJ_NULL;
+    }
     if (dest[1] == MP_OBJ_NULL) {
         // load_method returned just a normal attribute
         return dest[0];
@@ -981,10 +1010,10 @@
         const mp_obj_type_t *arg0_type = mp_obj_get_type(args[0]);
         if (arg0_type != self->type) {
             if (MICROPY_ERROR_REPORTING != MICROPY_ERROR_REPORTING_DETAILED) {
-                mp_raise_TypeError("argument has wrong type");
+                return mp_raise_TypeError_o("argument has wrong type");
             } else {
-                mp_raise_msg_varg(&mp_type_TypeError,
-                    "argument should be a '%q' not a '%q'", self->type->name, arg0_type->name);
+                return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                    "argument should be a '%q' not a '%q'", self->type->name, arg0_type->name));
             }
         }
     }
@@ -1061,7 +1090,7 @@
 // no attribute found, returns:     dest[0] == MP_OBJ_NULL, dest[1] == MP_OBJ_NULL
 // normal attribute found, returns: dest[0] == <attribute>, dest[1] == MP_OBJ_NULL
 // method attribute found, returns: dest[0] == <method>,    dest[1] == <self>
-void mp_load_method_maybe(mp_obj_t obj, qstr attr, mp_obj_t *dest) {
+mp_obj_t mp_load_method_maybe(mp_obj_t obj, qstr attr, mp_obj_t *dest) {
     // clear output to indicate no attribute/method found yet
     dest[0] = MP_OBJ_NULL;
     dest[1] = MP_OBJ_NULL;
@@ -1074,7 +1103,7 @@
     if (attr == MP_QSTR___class__) {
         // a.__class__ is equivalent to type(a)
         dest[0] = MP_OBJ_FROM_PTR(type);
-        return;
+        return MP_OBJ_SENTINEL; // success
     }
     #endif
 
@@ -1085,6 +1114,9 @@
     } else if (type->attr != NULL) {
         // this type can do its own load, so call it
         type->attr(obj, attr, dest);
+        if (MP_STATE_THREAD(active_exception) != NULL) {
+            return MP_OBJ_NULL;
+        }
 
     } else if (type->locals_dict != NULL) {
         // generic method lookup
@@ -1096,65 +1128,76 @@
             mp_convert_member_lookup(obj, type, elem->value, dest);
         }
     }
+
+    return MP_OBJ_SENTINEL; // success
 }
 
-void mp_load_method(mp_obj_t base, qstr attr, mp_obj_t *dest) {
+mp_obj_t mp_load_method(mp_obj_t base, qstr attr, mp_obj_t *dest) {
     DEBUG_OP_printf("load method %p.%s\n", base, qstr_str(attr));
 
-    mp_load_method_maybe(base, attr, dest);
+    if (mp_load_method_maybe(base, attr, dest) == MP_OBJ_NULL) {
+        // exception
+        return MP_OBJ_NULL;
+    }
 
     if (dest[0] == MP_OBJ_NULL) {
         // no attribute/method called attr
         if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-            mp_raise_msg(&mp_type_AttributeError, "no such attribute");
+            return mp_raise_msg_o(&mp_type_AttributeError, "no such attribute");
         } else {
             // following CPython, we give a more detailed error message for type objects
             if (mp_obj_is_type(base, &mp_type_type)) {
-                mp_raise_msg_varg(&mp_type_AttributeError,
+                return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_AttributeError,
                     "type object '%q' has no attribute '%q'",
-                    ((mp_obj_type_t *)MP_OBJ_TO_PTR(base))->name, attr);
+                    ((mp_obj_type_t *)MP_OBJ_TO_PTR(base))->name, attr));
             } else {
-                mp_raise_msg_varg(&mp_type_AttributeError,
+                return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_AttributeError,
                     "'%s' object has no attribute '%q'",
-                    mp_obj_get_type_str(base), attr);
+                    mp_obj_get_type_str(base), attr));
             }
         }
     }
+
+    return MP_OBJ_SENTINEL; // success
 }
 
 // Acts like mp_load_method_maybe but catches AttributeError, and all other exceptions if requested
-void mp_load_method_protected(mp_obj_t obj, qstr attr, mp_obj_t *dest, bool catch_all_exc) {
-    nlr_buf_t nlr;
-    if (nlr_push(&nlr) == 0) {
-        mp_load_method_maybe(obj, attr, dest);
-        nlr_pop();
-    } else {
+mp_obj_t mp_load_method_protected(mp_obj_t obj, qstr attr, mp_obj_t *dest, bool catch_all_exc) {
+    if (mp_load_method_maybe(obj, attr, dest) == MP_OBJ_NULL) {
+        // exception
+        mp_obj_base_t *exc = MP_STATE_THREAD(active_exception);
+        MP_STATE_THREAD(active_exception) = NULL;
         if (!catch_all_exc
-            && !mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(((mp_obj_base_t *)nlr.ret_val)->type),
+            && !mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(exc->type),
                 MP_OBJ_FROM_PTR(&mp_type_AttributeError))) {
             // Re-raise the exception
-            nlr_raise(MP_OBJ_FROM_PTR(nlr.ret_val));
+            return mp_raise_o(MP_OBJ_FROM_PTR(exc));
         }
     }
+    return MP_OBJ_SENTINEL; // success
 }
 
-void mp_store_attr(mp_obj_t base, qstr attr, mp_obj_t value) {
+mp_obj_t mp_store_attr(mp_obj_t base, qstr attr, mp_obj_t value) {
     DEBUG_OP_printf("store attr %p.%s <- %p\n", base, qstr_str(attr), value);
     const mp_obj_type_t *type = mp_obj_get_type(base);
     if (type->attr != NULL) {
         mp_obj_t dest[2] = {MP_OBJ_SENTINEL, value};
         type->attr(base, attr, dest);
+        if (MP_STATE_THREAD(active_exception) != NULL) {
+            // exception
+            return MP_OBJ_NULL;
+        }
         if (dest[0] == MP_OBJ_NULL) {
             // success
-            return;
+            return MP_OBJ_SENTINEL;
         }
     }
     if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-        mp_raise_msg(&mp_type_AttributeError, "no such attribute");
+        return mp_raise_msg_o(&mp_type_AttributeError, "no such attribute");
     } else {
-        mp_raise_msg_varg(&mp_type_AttributeError,
+        return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_AttributeError,
             "'%s' object has no attribute '%q'",
-            mp_obj_get_type_str(base), attr);
+            mp_obj_get_type_str(base), attr));
     }
 }
 
@@ -1195,10 +1238,10 @@
 
     // object not iterable
     if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-        mp_raise_TypeError("object not iterable");
+        return mp_raise_TypeError_o("object not iterable");
     } else {
-        mp_raise_msg_varg(&mp_type_TypeError,
-            "'%s' object isn't iterable", mp_obj_get_type_str(o_in));
+        return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+            "'%s' object isn't iterable", mp_obj_get_type_str(o_in)));
     }
 }
 
@@ -1217,10 +1260,10 @@
             return mp_call_method_n_kw(0, 0, dest);
         } else {
             if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-                mp_raise_TypeError("object not an iterator");
+                return mp_raise_TypeError_o("object not an iterator");
             } else {
-                mp_raise_msg_varg(&mp_type_TypeError,
-                    "'%s' object isn't an iterator", mp_obj_get_type_str(o_in));
+                return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                    "'%s' object isn't an iterator", mp_obj_get_type_str(o_in)));
             }
         }
     }
@@ -1229,7 +1272,9 @@
 // will always return MP_OBJ_STOP_ITERATION instead of raising StopIteration() (or any subclass thereof)
 // may raise other exceptions
 mp_obj_t mp_iternext(mp_obj_t o_in) {
-    MP_STACK_CHECK(); // enumerate, filter, map and zip can recursively call mp_iternext
+    if (MP_STACK_CHECK()) { // enumerate, filter, map and zip can recursively call mp_iternext
+        return MP_OBJ_NULL;
+    }
     const mp_obj_type_t *type = mp_obj_get_type(o_in);
     if (type->iternext != NULL) {
         return type->iternext(o_in);
@@ -1239,29 +1284,50 @@
         mp_load_method_maybe(o_in, MP_QSTR___next__, dest);
         if (dest[0] != MP_OBJ_NULL) {
             // __next__ exists, call it and return its result
-            nlr_buf_t nlr;
-            if (nlr_push(&nlr) == 0) {
-                mp_obj_t ret = mp_call_method_n_kw(0, 0, dest);
-                nlr_pop();
+            mp_obj_t ret = mp_call_method_n_kw(0, 0, dest);
+            if (ret != MP_OBJ_NULL) {
                 return ret;
             } else {
-                if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(((mp_obj_base_t *)nlr.ret_val)->type), MP_OBJ_FROM_PTR(&mp_type_StopIteration))) {
+                // exception
+                if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(MP_STATE_THREAD(active_exception)->type), MP_OBJ_FROM_PTR(&mp_type_StopIteration))) {
+                    MP_STATE_THREAD(active_exception) = NULL;
                     return MP_OBJ_STOP_ITERATION;
                 } else {
-                    nlr_jump(nlr.ret_val);
+                    // reraise
+                    return MP_OBJ_NULL;
                 }
             }
         } else {
             if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
-                mp_raise_TypeError("object not an iterator");
+                return mp_raise_TypeError_o("object not an iterator");
             } else {
-                mp_raise_msg_varg(&mp_type_TypeError,
-                    "'%s' object isn't an iterator", mp_obj_get_type_str(o_in));
+                return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_TypeError,
+                    "'%s' object isn't an iterator", mp_obj_get_type_str(o_in)));
             }
         }
     }
 }
 
+mp_obj_t mp_iternext2(mp_obj_t o) {
+    if (o == MP_OBJ_NULL) {
+        return MP_OBJ_NULL;
+    }
+    o = mp_iternext(o);
+    if (o == MP_OBJ_STOP_ITERATION) {
+        MP_STATE_THREAD(active_exception) = (void*)1;
+        return MP_OBJ_NULL;
+    }
+    return o;
+}
+
+bool mp_iternext_had_exc(void) {
+    if (MP_STATE_THREAD(active_exception) == (void*)1) {
+        MP_STATE_THREAD(active_exception) = NULL;
+        return false;
+    }
+    return MP_STATE_THREAD(active_exception) != NULL;
+}
+
 // TODO: Unclear what to do with StopIterarion exception here.
 mp_vm_return_kind_t mp_resume(mp_obj_t self_in, mp_obj_t send_value, mp_obj_t throw_value, mp_obj_t *ret_val) {
     assert((send_value != MP_OBJ_NULL) ^ (throw_value != MP_OBJ_NULL));
@@ -1273,6 +1339,12 @@
 
     if (type->iternext != NULL && send_value == mp_const_none) {
         mp_obj_t ret = type->iternext(self_in);
+        if (ret == MP_OBJ_NULL) {
+            // exception
+            *ret_val = MP_OBJ_FROM_PTR(MP_STATE_THREAD(active_exception));
+            MP_STATE_THREAD(active_exception) = NULL;
+            return MP_VM_RETURN_EXCEPTION;
+        }
         *ret_val = ret;
         if (ret != MP_OBJ_STOP_ITERATION) {
             return MP_VM_RETURN_YIELD;
@@ -1290,6 +1362,11 @@
         mp_load_method_maybe(self_in, MP_QSTR___next__, dest);
         if (dest[0] != MP_OBJ_NULL) {
             *ret_val = mp_call_method_n_kw(0, 0, dest);
+            if (*ret_val == MP_OBJ_NULL) {
+                *ret_val = MP_OBJ_FROM_PTR(MP_STATE_THREAD(active_exception));
+                MP_STATE_THREAD(active_exception) = NULL;
+                return MP_VM_RETURN_EXCEPTION;
+            }
             return MP_VM_RETURN_YIELD;
         }
     }
@@ -1390,8 +1467,8 @@
 
     if (dest[1] != MP_OBJ_NULL) {
         // Hopefully we can't import bound method from an object
-    import_error:
-        mp_raise_msg_varg(&mp_type_ImportError, "cannot import name %q", name);
+import_error:
+        return mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_ImportError, "cannot import name %q", name));
     }
 
     if (dest[0] != MP_OBJ_NULL) {
@@ -1458,13 +1535,12 @@
     mp_globals_set(globals);
     mp_locals_set(locals);
 
-    nlr_buf_t nlr;
-    if (nlr_push(&nlr) == 0) {
-        qstr source_name = lex->source_name;
-        mp_parse_tree_t parse_tree = mp_parse(lex, parse_input_kind);
-        mp_obj_t module_fun = mp_compile(&parse_tree, source_name, false);
+    qstr source_name = lex->source_name;
+    mp_parse_tree_t parse_tree = mp_parse(lex, parse_input_kind);
+    mp_obj_t module_fun = mp_compile(&parse_tree, source_name, false);
 
-        mp_obj_t ret;
+    mp_obj_t ret = MP_OBJ_NULL;
+    if (module_fun != MP_OBJ_NULL) {
         if (MICROPY_PY_BUILTINS_COMPILE && globals == NULL) {
             // for compile only, return value is the module function
             ret = module_fun;
@@ -1472,31 +1548,27 @@
             // execute module function and get return value
             ret = mp_call_function_0(module_fun);
         }
-
-        // finish nlr block, restore context and return value
-        nlr_pop();
-        mp_globals_set(old_globals);
-        mp_locals_set(old_locals);
-        return ret;
-    } else {
-        // exception; restore context and re-raise same exception
-        mp_globals_set(old_globals);
-        mp_locals_set(old_locals);
-        nlr_jump(nlr.ret_val);
     }
+
+    // restore context and return value
+    mp_globals_set(old_globals);
+    mp_locals_set(old_locals);
+    return ret;
 }
 
 #endif // MICROPY_ENABLE_COMPILER
 
-NORETURN void m_malloc_fail(size_t num_bytes) {
+void *m_malloc_fail(size_t num_bytes) {
     DEBUG_printf("memory allocation failed, allocating %u bytes\n", (uint)num_bytes);
     #if MICROPY_ENABLE_GC
     if (gc_is_locked()) {
-        mp_raise_msg(&mp_type_MemoryError, "memory allocation failed, heap is locked");
+        mp_raise_msg_o(&mp_type_MemoryError, "memory allocation failed, heap is locked");
+        return NULL;
     }
     #endif
-    mp_raise_msg_varg(&mp_type_MemoryError,
-        "memory allocation failed, allocating %u bytes", (uint)num_bytes);
+    mp_raise_o(mp_obj_new_exception_msg_varg(&mp_type_MemoryError,
+        "memory allocation failed, allocating %u bytes", (uint)num_bytes));
+    return NULL;
 }
 
 NORETURN void mp_raise_msg(const mp_obj_type_t *exc_type, const char *msg) {
@@ -1532,8 +1604,41 @@
 }
 
 #if MICROPY_STACK_CHECK || MICROPY_ENABLE_PYSTACK
-NORETURN void mp_raise_recursion_depth(void) {
-    nlr_raise(mp_obj_new_exception_arg1(&mp_type_RuntimeError,
+void mp_raise_recursion_depth(void) {
+    mp_raise_o(mp_obj_new_exception_arg1(&mp_type_RuntimeError,
         MP_OBJ_NEW_QSTR(MP_QSTR_maximum_space_recursion_space_depth_space_exceeded)));
 }
 #endif
+
+mp_obj_t mp_raise_o(mp_obj_t exc) {
+    //printf("mp_raise_o(%p)\n", MP_OBJ_TO_PTR(exc));
+    // don't overwrite an existing exception
+    if (MP_STATE_THREAD(active_exception) == NULL) {
+        MP_STATE_THREAD(active_exception) = MP_OBJ_TO_PTR(exc);
+    }
+    return MP_OBJ_NULL;
+}
+
+mp_obj_t mp_raise_msg_o(const mp_obj_type_t *exc_type, const char *msg) {
+    if (msg == NULL) {
+        return mp_raise_o(mp_obj_new_exception(exc_type));
+    } else {
+        return mp_raise_o(mp_obj_new_exception_msg(exc_type, msg));
+    }
+}
+
+mp_obj_t mp_raise_ValueError_o(const char *msg) {
+    return mp_raise_msg_o(&mp_type_ValueError, msg);
+}
+
+mp_obj_t mp_raise_TypeError_o(const char *msg) {
+    return mp_raise_msg_o(&mp_type_TypeError, msg);
+}
+
+mp_obj_t mp_raise_NotImplementedError_o(const char *msg) {
+    return mp_raise_msg_o(&mp_type_NotImplementedError, msg);
+}
+
+mp_obj_t mp_raise_OSError_o(int errno_) {
+    return mp_raise_o(mp_obj_new_exception_arg1(&mp_type_OSError, MP_OBJ_NEW_SMALL_INT(errno_)));
+}
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/runtime.h	2020-05-01 00:05:34.704250701 +0200
+++ micropython-master-no_nlr/py/runtime.h	2020-04-30 23:32:39.498154717 +0200
@@ -80,14 +80,14 @@
 // extra printing method specifically for mp_obj_t's which are integral type
 int mp_print_mp_int(const mp_print_t *print, mp_obj_t x, int base, int base_char, int flags, char fill, int width, int prec);
 
-void mp_arg_check_num_sig(size_t n_args, size_t n_kw, uint32_t sig);
-static inline void mp_arg_check_num(size_t n_args, size_t n_kw, size_t n_args_min, size_t n_args_max, bool takes_kw) {
-    mp_arg_check_num_sig(n_args, n_kw, MP_OBJ_FUN_MAKE_SIG(n_args_min, n_args_max, takes_kw));
+int mp_arg_check_num_sig(size_t n_args, size_t n_kw, uint32_t sig);
+static inline int mp_arg_check_num(size_t n_args, size_t n_kw, size_t n_args_min, size_t n_args_max, bool takes_kw) {
+    return mp_arg_check_num_sig(n_args, n_kw, MP_OBJ_FUN_MAKE_SIG(n_args_min, n_args_max, takes_kw));
 }
-void mp_arg_parse_all(size_t n_pos, const mp_obj_t *pos, mp_map_t *kws, size_t n_allowed, const mp_arg_t *allowed, mp_arg_val_t *out_vals);
-void mp_arg_parse_all_kw_array(size_t n_pos, size_t n_kw, const mp_obj_t *args, size_t n_allowed, const mp_arg_t *allowed, mp_arg_val_t *out_vals);
-NORETURN void mp_arg_error_terse_mismatch(void);
-NORETURN void mp_arg_error_unimpl_kw(void);
+int mp_arg_parse_all(size_t n_pos, const mp_obj_t *pos, mp_map_t *kws, size_t n_allowed, const mp_arg_t *allowed, mp_arg_val_t *out_vals);
+int mp_arg_parse_all_kw_array(size_t n_pos, size_t n_kw, const mp_obj_t *args, size_t n_allowed, const mp_arg_t *allowed, mp_arg_val_t *out_vals);
+void mp_arg_error_terse_mismatch(void);
+void mp_arg_error_unimpl_kw(void);
 
 static inline mp_obj_dict_t *mp_locals_get(void) {
     return MP_STATE_THREAD(dict_locals);
@@ -107,8 +107,8 @@
 mp_obj_t mp_load_build_class(void);
 void mp_store_name(qstr qst, mp_obj_t obj);
 void mp_store_global(qstr qst, mp_obj_t obj);
-void mp_delete_name(qstr qst);
-void mp_delete_global(qstr qst);
+mp_obj_t mp_delete_name(qstr qst);
+mp_obj_t mp_delete_global(qstr qst);
 
 mp_obj_t mp_unary_op(mp_unary_op_t op, mp_obj_t arg);
 mp_obj_t mp_binary_op(mp_binary_op_t op, mp_obj_t lhs, mp_obj_t rhs);
@@ -136,23 +136,25 @@
 // prepares argument array suitable for passing to ->call() method of a
 // function object (and mp_call_function_n_kw()).
 // (Only needed in stackless mode.)
-void mp_call_prepare_args_n_kw_var(bool have_self, size_t n_args_n_kw, const mp_obj_t *args, mp_call_args_t *out_args);
+int mp_call_prepare_args_n_kw_var(bool have_self, size_t n_args_n_kw, const mp_obj_t *args, mp_call_args_t *out_args);
 #endif
 
-void mp_unpack_sequence(mp_obj_t seq, size_t num, mp_obj_t *items);
-void mp_unpack_ex(mp_obj_t seq, size_t num, mp_obj_t *items);
+mp_obj_t mp_unpack_sequence(mp_obj_t seq, size_t num, mp_obj_t *items);
+mp_obj_t mp_unpack_ex(mp_obj_t seq, size_t num, mp_obj_t *items);
 mp_obj_t mp_store_map(mp_obj_t map, mp_obj_t key, mp_obj_t value);
 mp_obj_t mp_load_attr(mp_obj_t base, qstr attr);
 void mp_convert_member_lookup(mp_obj_t obj, const mp_obj_type_t *type, mp_obj_t member, mp_obj_t *dest);
-void mp_load_method(mp_obj_t base, qstr attr, mp_obj_t *dest);
-void mp_load_method_maybe(mp_obj_t base, qstr attr, mp_obj_t *dest);
-void mp_load_method_protected(mp_obj_t obj, qstr attr, mp_obj_t *dest, bool catch_all_exc);
-void mp_load_super_method(qstr attr, mp_obj_t *dest);
-void mp_store_attr(mp_obj_t base, qstr attr, mp_obj_t val);
+mp_obj_t mp_load_method(mp_obj_t base, qstr attr, mp_obj_t *dest);
+mp_obj_t mp_load_method_maybe(mp_obj_t base, qstr attr, mp_obj_t *dest);
+mp_obj_t mp_load_method_protected(mp_obj_t obj, qstr attr, mp_obj_t *dest, bool catch_all_exc);
+mp_obj_t mp_load_super_method(qstr attr, mp_obj_t *dest);
+mp_obj_t mp_store_attr(mp_obj_t base, qstr attr, mp_obj_t val);
 
 mp_obj_t mp_getiter(mp_obj_t o, mp_obj_iter_buf_t *iter_buf);
 mp_obj_t mp_iternext_allow_raise(mp_obj_t o); // may return MP_OBJ_STOP_ITERATION instead of raising StopIteration()
 mp_obj_t mp_iternext(mp_obj_t o); // will always return MP_OBJ_STOP_ITERATION instead of raising StopIteration(...)
+mp_obj_t mp_iternext2(mp_obj_t o);
+bool mp_iternext_had_exc(void);
 mp_vm_return_kind_t mp_resume(mp_obj_t self_in, mp_obj_t send_value, mp_obj_t throw_value, mp_obj_t *ret_val);
 
 mp_obj_t mp_make_raise_obj(mp_obj_t o);
@@ -168,7 +170,14 @@
 NORETURN void mp_raise_TypeError(const char *msg);
 NORETURN void mp_raise_NotImplementedError(const char *msg);
 NORETURN void mp_raise_OSError(int errno_);
-NORETURN void mp_raise_recursion_depth(void);
+void mp_raise_recursion_depth(void);
+
+mp_obj_t mp_raise_o(mp_obj_t exc);
+mp_obj_t mp_raise_msg_o(const mp_obj_type_t *exc_type, const char *msg);
+mp_obj_t mp_raise_ValueError_o(const char *msg);
+mp_obj_t mp_raise_TypeError_o(const char *msg);
+mp_obj_t mp_raise_NotImplementedError_o(const char *msg);
+mp_obj_t mp_raise_OSError_o(int errno_);
 
 #if MICROPY_BUILTIN_METHOD_CHECK_SELF_ARG
 #undef mp_check_self
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/runtime_utils.c	2020-04-17 09:19:09.284299403 +0200
+++ micropython-master-no_nlr/py/runtime_utils.c	2020-04-17 12:45:36.391619808 +0200
@@ -28,25 +28,19 @@
 #include "py/runtime.h"
 
 mp_obj_t mp_call_function_1_protected(mp_obj_t fun, mp_obj_t arg) {
-    nlr_buf_t nlr;
-    if (nlr_push(&nlr) == 0) {
-        mp_obj_t ret = mp_call_function_1(fun, arg);
-        nlr_pop();
-        return ret;
-    } else {
-        mp_obj_print_exception(&mp_plat_print, MP_OBJ_FROM_PTR(nlr.ret_val));
-        return MP_OBJ_NULL;
+    mp_obj_t ret = mp_call_function_1(fun, arg);
+    if (ret == MP_OBJ_NULL) {
+        mp_obj_print_exception(&mp_plat_print, MP_OBJ_FROM_PTR(MP_STATE_THREAD(active_exception)));
+        MP_STATE_THREAD(active_exception) = NULL;
     }
+    return ret;
 }
 
 mp_obj_t mp_call_function_2_protected(mp_obj_t fun, mp_obj_t arg1, mp_obj_t arg2) {
-    nlr_buf_t nlr;
-    if (nlr_push(&nlr) == 0) {
-        mp_obj_t ret = mp_call_function_2(fun, arg1, arg2);
-        nlr_pop();
-        return ret;
-    } else {
-        mp_obj_print_exception(&mp_plat_print, MP_OBJ_FROM_PTR(nlr.ret_val));
-        return MP_OBJ_NULL;
+    mp_obj_t ret = mp_call_function_2(fun, arg1, arg2);
+    if (ret == MP_OBJ_NULL) {
+        mp_obj_print_exception(&mp_plat_print, MP_OBJ_FROM_PTR(MP_STATE_THREAD(active_exception)));
+        MP_STATE_THREAD(active_exception) = NULL;
     }
+    return ret;
 }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/scope.c	2020-05-01 00:05:34.704250701 +0200
+++ micropython-master-no_nlr/py/scope.c	2020-04-30 23:32:39.498154717 +0200
@@ -42,6 +42,9 @@
 
 scope_t *scope_new(scope_kind_t kind, mp_parse_node_t pn, qstr source_file, mp_uint_t emit_options) {
     scope_t *scope = m_new0(scope_t, 1);
+    if (scope == NULL) {
+        return NULL;
+    }
     scope->kind = kind;
     scope->pn = pn;
     scope->source_file = source_file;
@@ -56,6 +59,10 @@
     scope->id_info_alloc = MICROPY_ALLOC_SCOPE_ID_INIT;
     scope->id_info = m_new(id_info_t, scope->id_info_alloc);
 
+    if (scope->raw_code == NULL || scope->id_info == NULL) {
+        return NULL;
+    }
+
     return scope;
 }
 
@@ -73,6 +80,9 @@
     // make sure we have enough memory
     if (scope->id_info_len >= scope->id_info_alloc) {
         scope->id_info = m_renew(id_info_t, scope->id_info, scope->id_info_alloc, scope->id_info_alloc + MICROPY_ALLOC_SCOPE_ID_INC);
+        if (scope->id_info == NULL) {
+            return NULL;
+        }
         scope->id_info_alloc += MICROPY_ALLOC_SCOPE_ID_INC;
     }
 
@@ -89,6 +99,9 @@
 }
 
 id_info_t *scope_find(scope_t *scope, qstr qst) {
+    if (scope->id_info == NULL) {
+        return NULL;
+    }
     for (mp_uint_t i = 0; i < scope->id_info_len; i++) {
         if (scope->id_info[i].qst == qst) {
             return &scope->id_info[i];
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/sequence.c	2020-05-01 00:05:34.706250673 +0200
+++ micropython-master-no_nlr/py/sequence.c	2020-04-30 23:32:39.500154689 +0200
@@ -45,7 +45,7 @@
 
 #if MICROPY_PY_BUILTINS_SLICE
 
-bool mp_seq_get_fast_slice_indexes(mp_uint_t len, mp_obj_t slice, mp_bound_slice_t *indexes) {
+int mp_seq_get_fast_slice_indexes(mp_uint_t len, mp_obj_t slice, mp_bound_slice_t *indexes) {
     mp_obj_slice_indices(slice, len, indexes);
 
     // If the index is negative then stop points to the last item, not after it
@@ -202,7 +202,7 @@
         }
     }
 
-    mp_raise_ValueError("object not in sequence");
+    return mp_raise_ValueError_o("object not in sequence");
 }
 
 mp_obj_t mp_seq_count_obj(const mp_obj_t *items, size_t len, mp_obj_t value) {
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/stackctrl.c	2020-05-01 00:05:34.706250673 +0200
+++ micropython-master-no_nlr/py/stackctrl.c	2020-04-30 23:32:39.500154689 +0200
@@ -48,10 +48,12 @@
     MP_STATE_THREAD(stack_limit) = limit;
 }
 
-void mp_stack_check(void) {
+int mp_stack_check(void) {
     if (mp_stack_usage() >= MP_STATE_THREAD(stack_limit)) {
         mp_raise_recursion_depth();
+        return 1;
     }
+    return 0;
 }
 
 #endif // MICROPY_STACK_CHECK
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/stackctrl.h	2020-04-17 09:19:09.284299403 +0200
+++ micropython-master-no_nlr/py/stackctrl.h	2020-04-17 12:45:36.393619783 +0200
@@ -35,13 +35,15 @@
 #if MICROPY_STACK_CHECK
 
 void mp_stack_set_limit(mp_uint_t limit);
-void mp_stack_check(void);
+int mp_stack_check(void);
 #define MP_STACK_CHECK() mp_stack_check()
 
 #else
 
 #define mp_stack_set_limit(limit)
-#define MP_STACK_CHECK()
+static inline int MP_STACK_CHECK(void) {
+    return 0;
+}
 
 #endif
 
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/stream.c	2020-05-01 00:05:34.706250673 +0200
+++ micropython-master-no_nlr/py/stream.c	2020-04-30 23:32:39.500154689 +0200
@@ -92,7 +92,8 @@
         || ((flags & MP_STREAM_OP_WRITE) && stream_p->write == NULL)
         || ((flags & MP_STREAM_OP_IOCTL) && stream_p->ioctl == NULL)) {
         // CPython: io.UnsupportedOperation, OSError subclass
-        mp_raise_msg(&mp_type_OSError, "stream operation not supported");
+        mp_raise_msg_o(&mp_type_OSError, "stream operation not supported");
+        return NULL;
     }
     return stream_p;
 }
@@ -140,7 +141,7 @@
                     }
                     break;
                 }
-                mp_raise_OSError(error);
+                return mp_raise_OSError_o(error);
             }
 
             if (out_sz < more_bytes) {
@@ -208,7 +209,7 @@
             // this as EOF.
             return mp_const_none;
         }
-        mp_raise_OSError(error);
+        return mp_raise_OSError_o(error);
     } else {
         vstr.len = out_sz;
         return mp_obj_new_str_from_vstr(STREAM_CONTENT_TYPE(stream_p), &vstr);
@@ -235,7 +236,7 @@
             // no single byte could be readily written to it."
             return mp_const_none;
         }
-        mp_raise_OSError(error);
+        return mp_raise_OSError_o(error);
     } else {
         return MP_OBJ_NEW_SMALL_INT(out_sz);
     }
@@ -293,7 +294,7 @@
         if (mp_is_nonblocking_error(error)) {
             return mp_const_none;
         }
-        mp_raise_OSError(error);
+        return mp_raise_OSError_o(error);
     } else {
         return MP_OBJ_NEW_SMALL_INT(out_sz);
     }
@@ -312,6 +313,9 @@
         int error;
         mp_uint_t out_sz = stream_p->read(self_in, p, current_read, &error);
         if (out_sz == MP_STREAM_ERROR) {
+            if (MP_STATE_THREAD(active_exception) != NULL) {
+                return MP_OBJ_NULL;
+            }
             if (mp_is_nonblocking_error(error)) {
                 // With non-blocking streams, we read as much as we can.
                 // If we read nothing, return None, just like read().
@@ -321,7 +325,7 @@
                 }
                 break;
             }
-            mp_raise_OSError(error);
+            return mp_raise_OSError_o(error);
         }
         if (out_sz == 0) {
             break;
@@ -361,6 +365,9 @@
         int error;
         mp_uint_t out_sz = stream_p->read(args[0], p, 1, &error);
         if (out_sz == MP_STREAM_ERROR) {
+            if (MP_STATE_THREAD(active_exception) != NULL) {
+                return MP_OBJ_NULL;
+            }
             if (mp_is_nonblocking_error(error)) {
                 if (vstr.len == 1) {
                     // We just incremented it, but otherwise we read nothing
@@ -375,7 +382,7 @@
                     goto done;
                 }
             }
-            mp_raise_OSError(error);
+            return mp_raise_OSError_o(error);
         }
         if (out_sz == 0) {
         done:
@@ -421,7 +428,10 @@
     int error;
     mp_uint_t res = stream_p->ioctl(stream, MP_STREAM_CLOSE, 0, &error);
     if (res == MP_STREAM_ERROR) {
-        mp_raise_OSError(error);
+        if (MP_STATE_THREAD(active_exception) != NULL) {
+            return MP_OBJ_NULL;
+        }
+        return mp_raise_OSError_o(error);
     }
     return mp_const_none;
 }
@@ -438,14 +448,17 @@
 
     // In POSIX, it's error to seek before end of stream, we enforce it here.
     if (seek_s.whence == SEEK_SET && seek_s.offset < 0) {
-        mp_raise_OSError(MP_EINVAL);
+        return mp_raise_OSError_o(MP_EINVAL);
     }
 
     const mp_stream_p_t *stream_p = mp_get_stream(args[0]);
     int error;
     mp_uint_t res = stream_p->ioctl(args[0], MP_STREAM_SEEK, (mp_uint_t)(uintptr_t)&seek_s, &error);
     if (res == MP_STREAM_ERROR) {
-        mp_raise_OSError(error);
+        if (MP_STATE_THREAD(active_exception) != NULL) {
+            return MP_OBJ_NULL;
+        }
+        return mp_raise_OSError_o(error);
     }
 
     // TODO: Could be uint64
@@ -466,7 +479,10 @@
     int error;
     mp_uint_t res = stream_p->ioctl(self, MP_STREAM_FLUSH, 0, &error);
     if (res == MP_STREAM_ERROR) {
-        mp_raise_OSError(error);
+        if (MP_STATE_THREAD(active_exception) != NULL) {
+            return MP_OBJ_NULL;
+        }
+        return mp_raise_OSError_o(error);
     }
     return mp_const_none;
 }
@@ -487,7 +503,10 @@
     int error;
     mp_uint_t res = stream_p->ioctl(args[0], mp_obj_get_int(args[1]), val, &error);
     if (res == MP_STREAM_ERROR) {
-        mp_raise_OSError(error);
+        if (MP_STATE_THREAD(active_exception) != NULL) {
+            return MP_OBJ_NULL;
+        }
+        return mp_raise_OSError_o(error);
     }
 
     return mp_obj_new_int(res);
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/vm.c	2020-05-01 00:05:34.706250673 +0200
+++ micropython-master-no_nlr/py/vm.c	2020-04-30 23:32:39.430155680 +0200
@@ -229,7 +229,21 @@
     // sees that it's possible for us to jump from the dispatch loop to the exception
     // handler.  Without this, the code may have a different stack layout in the dispatch
     // loop and the exception handler, leading to very obscure bugs.
+#if NO_NLR
+    #define RAISE(o) do { MP_STATE_THREAD(active_exception) = MP_OBJ_TO_PTR(o); goto exception_handler; } while (0)
+    //#define RAISE_IT() do { goto exception_handler; } while (0)
+    #define RAISE_IF(arg) if (arg) { goto exception_handler; }
+    #define RAISE_IF_NULL(arg) RAISE_IF(arg == MP_OBJ_NULL)
+    #define THE_EXC the_exc
+    #define TEST_TOP() (*sp)
+#else
     #define RAISE(o) do { nlr_pop(); nlr.ret_val = MP_OBJ_TO_PTR(o); goto exception_handler; } while (0)
+    #define RAISE_IF(condition) { condition; }
+    #define THE_EXC nlr.ret_val
+    #define RAISE_IF_NULL(arg) {arg;}
+    #define TEST_TOP()
+#endif
+
 
 #if MICROPY_STACKLESS
 run_code_state: ;
@@ -261,9 +275,13 @@
 
     // outer exception handling loop
     for (;;) {
+#if NO_NLR
+        {
+#else
         nlr_buf_t nlr;
 outer_dispatch_loop:
         if (nlr_push(&nlr) == 0) {
+#endif
             // local variables that are not visible to the exception handler
             const byte *ip = code_state->ip;
             mp_obj_t *sp = code_state->sp;
@@ -342,8 +360,7 @@
                     if (obj_shared == MP_OBJ_NULL) {
                         local_name_error: {
                             MARK_EXC_IP_SELECTIVE();
-                            mp_obj_t obj = mp_obj_new_exception_msg(&mp_type_NameError, "local variable referenced before assignment");
-                            RAISE(obj);
+                            RAISE(mp_obj_new_exception_msg(&mp_type_NameError, "local variable referenced before assignment"));
                         }
                     }
                     PUSH(obj_shared);
@@ -361,6 +378,7 @@
                     MARK_EXC_IP_SELECTIVE();
                     DECODE_QSTR;
                     PUSH(mp_load_name(qst));
+                    RAISE_IF_NULL(TEST_TOP());
                     DISPATCH();
                 }
                 #else
@@ -373,6 +391,9 @@
                         obj = elem->value;
                     } else {
                         obj = mp_load_name(qst);
+#if NO_NLR
+                        RAISE_IF_NULL(obj);
+#endif
                     }
                     PUSH(obj);
                     ip++;
@@ -385,6 +406,7 @@
                     MARK_EXC_IP_SELECTIVE();
                     DECODE_QSTR;
                     PUSH(mp_load_global(qst));
+                    RAISE_IF_NULL(TEST_TOP());
                     DISPATCH();
                 }
                 #else
@@ -397,6 +419,9 @@
                         obj = elem->value;
                     } else {
                         obj = mp_load_global(qst);
+#if NO_NLR
+                        RAISE_IF_NULL(obj);
+#endif
                     }
                     PUSH(obj);
                     ip++;
@@ -410,6 +435,7 @@
                     MARK_EXC_IP_SELECTIVE();
                     DECODE_QSTR;
                     SET_TOP(mp_load_attr(TOP(), qst));
+                    RAISE_IF_NULL(TEST_TOP());
                     DISPATCH();
                 }
                 #else
@@ -428,6 +454,9 @@
                         obj = elem->value;
                     } else {
                         obj = mp_load_attr(top, qst);
+#if NO_NLR
+                        RAISE_IF_NULL(obj);
+#endif
                     }
                     SET_TOP(obj);
                     ip++;
@@ -438,7 +467,7 @@
                 ENTRY(MP_BC_LOAD_METHOD): {
                     MARK_EXC_IP_SELECTIVE();
                     DECODE_QSTR;
-                    mp_load_method(*sp, qst, sp);
+                    RAISE_IF_NULL(mp_load_method(*sp, qst, sp));
                     sp += 1;
                     DISPATCH();
                 }
@@ -447,7 +476,7 @@
                     MARK_EXC_IP_SELECTIVE();
                     DECODE_QSTR;
                     sp -= 1;
-                    mp_load_super_method(qst, sp - 1);
+                    RAISE_IF_NULL(mp_load_super_method(qst, sp - 1));
                     DISPATCH();
                 }
 
@@ -460,6 +489,7 @@
                     MARK_EXC_IP_SELECTIVE();
                     mp_obj_t index = POP();
                     SET_TOP(mp_obj_subscr(TOP(), index, MP_OBJ_SENTINEL));
+                    RAISE_IF_NULL(TEST_TOP());
                     DISPATCH();
                 }
 
@@ -494,7 +524,7 @@
                     FRAME_UPDATE();
                     MARK_EXC_IP_SELECTIVE();
                     DECODE_QSTR;
-                    mp_store_attr(sp[0], qst, sp[-1]);
+                    RAISE_IF_NULL(mp_store_attr(sp[0], qst, sp[-1]));
                     sp -= 2;
                     DISPATCH();
                 }
@@ -517,7 +547,7 @@
                     if (elem != NULL) {
                         elem->value = sp[-1];
                     } else {
-                        mp_store_attr(sp[0], qst, sp[-1]);
+                        RAISE_IF_NULL(mp_store_attr(sp[0], qst, sp[-1]));
                     }
                     sp -= 2;
                     ip++;
@@ -527,7 +557,7 @@
 
                 ENTRY(MP_BC_STORE_SUBSCR):
                     MARK_EXC_IP_SELECTIVE();
-                    mp_obj_subscr(sp[-1], sp[0], sp[-2]);
+                    RAISE_IF_NULL(mp_obj_subscr(sp[-1], sp[0], sp[-2]));
                     sp -= 3;
                     DISPATCH();
 
@@ -554,14 +584,14 @@
                 ENTRY(MP_BC_DELETE_NAME): {
                     MARK_EXC_IP_SELECTIVE();
                     DECODE_QSTR;
-                    mp_delete_name(qst);
+                    RAISE_IF_NULL(mp_delete_name(qst));
                     DISPATCH();
                 }
 
                 ENTRY(MP_BC_DELETE_GLOBAL): {
                     MARK_EXC_IP_SELECTIVE();
                     DECODE_QSTR;
-                    mp_delete_global(qst);
+                    RAISE_IF_NULL(mp_delete_global(qst));
                     DISPATCH();
                 }
 
@@ -642,9 +672,12 @@
                     MARK_EXC_IP_SELECTIVE();
                     // stack: (..., ctx_mgr)
                     mp_obj_t obj = TOP();
-                    mp_load_method(obj, MP_QSTR___exit__, sp);
-                    mp_load_method(obj, MP_QSTR___enter__, sp + 2);
+                    RAISE_IF_NULL(mp_load_method(obj, MP_QSTR___exit__, sp));
+                    RAISE_IF_NULL(mp_load_method(obj, MP_QSTR___enter__, sp + 2));
                     mp_obj_t ret = mp_call_method_n_kw(0, 0, sp + 2);
+#if NO_NLR
+                    RAISE_IF_NULL(ret);
+#endif
                     sp += 1;
                     PUSH_EXC_BLOCK(1);
                     PUSH(ret);
@@ -665,7 +698,7 @@
                         sp[1] = mp_const_none;
                         sp[2] = mp_const_none;
                         sp -= 2;
-                        mp_call_method_n_kw(3, 0, sp);
+                        RAISE_IF_NULL(mp_call_method_n_kw(3, 0, sp));
                         SET_TOP(mp_const_none);
                     } else if (mp_obj_is_small_int(TOP())) {
                         // Getting here there are two distinct cases:
@@ -790,6 +823,7 @@
                 ENTRY(MP_BC_GET_ITER):
                     MARK_EXC_IP_SELECTIVE();
                     SET_TOP(mp_getiter(TOP(), NULL));
+                    RAISE_IF_NULL(TEST_TOP());
                     DISPATCH();
 
                 // An iterator for a for-loop takes MP_OBJ_ITER_BUF_NSLOTS slots on
@@ -802,6 +836,9 @@
                     mp_obj_iter_buf_t *iter_buf = (mp_obj_iter_buf_t*)sp;
                     sp += MP_OBJ_ITER_BUF_NSLOTS - 1;
                     obj = mp_getiter(obj, iter_buf);
+#if NO_NLR
+                    RAISE_IF_NULL(obj);
+#endif
                     if (obj != MP_OBJ_FROM_PTR(iter_buf)) {
                         // Iterator didn't use the stack so indicate that with MP_OBJ_NULL.
                         sp[-MP_OBJ_ITER_BUF_NSLOTS + 1] = MP_OBJ_NULL;
@@ -825,6 +862,17 @@
                     if (value == MP_OBJ_STOP_ITERATION) {
                         sp -= MP_OBJ_ITER_BUF_NSLOTS; // pop the exhausted iterator
                         ip += ulab; // jump to after for-block
+#if NO_NLR
+                    } else if (value == MP_OBJ_NULL) {
+                        // raised an exception
+                        if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(MP_STATE_THREAD(active_exception)->type), MP_OBJ_FROM_PTR(&mp_type_StopIteration))) {
+                            MP_STATE_THREAD(active_exception) = NULL;
+                            sp -= MP_OBJ_ITER_BUF_NSLOTS; // pop the exhausted iterator
+                            ip += ulab; // jump to after for-block
+                        } else {
+                            RAISE_IF(true);
+                        }
+#endif
                     } else {
                         PUSH(value); // push the next iteration value
                         #if MICROPY_PY_SYS_SETTRACE
@@ -850,6 +898,7 @@
                     DECODE_UINT;
                     sp -= unum - 1;
                     SET_TOP(mp_obj_new_tuple(unum, sp));
+                    RAISE_IF_NULL(TEST_TOP());
                     DISPATCH();
                 }
 
@@ -858,6 +907,7 @@
                     DECODE_UINT;
                     sp -= unum - 1;
                     SET_TOP(mp_obj_new_list(unum, sp));
+                    RAISE_IF_NULL(TEST_TOP());
                     DISPATCH();
                 }
 
@@ -865,13 +915,14 @@
                     MARK_EXC_IP_SELECTIVE();
                     DECODE_UINT;
                     PUSH(mp_obj_new_dict(unum));
+                    RAISE_IF_NULL(TEST_TOP());
                     DISPATCH();
                 }
 
                 ENTRY(MP_BC_STORE_MAP):
                     MARK_EXC_IP_SELECTIVE();
                     sp -= 2;
-                    mp_obj_dict_store(sp[0], sp[2], sp[1]);
+                    RAISE_IF_NULL(mp_obj_dict_store(sp[0], sp[2], sp[1]));
                     DISPATCH();
 
 #if MICROPY_PY_BUILTINS_SET
@@ -880,6 +931,7 @@
                     DECODE_UINT;
                     sp -= unum - 1;
                     SET_TOP(mp_obj_new_set(unum, sp));
+                    RAISE_IF_NULL(TEST_TOP());
                     DISPATCH();
                 }
 #endif
@@ -895,6 +947,7 @@
                     mp_obj_t stop = POP();
                     mp_obj_t start = TOP();
                     SET_TOP(mp_obj_new_slice(start, stop, step));
+                    RAISE_IF_NULL(TEST_TOP());
                     DISPATCH();
                 }
 #endif
@@ -921,7 +974,7 @@
                 ENTRY(MP_BC_UNPACK_SEQUENCE): {
                     MARK_EXC_IP_SELECTIVE();
                     DECODE_UINT;
-                    mp_unpack_sequence(sp[0], unum, sp);
+                    RAISE_IF_NULL(mp_unpack_sequence(sp[0], unum, sp));
                     sp += unum - 1;
                     DISPATCH();
                 }
@@ -929,7 +982,7 @@
                 ENTRY(MP_BC_UNPACK_EX): {
                     MARK_EXC_IP_SELECTIVE();
                     DECODE_UINT;
-                    mp_unpack_ex(sp[0], unum, sp);
+                    RAISE_IF_NULL(mp_unpack_ex(sp[0], unum, sp));
                     sp += (unum & 0xff) + ((unum >> 8) & 0xff);
                     DISPATCH();
                 }
@@ -986,18 +1039,23 @@
                             #if MICROPY_STACKLESS_STRICT
                         deep_recursion_error:
                             mp_raise_recursion_depth();
+                            RAISE_IF(true);
                             #endif
                         } else
                         #endif
                         {
                             new_state->prev = code_state;
                             code_state = new_state;
+#if NO_NLR
+#else
                             nlr_pop();
+#endif
                             goto run_code_state;
                         }
                     }
                     #endif
                     SET_TOP(mp_call_function_n_kw(*sp, unum & 0xff, (unum >> 8) & 0xff, sp + 1));
+                    RAISE_IF_NULL(TEST_TOP());
                     DISPATCH();
                 }
 
@@ -1017,8 +1075,7 @@
                         code_state->exc_sp_idx = MP_CODE_STATE_EXC_SP_IDX_FROM_PTR(exc_stack, exc_sp);
 
                         mp_call_args_t out_args;
-                        mp_call_prepare_args_n_kw_var(false, unum, sp, &out_args);
-
+                        RAISE_IF(mp_call_prepare_args_n_kw_var(false, unum, sp, &out_args));
                         mp_code_state_t *new_state = mp_obj_fun_bc_prepare_codestate(out_args.fun,
                             out_args.n_args, out_args.n_kw, out_args.args);
                         #if !MICROPY_ENABLE_PYSTACK
@@ -1038,12 +1095,16 @@
                         {
                             new_state->prev = code_state;
                             code_state = new_state;
+#if NO_NLR
+#else
                             nlr_pop();
+#endif
                             goto run_code_state;
                         }
                     }
                     #endif
                     SET_TOP(mp_call_method_n_kw_var(false, unum, sp));
+                    RAISE_IF_NULL(TEST_TOP());
                     DISPATCH();
                 }
 
@@ -1077,12 +1138,16 @@
                         {
                             new_state->prev = code_state;
                             code_state = new_state;
+#if NO_NLR
+#else
                             nlr_pop();
+#endif
                             goto run_code_state;
                         }
                     }
                     #endif
                     SET_TOP(mp_call_method_n_kw(unum & 0xff, (unum >> 8) & 0xff, sp));
+                    RAISE_IF_NULL(TEST_TOP());
                     DISPATCH();
                 }
 
@@ -1102,7 +1167,8 @@
                         code_state->exc_sp_idx = MP_CODE_STATE_EXC_SP_IDX_FROM_PTR(exc_stack, exc_sp);
 
                         mp_call_args_t out_args;
-                        mp_call_prepare_args_n_kw_var(true, unum, sp, &out_args);
+#warning no NULL test ?
+                        RAISE_IF(mp_call_prepare_args_n_kw_var(true, unum, sp, &out_args));
 
                         mp_code_state_t *new_state = mp_obj_fun_bc_prepare_codestate(out_args.fun,
                             out_args.n_args, out_args.n_kw, out_args.args);
@@ -1123,12 +1189,16 @@
                         {
                             new_state->prev = code_state;
                             code_state = new_state;
+#if NO_NLR
+#else
                             nlr_pop();
+#endif
                             goto run_code_state;
                         }
                     }
                     #endif
                     SET_TOP(mp_call_method_n_kw_var(true, unum, sp));
+                    RAISE_IF_NULL(TEST_TOP());
                     DISPATCH();
                 }
 
@@ -1166,7 +1236,10 @@
                         }
                         POP_EXC_BLOCK();
                     }
+#if NO_NLR
+#else
                     nlr_pop();
+#endif
                     code_state->sp = sp;
                     assert(exc_sp == exc_stack - 1);
                     MICROPY_VM_HOOK_RETURN
@@ -1222,7 +1295,6 @@
 
                 ENTRY(MP_BC_YIELD_VALUE):
 yield:
-                    nlr_pop();
                     code_state->ip = ip;
                     code_state->sp = sp;
                     code_state->exc_sp_idx = MP_CODE_STATE_EXC_SP_IDX_FROM_PTR(exc_stack, exc_sp);
@@ -1238,7 +1310,10 @@
                     mp_obj_t send_value = POP();
                     mp_obj_t t_exc = MP_OBJ_NULL;
                     mp_obj_t ret_value;
+#if NO_NLR
+#else
                     code_state->sp = sp; // Save sp because it's needed if mp_resume raises StopIteration
+#endif
                     if (inject_exc != MP_OBJ_NULL) {
                         t_exc = inject_exc;
                         inject_exc = MP_OBJ_NULL;
@@ -1268,9 +1343,20 @@
                         DISPATCH();
                     } else {
                         assert(ret_kind == MP_VM_RETURN_EXCEPTION);
+#if NO_NLR
+                        // Pop exhausted gen
+                        sp--;
+                        if (EXC_MATCH(ret_value, MP_OBJ_FROM_PTR(&mp_type_StopIteration))) {
+                            // StopIteration inside yield from call means return a value of
+                            // yield from, so inject exception's value as yield from's result
+                            PUSH(mp_obj_exception_get_value(MP_OBJ_FROM_PTR(ret_value)));
+                            DISPATCH();
+                        }
+#else
                         assert(!EXC_MATCH(ret_value, MP_OBJ_FROM_PTR(&mp_type_StopIteration)));
                         // Pop exhausted gen
                         sp--;
+#endif
                         RAISE(ret_value);
                     }
                 }
@@ -1281,6 +1367,7 @@
                     DECODE_QSTR;
                     mp_obj_t obj = POP();
                     SET_TOP(mp_import_name(qst, obj, TOP()));
+                    RAISE_IF_NULL(TEST_TOP());
                     DISPATCH();
                 }
 
@@ -1289,6 +1376,9 @@
                     MARK_EXC_IP_SELECTIVE();
                     DECODE_QSTR;
                     mp_obj_t obj = mp_import_from(TOP(), qst);
+#if NO_NLR
+                    RAISE_IF_NULL(obj);
+#endif
                     PUSH(obj);
                     DISPATCH();
                 }
@@ -1314,6 +1404,7 @@
                 ENTRY(MP_BC_UNARY_OP_MULTI):
                     MARK_EXC_IP_SELECTIVE();
                     SET_TOP(mp_unary_op(ip[-1] - MP_BC_UNARY_OP_MULTI, TOP()));
+                    RAISE_IF_NULL(TEST_TOP());
                     DISPATCH();
 
                 ENTRY(MP_BC_BINARY_OP_MULTI): {
@@ -1321,6 +1412,7 @@
                     mp_obj_t rhs = POP();
                     mp_obj_t lhs = TOP();
                     SET_TOP(mp_binary_op(ip[-1] - MP_BC_BINARY_OP_MULTI, lhs, rhs));
+                    RAISE_IF_NULL(TEST_TOP());
                     DISPATCH();
                 }
 
@@ -1331,26 +1423,34 @@
                     if (ip[-1] < MP_BC_LOAD_CONST_SMALL_INT_MULTI + MP_BC_LOAD_CONST_SMALL_INT_MULTI_NUM) {
                         PUSH(MP_OBJ_NEW_SMALL_INT((mp_int_t)ip[-1] - MP_BC_LOAD_CONST_SMALL_INT_MULTI - MP_BC_LOAD_CONST_SMALL_INT_MULTI_EXCESS));
                         DISPATCH();
+
                     } else if (ip[-1] < MP_BC_LOAD_FAST_MULTI + MP_BC_LOAD_FAST_MULTI_NUM) {
                         obj_shared = fastn[MP_BC_LOAD_FAST_MULTI - (mp_int_t)ip[-1]];
                         goto load_check;
+
                     } else if (ip[-1] < MP_BC_STORE_FAST_MULTI + MP_BC_STORE_FAST_MULTI_NUM) {
                         fastn[MP_BC_STORE_FAST_MULTI - (mp_int_t)ip[-1]] = POP();
                         DISPATCH();
                     } else if (ip[-1] < MP_BC_UNARY_OP_MULTI + MP_BC_UNARY_OP_MULTI_NUM) {
                         SET_TOP(mp_unary_op(ip[-1] - MP_BC_UNARY_OP_MULTI, TOP()));
+                        RAISE_IF_NULL(TEST_TOP());
                         DISPATCH();
+
                     } else if (ip[-1] < MP_BC_BINARY_OP_MULTI + MP_BC_BINARY_OP_MULTI_NUM) {
-                        mp_obj_t rhs = POP();
+                        mp_obj_t rhs = POP();  // XXX may now be unreachable
                         mp_obj_t lhs = TOP();
                         SET_TOP(mp_binary_op(ip[-1] - MP_BC_BINARY_OP_MULTI, lhs, rhs));
+                        RAISE_IF_NULL(TEST_TOP());
                         DISPATCH();
+
                     } else
 #endif
                 {
-
                     mp_obj_t obj = mp_obj_new_exception_msg(&mp_type_NotImplementedError, "opcode");
+#if NO_NLR
+#else
                     nlr_pop();
+#endif
                     code_state->state[0] = obj;
                     FRAME_LEAVE();
                     return MP_VM_RETURN_EXCEPTION;
@@ -1410,19 +1510,35 @@
 
             } // for loop
 
+#if !NO_NLR
         } else {
 exception_handler:
             // exception occurred
+#else
+        }
+        {
+exception_handler:
+            // exception occurred
+            assert(MP_STATE_THREAD(active_exception) != NULL);
 
-            #if MICROPY_PY_SYS_EXC_INFO
+            // clear exception because we caught it
+            mp_obj_base_t *the_exc = MP_STATE_THREAD(active_exception);
+            MP_STATE_THREAD(active_exception) = NULL;
+#endif
+             #if MICROPY_PY_SYS_EXC_INFO
+#if !NO_NLR
             MP_STATE_VM(cur_exception) = nlr.ret_val;
-            #endif
+#else
+            MP_STATE_VM(cur_exception) = the_exc;
+#endif
+             #endif
 
             #if SELECTIVE_EXC_IP
             // with selective ip, we store the ip 1 byte past the opcode, so move ptr back
             code_state->ip -= 1;
             #endif
 
+#if !NO_NLR
             if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(((mp_obj_base_t*)nlr.ret_val)->type), MP_OBJ_FROM_PTR(&mp_type_StopIteration))) {
                 if (code_state->ip) {
                     // check if it's a StopIteration within a for block
@@ -1449,6 +1565,15 @@
                 TRACE_TICK(code_state->ip, code_state->sp, true /* yes, it's an exception */);
             }
             #endif
+#else
+            #if MICROPY_PY_SYS_SETTRACE
+            // Exceptions are traced here
+            if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(((mp_obj_base_t*)the_exc)->type), MP_OBJ_FROM_PTR(&mp_type_Exception))) {
+                TRACE_TICK(code_state->ip, code_state->sp, true /* yes, it's an exception */);
+            }
+            #endif
+#endif
+
 
 #if MICROPY_STACKLESS
 unwind_loop:
@@ -1457,7 +1582,11 @@
             // - constant GeneratorExit object, because it's const
             // - exceptions re-raised by END_FINALLY
             // - exceptions re-raised explicitly by "raise"
-            if (nlr.ret_val != &mp_const_GeneratorExit_obj
+#if !NO_NLR
+            if (THE_EXC != &mp_const_GeneratorExit_obj
+#else
+            if (THE_EXC != &mp_const_GeneratorExit_obj.base
+#endif
                 && *code_state->ip != MP_BC_END_FINALLY
                 && *code_state->ip != MP_BC_RAISE_LAST) {
                 const byte *ip = code_state->fun_bc->bytecode;
@@ -1480,7 +1609,7 @@
                 ip = mp_decode_uint_skip(ip);
                 #endif
                 size_t source_line = mp_bytecode_get_source_line(ip, bc);
-                mp_obj_exception_add_traceback(MP_OBJ_FROM_PTR(nlr.ret_val), source_file, source_line, block_name);
+                mp_obj_exception_add_traceback(MP_OBJ_FROM_PTR(THE_EXC), source_file, source_line, block_name);
             }
 
             while (exc_sp >= exc_stack && exc_sp->handler <= code_state->ip) {
@@ -1501,9 +1630,9 @@
                 code_state->ip = exc_sp->handler;
                 mp_obj_t *sp = MP_TAGPTR_PTR(exc_sp->val_sp);
                 // save this exception in the stack so it can be used in a reraise, if needed
-                exc_sp->prev_exc = nlr.ret_val;
+                exc_sp->prev_exc = THE_EXC;
                 // push exception object so it can be handled by bytecode
-                PUSH(MP_OBJ_FROM_PTR(nlr.ret_val));
+                PUSH(MP_OBJ_FROM_PTR(THE_EXC));
                 code_state->sp = sp;
 
             #if MICROPY_STACKLESS
@@ -1529,7 +1658,7 @@
             } else {
                 // propagate exception to higher level
                 // Note: ip and sp don't have usable values at this point
-                code_state->state[0] = MP_OBJ_FROM_PTR(nlr.ret_val); // put exception here because sp is invalid
+                code_state->state[0] = MP_OBJ_FROM_PTR(THE_EXC); // put exception here because sp is invalid
                 FRAME_LEAVE();
                 return MP_VM_RETURN_EXCEPTION;
             }
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/py/vstr.c	2020-05-01 00:05:34.706250673 +0200
+++ micropython-master-no_nlr/py/vstr.c	2020-04-30 23:32:39.500154689 +0200
@@ -95,7 +95,8 @@
     if (vstr->fixed_buf) {
         // We can't reallocate, and the caller is expecting the space to
         // be there, so the only safe option is to raise an exception.
-        mp_raise_msg(&mp_type_RuntimeError, NULL);
+        mp_raise_msg_o(&mp_type_RuntimeError, NULL);
+        return NULL;
     }
     char *new_buf = m_renew(char, vstr->buf, vstr->alloc, vstr->alloc + size);
     char *p = new_buf + vstr->alloc;
@@ -104,18 +105,24 @@
     return p;
 }
 
-STATIC void vstr_ensure_extra(vstr_t *vstr, size_t size) {
+STATIC int vstr_ensure_extra(vstr_t *vstr, size_t size) {
+    if (vstr->buf == NULL) {
+        // could not allocate a buffer
+        return -1;
+    }
     if (vstr->len + size > vstr->alloc) {
         if (vstr->fixed_buf) {
             // We can't reallocate, and the caller is expecting the space to
             // be there, so the only safe option is to raise an exception.
-            mp_raise_msg(&mp_type_RuntimeError, NULL);
+            mp_raise_msg_o(&mp_type_RuntimeError, NULL);
+            return -1;
         }
         size_t new_alloc = ROUND_ALLOC((vstr->len + size) + 16);
         char *new_buf = m_renew(char, vstr->buf, vstr->alloc, new_alloc);
         vstr->alloc = new_alloc;
         vstr->buf = new_buf;
     }
+    return 0;
 }
 
 void vstr_hint_size(vstr_t *vstr, size_t size) {
@@ -133,7 +140,9 @@
 char *vstr_null_terminated_str(vstr_t *vstr) {
     // If there's no more room, add single byte
     if (vstr->alloc == vstr->len) {
-        vstr_extend(vstr, 1);
+        if (vstr_extend(vstr, 1) == NULL) {
+            return NULL;
+        }
     }
     vstr->buf[vstr->len] = '\0';
     return vstr->buf;
@@ -173,14 +182,17 @@
     #endif
 }
 
-void vstr_add_str(vstr_t *vstr, const char *str) {
-    vstr_add_strn(vstr, str, strlen(str));
+int vstr_add_str(vstr_t *vstr, const char *str) {
+    return vstr_add_strn(vstr, str, strlen(str));
 }
 
-void vstr_add_strn(vstr_t *vstr, const char *str, size_t len) {
-    vstr_ensure_extra(vstr, len);
+int vstr_add_strn(vstr_t *vstr, const char *str, size_t len) {
+    if (vstr_ensure_extra(vstr, len)) {
+        return -1;
+    }
     memmove(vstr->buf + vstr->len, str, len);
     vstr->len += len;
+    return 0; // success
 }
 
 STATIC char *vstr_ins_blank_bytes(vstr_t *vstr, size_t byte_pos, size_t byte_len) {
--- git-ad9a0ec8abc9d04b93b949831b7152f55ca0d7ac/tests/run-tests	2020-05-01 01:09:34.241637894 +0200
+++ micropython-master-no_nlr/tests/run-tests	2020-05-01 00:57:32.199592749 +0200
@@ -49,7 +49,7 @@
     return bytes(''.join(cs), 'utf8')
 
 
-def run_micropython(pyb, args, test_file, is_special=False):
+def run_micropython(pyb, args, test_file, is_special=False, crash_info=None):
     special_tests = (
         'micropython/meminfo.py', 'basics/bytes_compare3.py',
         'basics/builtin_help.py', 'thread/thread_exc2.py',
@@ -128,6 +128,9 @@
             if args.heapsize is not None:
                 cmdlist.extend(['-X', 'heapsize=' + args.heapsize])
 
+            if hasattr(args, 'alloc_max'):
+                cmdlist.extend(['-X', 'alloc-max=' + str(args.alloc_max)])
+
             # if running via .mpy, first compile the .py file
             if args.via_mpy:
                 subprocess.check_output([MPYCROSS] + args.mpy_cross_flags.split() + ['-o', 'mpytest.mpy', '-X', 'emit=' + args.emit, test_file])
@@ -140,7 +143,10 @@
                 output_mupy = subprocess.check_output(cmdlist, stderr=subprocess.STDOUT)
             except subprocess.CalledProcessError as er:
                 had_crash = True
+                #print(er, dir(er), er.args, er.cmd, er.output, er.returncode)
                 output_mupy = er.output + b'CRASH'
+                if crash_info is not None:
+                    crash_info[0] = er.returncode
 
             # clean up if we had an intermediate .mpy file
             if args.via_mpy:
@@ -467,6 +473,34 @@
             skipped_tests.append(test_name)
             continue
 
+        # set to True to run special OOM testing
+        if False:
+            print("run", test_file)
+            got_success = 0
+            args.alloc_max = 0
+            while True:
+                rc = [0]
+                output_mupy = run_micropython(pyb, args, test_file, crash_info=rc)
+                if rc[0] == 2 and 0 <= args.alloc_max <= 5:
+                    # accept uncaught NLR for first 6 allocs (not handled properly by unix port)
+                    continue
+                elif output_mupy == b'SKIP\n':
+                    print("skip ", test_file)
+                    skipped_tests.append(test_name)
+                    break
+                elif args.alloc_max > 1000:
+                    print("no success", args.alloc_max, test_file)
+                    break
+                elif rc[0] == 0:
+                    got_success += 1
+                    if got_success >= 3:
+                        break
+                elif rc[0] != 1:
+                    print(args.alloc_max, rc[0])
+                args.alloc_max += 1
+
+            continue
+
         # get expected output
         test_file_expected = test_file + '.exp'
         if os.path.isfile(test_file_expected):
